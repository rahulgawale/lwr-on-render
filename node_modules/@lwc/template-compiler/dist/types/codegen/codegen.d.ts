import * as t from '../shared/estree';
import { ChildNode, Element, Expression, Literal, LWCDirectiveRenderMode, Root } from '../shared/types';
import State from '../state';
export default class CodeGen {
    /** The AST root. */
    readonly root: Root;
    /** The template render mode. */
    readonly renderMode: LWCDirectiveRenderMode;
    /** Indicates whether the generated code should preserve HTML comments or not. */
    readonly preserveComments: boolean;
    /**
     * This flag indicates if the generated code should scope the template fragment id. It is set to
     * true if the template also contains ids.
     *
     * TODO [#1150]: Remove this code once we can figure out how to do this in a deterministic
     * fashion.
     */
    readonly scopeFragmentId: boolean;
    /**
     * The scope keeps track of the identifiers that have been seen while traversing the AST.
     * Currently, we are keeping track of item, index and iterator on the ForEach and ForOf nodes respectively.
     *
     * Scope is used in bindExpression to determine if the expression is a known identifier.
     * A known identifier exists if it exists in the scope chain.
     */
    private scope;
    readonly staticNodes: Set<ChildNode>;
    readonly hoistedNodes: Array<{
        identifier: t.Identifier;
        expr: t.Expression;
    }>;
    /**
     * State maintains information about the current compilation configs.
     */
    readonly state: State;
    currentId: number;
    currentKey: number;
    innerHtmlInstances: number;
    usedApis: {
        [name: string]: t.Identifier;
    };
    usedLwcApis: Set<string>;
    slotNames: Set<string>;
    memorizedIds: t.Identifier[];
    referencedComponents: Set<string>;
    constructor({ root, state, scopeFragmentId, }: {
        root: Root;
        state: State;
        scopeFragmentId: boolean;
    });
    generateKey(): number;
    genElement(tagName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genCustomElement(tagName: string, componentClass: t.Identifier, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genDynamicElement(tagName: string, ctor: t.Expression, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genText(value: Array<string | t.Expression>): t.Expression;
    genComment(value: string): t.Expression;
    genSanitizeHtmlContent(content: t.Expression): t.Expression;
    genIterator(iterable: t.Expression, callback: t.FunctionExpression): import("estree").CallExpression;
    genBind(handler: t.Expression): import("estree").CallExpression;
    genFlatten(children: t.Expression[]): import("estree").CallExpression;
    genKey(compilerKey: t.SimpleLiteral, value: t.Expression): import("estree").CallExpression;
    genScopedId(id: string | t.Expression): t.CallExpression;
    genScopedFragId(id: string | t.Expression): t.CallExpression;
    getSlot(slotName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genTabIndex(children: [t.Expression]): import("estree").CallExpression;
    getMemorizationId(): import("estree").Identifier;
    genBooleanAttributeExpr(bindExpr: t.Expression): import("estree").ConditionalExpression;
    /**
     * This routine generates an expression that avoids
     * computing the sanitized html of a raw html if it does not change
     * between renders.
     *
     * @param expr
     * @returns sanitizedHtmlExpr
     */
    genSanitizedHtmlExpr(expr: t.Expression): import("estree").LogicalExpression | import("estree").ConditionalExpression;
    private _renderApiCall;
    beginScope(): void;
    private createScope;
    endScope(): void;
    declareIdentifier(identifier: t.Identifier): void;
    /**
     * Searches the scopes to find an identifier with a matching name.
     */
    isLocalIdentifier(identifier: t.Identifier): boolean;
    /**
     * Bind the passed expression to the component instance. It applies the following transformation to the expression:
     * - {value} --> {$cmp.value}
     * - {value[index]} --> {$cmp.value[$cmp.index]}
     */
    bindExpression(expression: Expression | Literal): t.Expression;
    genHoistedElement(element: Element, slotParentName?: string): t.Expression;
}
