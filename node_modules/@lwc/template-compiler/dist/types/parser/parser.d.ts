import { CompilerDiagnostic, LWCErrorInfo } from '@lwc/errors';
import { NormalizedConfig } from '../config';
import { Root, SourceLocation, ParentNode, BaseNode, LWCDirectiveRenderMode } from '../shared/types';
interface ParentWrapper {
    parent: ParentNode | null;
    current: ParentNode;
}
export default class ParserCtx {
    private readonly source;
    readonly config: NormalizedConfig;
    readonly warnings: CompilerDiagnostic[];
    readonly seenIds: Set<string>;
    readonly seenSlots: Set<string>;
    /**
     * Scopes keep track of the hierarchy of ParentNodes as the parser traverses the parse5 AST.
     * Each scope is represented by an array where each node in the array correspond to either
     * a ForEach, ForOf, If, Element, Component, or Slot.
     *
     * Currently, each scope has a hierarchy of ForBlock > IfBlock > Element | Component | Slot.
     * Note: Not all scopes will have all three, but when they do, they will appear in this order.
     * We do not keep track of template nodes.
     *
     * Each scope corresponds to the original parse5.Element node.
     */
    private readonly scopes;
    renderMode: LWCDirectiveRenderMode;
    preserveComments: boolean;
    constructor(source: String, config: NormalizedConfig);
    getSource(start: number, end: number): string;
    setRootDirective(root: Root): void;
    /**
     * This method flattens the scopes into a single array for traversal.
     */
    ancestors(element?: ParentNode): IterableIterator<ParentWrapper>;
    /**
     * This method returns an iterator over ancestor nodes, starting at the parent and ending at the root node.
     *
     * Note: There are instances when we want to terminate the traversal early, such as searching for a ForBlock parent.
     *
     * @param {ParentNode} startNode - Starting node to begin search, defaults to the tail of the current scope.
     * @param {function} predicate - This callback is called once for each ancestor until it finds one where predicate returns true.
     * @param {function} traversalCond - This callback is called after predicate and will terminate the traversal if it returns false.
     * traversalCond is ignored if no value is provided.
     */
    findAncestor<A extends ParentNode>(predicate: (node: ParentNode) => node is A, traversalCond?: (nodes: ParentWrapper) => unknown, startNode?: ParentNode): A | null;
    /**
     * This method searchs the current scope and returns the value that satisfies the predicate.
     *
     * @param {function} predicate - This callback is called once for each sibling in the current scope
     * until it finds one where predicate returns true.
     */
    findSibling<A extends ParentNode>(predicate: (node: ParentNode) => node is A): A | null;
    beginScope(): void;
    endScope(): void;
    addNodeCurrentScope(node: ParentNode): void;
    private currentScope;
    /**
     * This method recovers from diagnostic errors that are encountered when fn is invoked.
     * All other errors are considered compiler errors and can not be recovered from.
     *
     * @param fn - method to be invoked.
     */
    withErrorRecovery<T>(fn: () => T): T | undefined;
    withErrorWrapping<T>(fn: () => T, errorInfo: LWCErrorInfo, location: SourceLocation, msgFormatter?: (error: any) => string): T;
    throwOnError(errorInfo: LWCErrorInfo, error: any, location?: SourceLocation): never;
    /**
     * This method throws a diagnostic error with the node's location.
     */
    throwOnNode(errorInfo: LWCErrorInfo, node: BaseNode, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error with location information.
     */
    throwAtLocation(errorInfo: LWCErrorInfo, location: SourceLocation, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error and will immediately exit the current routine.
     */
    throw(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: SourceLocation): never;
    /**
     * This method logs a diagnostic warning with the node's location.
     */
    warnOnNode(errorInfo: LWCErrorInfo, node: BaseNode, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning with location information.
     */
    warnAtLocation(errorInfo: LWCErrorInfo, location: SourceLocation, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning and will continue execution of the current routine.
     */
    warn(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: SourceLocation): void;
    private addDiagnostic;
}
export {};
