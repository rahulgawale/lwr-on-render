/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { SymbolFor as SymbolFor$LWS, LOCKER_UNMINIFIED_FLAG as LOCKER_UNMINIFIED_FLAG$LWS, ArrayIsArray as ArrayIsArray$1$LWS, ReflectDefineProperty as ReflectDefineProperty$LWS, isNearMembrane as isNearMembrane$LWS, ReflectApply as ReflectApply$1$LWS, ArrayProtoPush as ArrayProtoPush$1$LWS, ObjectProtoToString as ObjectProtoToString$LWS, ObjectKeys as ObjectKeys$LWS, TO_STRING_BRAND_SYMBOL as TO_STRING_BRAND_SYMBOL$LWS, ArrayProtoIncludes as ArrayProtoIncludes$1$LWS, ArrayProtoUnshift as ArrayProtoUnshift$1$LWS, TO_STRING_BRAND_STRING as TO_STRING_BRAND_STRING$LWS, ArrayProtoFilter as ArrayProtoFilter$1$LWS, NumberIsInteger as NumberIsInteger$LWS, MathMin as MathMin$LWS, CHAR_ELLIPSIS as CHAR_ELLIPSIS$LWS, StringProtoSlice as StringProtoSlice$LWS, StringCtor as StringCtor$LWS, getNearMembraneSerializedValue as getNearMembraneSerializedValue$LWS, TO_STRING_BRAND_NUMBER as TO_STRING_BRAND_NUMBER$LWS, TO_STRING_BRAND_BOOLEAN as TO_STRING_BRAND_BOOLEAN$LWS, TO_STRING_BRAND_BIG_INT as TO_STRING_BRAND_BIG_INT$LWS, ReflectOwnKeys as ReflectOwnKeys$1$LWS, ArrayProtoSort as ArrayProtoSort$1$LWS, isObject as isObject$LWS, NumberIsFinite as NumberIsFinite$LWS, JSONStringify as JSONStringify$LWS, RegExpProtoTest as RegExpProtoTest$LWS, StringProtoStartsWith as StringProtoStartsWith$LWS, toSafeArray as toSafeArray$1$LWS, StringProtoToLowerCase as StringProtoToLowerCase$LWS, StringProtoEndsWith as StringProtoEndsWith$LWS, StringProtoIncludes as StringProtoIncludes$LWS, StringProtoReplace as StringProtoReplace$LWS, toSafeWeakMap as toSafeWeakMap$1$LWS, WeakMapCtor as WeakMapCtor$1$LWS, toSafeMap as toSafeMap$LWS, MapCtor as MapCtor$LWS, toSafeWeakSet as toSafeWeakSet$LWS, WeakSetCtor as WeakSetCtor$LWS, ReflectGetOwnPropertyDescriptor as ReflectGetOwnPropertyDescriptor$LWS, ReflectSetPrototypeOf as ReflectSetPrototypeOf$1$LWS, ObjectLookupOwnGetter as ObjectLookupOwnGetter$1$LWS, ObjectFreeze as ObjectFreeze$1$LWS, ArrayConcat as ArrayConcat$LWS, ObjectLookupOwnSetter as ObjectLookupOwnSetter$LWS, alwaysNull as alwaysNull$LWS, StringProtoSplit as StringProtoSplit$LWS, isConvertibleToString as isConvertibleToString$LWS, prefixNamespace as prefixNamespace$LWS, PromiseProtoThen as PromiseProtoThen$LWS, isNamespacePrefixed as isNamespacePrefixed$LWS, unprefixNamespace as unprefixNamespace$LWS, isObjectLike as isObjectLike$LWS, shallowCloneOptions as shallowCloneOptions$LWS, PromiseReject as PromiseReject$LWS, LockerSecurityError as LockerSecurityError$LWS, toString as toString$LWS, ArrayProtoJoin as ArrayProtoJoin$1$LWS, enquote as enquote$LWS, capitalizeFirstChar as capitalizeFirstChar$LWS, toSafeTemplateStringValue as toSafeTemplateStringValue$LWS, createRevokedProxy as createRevokedProxy$LWS, getNamespacePrefix as getNamespacePrefix$LWS, trackTargetAsLive as trackTargetAsLive$LWS, ObjectAssign as ObjectAssign$1$LWS, ReflectGetPrototypeOf as ReflectGetPrototypeOf$1$LWS, partialStructuredClone as partialStructuredClone$LWS, consoleWarn as consoleWarn$LWS, noop as noop$1$LWS, shallowCloneArray as shallowCloneArray$LWS, ArrayProtoIndexOf as ArrayProtoIndexOf$1$LWS, ArrayProtoSlice as ArrayProtoSlice$1$LWS, ObjectLookupOwnValue as ObjectLookupOwnValue$LWS, FunctionProtoBind as FunctionProtoBind$LWS, ReflectDeleteProperty as ReflectDeleteProperty$1$LWS, UNCOMPILED_LOCATION_NAME as UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME as UNCOMPILED_TOP_NAME$LWS, ProxyCtor as ProxyCtor$LWS, ReflectGet as ReflectGet$LWS, ObjectHasOwn as ObjectHasOwn$1$LWS, ReflectSet as ReflectSet$LWS, ObjectGetOwnPropertySymbols as ObjectGetOwnPropertySymbols$LWS, ReflectHas as ReflectHas$LWS, ArrayCtor as ArrayCtor$1$LWS, ObjectGetOwnPropertyDescriptors as ObjectGetOwnPropertyDescriptors$LWS, SANDBOX_EVAL_CONTEXT_NAME as SANDBOX_EVAL_CONTEXT_NAME$LWS, extractFunctionBodySource as extractFunctionBodySource$LWS, indexOfPragma as indexOfPragma$LWS, isTargetLive as isTargetLive$LWS, LOCKER_IDENTIFIER_MARKER as LOCKER_IDENTIFIER_MARKER$LWS, ReflectConstruct as ReflectConstruct$LWS, SANDBOX_EVAL_HELPERS_NAME as SANDBOX_EVAL_HELPERS_NAME$LWS } from '@locker/shared';
import { DocumentProtoCreateElement as DocumentProtoCreateElement$1$LWS, HTMLAnchorElementProtoHrefSetter as HTMLAnchorElementProtoHrefSetter$LWS, HTMLAnchorElementProtoHrefGetter as HTMLAnchorElementProtoHrefGetter$LWS, HTMLAnchorElementProtoHostnameGetter as HTMLAnchorElementProtoHostnameGetter$LWS, WindowDecodeURIComponent as WindowDecodeURIComponent$LWS, HTMLAnchorElementProtoPathnameGetter as HTMLAnchorElementProtoPathnameGetter$LWS, HTMLAnchorElementProtoProtocolGetter as HTMLAnchorElementProtoProtocolGetter$LWS, AttrProtoOwnerElementGetter as AttrProtoOwnerElementGetter$LWS, AttrProtoNameGetter as AttrProtoNameGetter$LWS, AttrProtoNamespaceURIGetter as AttrProtoNamespaceURIGetter$LWS, transformUncompiledSourceText as transformUncompiledSourceText$LWS, DocumentProtoCookieGetter as DocumentProtoCookieGetter$LWS, DocumentProtoCookieSetter as DocumentProtoCookieSetter$LWS, NodeProtoNodeNameGetter as NodeProtoNodeNameGetter$LWS, ElementProtoGetAttributeNode as ElementProtoGetAttributeNode$LWS, ElementProtoRemoveAttributeNode as ElementProtoRemoveAttributeNode$LWS, AttrProtoValueGetter as AttrProtoValueGetter$LWS, AttrProtoValueSetter as AttrProtoValueSetter$LWS, ElementProtoGetAttributeNodeNS as ElementProtoGetAttributeNodeNS$LWS, NAMESPACE_XLINK as NAMESPACE_XLINK$LWS, getValidator as getValidator$LWS, NAMESPACE_DEFAULT as NAMESPACE_DEFAULT$LWS, selfValidator as selfValidator$LWS, DocumentProtoHeadGetter as DocumentProtoHeadGetter$LWS, NodeProtoOwnerDocumentGetter as NodeProtoOwnerDocumentGetter$LWS, DOMTokenListProtoValueGetter as DOMTokenListProtoValueGetter$LWS, StorageProtoKey as StorageProtoKey$LWS, StorageProtoGetItem as StorageProtoGetItem$LWS, StorageProtoSetItem as StorageProtoSetItem$LWS, StorageProtoRemoveItem as StorageProtoRemoveItem$LWS, BlobProtoTypeGetter as BlobProtoTypeGetter$LWS, BlobProtoSlice as BlobProtoSlice$LWS, BlobProtoSizeGetter as BlobProtoSizeGetter$LWS, URLRevokeObjectURL as URLRevokeObjectURL$LWS, XhrCtor as XhrCtor$LWS, XhrProtoOpen as XhrProtoOpen$LWS, XhrProtoSend as XhrProtoSend$LWS, XhrProtoResponseTextGetter as XhrProtoResponseTextGetter$LWS, RequestProtoURLGetter as RequestProtoURLGetter$LWS, EventProtoCurrentTargetGetter as EventProtoCurrentTargetGetter$LWS, HTMLIFrameElementProtoSrcSetter as HTMLIFrameElementProtoSrcSetter$LWS, HTMLElementProtoDatasetGetter as HTMLElementProtoDatasetGetter$LWS, DocumentProtoDefaultViewGetter as DocumentProtoDefaultViewGetter$LWS, ElementProtoNamespaceURIGetter as ElementProtoNamespaceURIGetter$LWS, ElementProtoSetAttributeNS as ElementProtoSetAttributeNS$LWS, XhrProtoWithCredentialsSetter as XhrProtoWithCredentialsSetter$LWS, EventTargetProtoAddEventListener as EventTargetProtoAddEventListener$LWS, XhrProtoStatusGetter as XhrProtoStatusGetter$LWS, ElementProtoHasAttribute as _ElementProtoHasAttribute$LWS, ElementProtoGetAttribute as ElementProtoGetAttribute$LWS, SVGElementProtoDatasetGetter as SVGElementProtoDatasetGetter$LWS, WindowLengthGetter as WindowLengthGetter$LWS, URLCreateObjectURL as URLCreateObjectURL$LWS, BlobCtor as BlobCtor$LWS, WindowEncodeURIComponent as WindowEncodeURIComponent$LWS, NAMESPACE_XHTML as NAMESPACE_XHTML$LWS, isWindow as isWindow$LWS, selfDocument as selfDocument$LWS, selfWindow as selfWindow$LWS, WindowFrameElementGetter as WindowFrameElementGetter$LWS, WindowQueueMicrotask as WindowQueueMicrotask$LWS, WindowDocumentGetter as WindowDocumentGetter$LWS, WindowLocationGetter as WindowLocationGetter$LWS } from '@locker/shared-dom';
import { sanitize as sanitize$LWS, sanitizeSvgInnerHtml as sanitizeSvgInnerHtml$LWS, blobSanitizer as blobSanitizer$LWS, sanitizeDocument as sanitizeDocument$LWS, sanitizeSvgHref as sanitizeSvgHref$LWS } from '@locker/html-sanitizer';
const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS('@@lockerDebugMode'); // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore else: not avoidable via tests

if (LOCKER_UNMINIFIED_FLAG$LWS) {
  // We passed the phase one gate so we know our code is unminified and we can
  // install Locker's custom devtools formatter.
  let lockerDebugModeSymbolFlag$LWS = true;
  const MAX_ARRAY_DISPLAY$LWS = 100;
  const MAX_OBJECT_DISPLAY$LWS = 5;
  const MAX_STRING_DISPLAY$LWS = 100;
  const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
  const headerCSSText$LWS = 'display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;';
  const bodyItemStyleObject$LWS = {
    style: 'margin-left:11px; margin-bottom: 3px;'
  };
  const bodyStyleObject$LWS = {
    style: 'display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;'
  };
  const keyEnumerableStringStyleObject$LWS = {
    style: 'color: #9d288c; font-weight: bold'
  };
  const keyNonEnumerableOrSymbolStyleObject$LWS = {
    style: 'color: #b17ab0'
  };
  const primitiveBlueColorStyleObject$LWS = {
    style: 'color: #16239f'
  };
  const primitiveGreenColorStyleObject$LWS = {
    style: 'color: #236d25'
  };
  const primitiveGreyColorStyleObject$LWS = {
    style: 'color: #606367'
  };
  const primitiveOrangeColorStyleObject$LWS = {
    style: 'color: #b82619'
  }; // istanbul ignore next: currently unreachable via tests

  const formatValue$LWS = function formatValue$LWS(__value$LWS) {
    if (__value$LWS === null || __value$LWS === undefined) {
      return ['span', primitiveGreyColorStyleObject$LWS, `${__value$LWS}`];
    }

    if (typeof __value$LWS === 'boolean') {
      return ['span', primitiveBlueColorStyleObject$LWS, __value$LWS];
    }

    if (typeof __value$LWS === 'number') {
      return NumberIsFinite$LWS(__value$LWS) ? ['span', primitiveBlueColorStyleObject$LWS, __value$LWS] : ['span', primitiveBlueColorStyleObject$LWS, `${__value$LWS >= 0 ? '' : '-'}Infinity`];
    }

    if (typeof __value$LWS === 'string') {
      let _string$LWS = __value$LWS;
      const {
        length: _length$LWS
      } = _string$LWS;

      if (_length$LWS > MAX_STRING_DISPLAY$LWS) {
        const firstChunk$LWS = ReflectApply$1$LWS(StringProtoSlice$LWS, _string$LWS, [0, MID_STRING_DISPLAY$LWS]);
        const lastChunk$LWS = ReflectApply$1$LWS(StringProtoSlice$LWS, _string$LWS, [_length$LWS - MID_STRING_DISPLAY$LWS - 1, _length$LWS]);
        _string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
      } // @TODO: Default single quotes on main header.
      //       Double quotes on body.


      return ['span', primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(_string$LWS)];
    }

    if (ArrayIsArray$1$LWS(__value$LWS)) {
      return ['span', {}, `Array(${__value$LWS.length})`];
    }

    if (isObject$LWS(__value$LWS)) {
      return ['span', {}, `{${CHAR_ELLIPSIS$LWS}}`];
    } // Symbol will be coerced to a string.


    return ['span', primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(__value$LWS)];
  }; // istanbul ignore next: currently unreachable via tests


  const formatHeader$LWS = function formatHeader$LWS(object$LWS, config$LWS) {
    const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
    const formattedHeader$LWS = [];
    let formattedHeaderOffset$LWS = 0;

    if (isChildElement$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
    }

    const brand$LWS = ReflectApply$1$LWS(ObjectProtoToString$LWS, object$LWS, []);
    let _keys$LWS = ObjectKeys$LWS(object$LWS);

    if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
      if (!ReflectApply$1$LWS(ArrayProtoIncludes$1$LWS, _keys$LWS, ['description'])) {
        ReflectApply$1$LWS(ArrayProtoUnshift$1$LWS, _keys$LWS, ['description']);
      }
    } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
      const {
        length: _length$LWS
      } = object$LWS;
      _keys$LWS = ReflectApply$1$LWS(ArrayProtoFilter$1$LWS, _keys$LWS, [__key$LWS => {
        const _possibleIndex$LWS = typeof __key$LWS === 'string' ? +__key$LWS : -1;
        return _possibleIndex$LWS < 0 || _possibleIndex$LWS >= _length$LWS || !NumberIsInteger$LWS(_possibleIndex$LWS);
      }]);
    }

    const {
      length: keysLength$LWS
    } = _keys$LWS;

    if (ArrayIsArray$1$LWS(object$LWS)) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', isChildElement$LWS ? primitiveGreyColorStyleObject$LWS : {}, `(${object$LWS.length}) [`];

      for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_ARRAY_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
        const __key$LWS = _keys$LWS[_i$LWS];
        const __value$LWS = object$LWS[__key$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, _i$LWS ? ', ' : ''];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
      }

      if (keysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }

      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ']'];
      return formattedHeader$LWS;
    }

    let boxedHeaderEntry$LWS;
    let headerOpening$LWS = '{'; // eslint-disable-next-line default-case

    switch (brand$LWS) {
      case TO_STRING_BRAND_BIG_INT$LWS:
      case TO_STRING_BRAND_BOOLEAN$LWS:
      case TO_STRING_BRAND_NUMBER$LWS:
      case TO_STRING_BRAND_STRING$LWS:
      case TO_STRING_BRAND_SYMBOL$LWS:
        {
          let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;

          if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
            colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
          } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
            colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
          }

          headerOpening$LWS = `${ReflectApply$1$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
          boxedHeaderEntry$LWS = ['span', colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS))}`];
          break;
        }
    }

    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, headerOpening$LWS];

    if (boxedHeaderEntry$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;

      if (keysLength$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ', '];
      }
    }

    for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_OBJECT_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
      const __key$LWS = _keys$LWS[_i$LWS];
      const __value$LWS = object$LWS[__key$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, _i$LWS ? ', ' : ''];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, __key$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
    }

    if (keysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
    }

    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, '}'];
    return formattedHeader$LWS;
  }; // istanbul ignore next: currently unreachable via tests


  const formatBody$LWS = function formatBody$LWS(object$LWS) {
    const _keys$LWS = ObjectKeys$LWS(object$LWS); // @TODO: Arrays are broken into groups of 100.

    const ownKeys$LWS = ReflectOwnKeys$1$LWS(object$LWS);

    if (!ArrayIsArray$1$LWS(object$LWS)) {
      ReflectApply$1$LWS(ArrayProtoSort$1$LWS, ownKeys$LWS, []);
    }

    const formattedBody$LWS = [];
    let formattedBodyOffset$LWS = 0;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[_i$LWS];
      const __value$LWS = object$LWS[ownKey$LWS];

      if (isObject$LWS(__value$LWS)) {
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', {}, ['object', {
          object: __value$LWS,
          config: {
            childKey: StringCtor$LWS(ownKey$LWS),
            isChildElement: true
          }
        }]];
      } else {
        let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;

        if (typeof ownKey$LWS === 'symbol' || !ReflectApply$1$LWS(ArrayProtoIncludes$1$LWS, _keys$LWS, [ownKey$LWS])) {
          currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
        }

        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', bodyItemStyleObject$LWS, ['span', currentKeyStyle$LWS, StringCtor$LWS(ownKey$LWS)], ['span', {}, ': '], formatValue$LWS(__value$LWS)];
      }
    }

    return formattedBody$LWS;
  };

  let {
    devtoolsFormatters: devtoolsFormatters$LWS
  } = window;

  if (!ArrayIsArray$1$LWS(devtoolsFormatters$LWS)) {
    devtoolsFormatters$LWS = [];
    ReflectDefineProperty$LWS(window, 'devtoolsFormatters', {
      __proto__: null,
      configurable: true,
      value: devtoolsFormatters$LWS,
      writable: true
    });
  } // Append our custom formatter to the array of devtools formatters.
  // istanbul ignore next: currently unreachable via tests


  devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
    // istanbul ignore next: currently unreachable via tests
    header(object$LWS, config$LWS) {
      if (lockerDebugModeSymbolFlag$LWS) {
        // We passed the second phase gate so we know that the user has
        // opted-in to custom devtools formatters. Close the gate and
        // define the @@lockerDebugMode symbol on window.
        lockerDebugModeSymbolFlag$LWS = false;
        ReflectDefineProperty$LWS(window, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
          __proto__: null,
          configurable: true,
          value: true,
          writable: true
        });
      }

      if (!isNearMembrane$LWS(object$LWS)) {
        return null;
      }

      const headerDiv$LWS = ['div', {
        style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? '' : 'font-style: italic;'}`
      }];
      ReflectApply$1$LWS(ArrayProtoPush$1$LWS, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
      return ['div', {}, headerDiv$LWS];
    },

    // istanbul ignore next: currently unreachable via tests
    hasBody() {
      return true;
    },

    // istanbul ignore next: currently unreachable via tests
    body(object$LWS) {
      const bodyDiv$LWS = ['div', bodyStyleObject$LWS];
      ReflectApply$1$LWS(ArrayProtoPush$1$LWS, bodyDiv$LWS, formatBody$LWS(object$LWS));
      return bodyDiv$LWS;
    }

  };
}


const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar']; // Allow only alphanumeric, '-', '+', and '.' characters.

const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;

function isMIMETypeAllowed$LWS(mimeType$LWS) {
  // avoid MIME types which try to escape using special characters
  // Reason: W-4896359
  if (ReflectApply$1$LWS(RegExpProtoTest$LWS, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
    for (let i$LWS = 0, {
      length: length$LWS
    } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (ReflectApply$1$LWS(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
        return true;
      }
    }
  }

  return false;
}

const DISALLOWED_ENDPOINTS_LIST$LWS = ['/aura', '/webruntime'];
const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
const TRUSTED_DOMAINS_REG_EXP$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/;
const URL_SCHEMES_LIST$LWS = toSafeArray$1$LWS(['http:', 'https:']);
const normalizerAnchor$LWS = ReflectApply$1$LWS(DocumentProtoCreateElement$1$LWS, document, ['a']); // @TODO W-7302311 Make paths and domains configurable

function isValidURL$LWS(parsedURL$LWS) {
  const loweredPathname$LWS = ReflectApply$1$LWS(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);

  for (let i$LWS = 0, {
    length: length$LWS
  } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS; i$LWS += 1) {
    if (ReflectApply$1$LWS(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$1$LWS(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
      return false;
    }
  }

  return true;
}

function isValidURLScheme$LWS(url$LWS) {
  ReflectApply$1$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return URL_SCHEMES_LIST$LWS.includes(ReflectApply$1$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []));
}

function parseURL$LWS(url$LWS) {
  ReflectApply$1$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [sanitizeURLString$LWS(url$LWS)]);
  return {
    normalizedURL: ReflectApply$1$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []),
    hostname: ReflectApply$1$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []),
    pathname: WindowDecodeURIComponent$LWS(ReflectApply$1$LWS(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS, []))
  };
}

function sanitizeURLForElement$LWS(url$LWS) {
  ReflectApply$1$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return sanitizeURLString$LWS(ReflectApply$1$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []));
}

function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : ReflectApply$1$LWS(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, '']);
}



const CustomElementRegistryBlockedProperties$LWS = ['define'];
const documentToSandboxAttributeDistortionRegistry$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const recordToAttributeDistortionFactories$LWS = toSafeMap$LWS(new MapCtor$LWS());

function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS); // istanbul ignore if: currently unreachable via tests

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS]; // istanbul ignore if: currently unreachable via tests

  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$1$LWS(StringProtoToLowerCase$LWS, attrName$LWS, [])];

  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }

  const mapIterator$LWS = elementCtorMap$LWS.entries();

  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function createAttributeDistortionFactories$LWS(record$LWS) {
  const attributeFactories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS); // istanbul ignore if: currently unreachable via tests

  if (attributeFactories$LWS === undefined) {
    return [];
  }

  recordToAttributeDistortionFactories$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS);

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxAttributeDistortionRegistry$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }

  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  const {
    length: length$LWS
  } = attributeFactories$LWS;
  const factories$LWS = Array(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const attributeFactory$LWS = attributeFactories$LWS[i$LWS];

    factories$LWS[i$LWS] = () => {
      attributeFactory$LWS(attributeDistortionRegistry$LWS);
      return null;
    };
  }

  return factories$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}

function registerElementSetDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let attributeFactories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS);

  if (attributeFactories$LWS === undefined) {
    attributeFactories$LWS = [];
    recordToAttributeDistortionFactories$LWS.set(record$LWS, attributeFactories$LWS);
  }

  const loweredAttributeName$LWS = ReflectApply$1$LWS(StringProtoToLowerCase$LWS, attributeName$LWS, []);

  attributeFactories$LWS[attributeFactories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];

    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }

    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = toSafeMap$LWS(new MapCtor$LWS());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }

    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
  };
}

function initDistortionAttrValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS
  }
}) {
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');
  return function distortionAttrValueSetter$LWS(record$LWS) {
    return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
      const ownerElement$LWS = ReflectApply$1$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore else: needs default platform behavior test

      if (ownerElement$LWS) {
        const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
        /* istanbul ignore if: coverage missing, needs investigation */

        if (distortion$LWS) {
          ReflectApply$1$LWS(distortion$LWS, ownerElement$LWS, [val$LWS]);
          return;
        }
      }

      ReflectApply$1$LWS(originalAttrValueSetter$LWS, this, [val$LWS]);
    }];
  };
}

function initDistortionAuraUtilGlobalEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: globalObject$LWS
}) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval; // istanbul ignore else: external is the default sandbox type for coverage runs

  if (typeof originalGlobalEval$LWS !== 'function') {
    return alwaysNull$LWS;
  } // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  return function distortionAuraUtilGlobalEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
    return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
      let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;

      if (typeof descriptor$LWS === 'string') {
        const split$LWS = ReflectApply$1$LWS(StringProtoSplit$LWS, descriptor$LWS, ['://']);
        const {
          length: length$LWS
        } = split$LWS;
        const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
        wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${ReflectApply$1$LWS(StringProtoReplace$LWS, name$LWS, ['.', '/'])}` : `/components/${ReflectApply$1$LWS(StringProtoReplace$LWS, name$LWS, [':', '/'])}.js`);
      }

      return sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageDelete$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$1$LWS(originalDelete$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageHas$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy2$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageHas$LWS({
    key: key$LWS
  }) {
    return [originalHas$LWS, function has$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$1$LWS(originalHas$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageKeys$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy3$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageKeys$LWS({
    key: key$LWS
  }) {
    return [originalKeys$LWS, function keys$LWS() {
      const keysResultPromise$LWS = ReflectApply$1$LWS(originalKeys$LWS, this, []);
      return ReflectApply$1$LWS(PromiseProtoThen$LWS, keysResultPromise$LWS, [result$LWS => {
        const sandboxedCacheNames$LWS = [];

        for (let i$LWS = 0, j$LWS = 0, {
          length: length$LWS
        } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cacheName$LWS = result$LWS[i$LWS];

          if (isNamespacePrefixed$LWS(cacheName$LWS, key$LWS)) {
            sandboxedCacheNames$LWS[j$LWS++] = unprefixNamespace$LWS(cacheName$LWS, key$LWS);
          }
        }

        return sandboxedCacheNames$LWS;
      }]);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageMatch$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy4$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageMatch$LWS({
    key: key$LWS
  }) {
    return [originalMatch$LWS, function match$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // Let the native method handle missing parameters.

      if (!length$LWS) {
        return ReflectApply$1$LWS(originalMatch$LWS, this, args$LWS);
      } // Next we check `length` is at least 2, which means options are present.


      const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the
      // `options.cacheName` value. The value of `options.cacheName` must
      // also be safely convertible to a string.

      if (isObjectLike$LWS(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
        const {
          cacheName: cacheName$LWS
        } = matchOptions$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
          clonedOptions$LWS.cacheName = prefixNamespace$LWS(cacheName$LWS, key$LWS);
          args$LWS[1] = clonedOptions$LWS;
          return ReflectApply$1$LWS(originalMatch$LWS, this, args$LWS);
        }
      }

      return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageOpen$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy5$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageOpen$LWS({
    key: key$LWS
  }) {
    return [originalOpen$LWS, function open$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$1$LWS(originalOpen$LWS, this, args$LWS);
    }];
  };
}

const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */

function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = prefixNamespace$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookie$LWS(cookieEntry$LWS, key$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!isNamespacePrefixed$LWS(cookieEntry$LWS, key$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key.


  const prefix$LWS = getNamespacePrefix$LWS(key$LWS);
  const {
    length: prefixLength$LWS
  } = prefix$LWS;
  const pos$LWS = cookieEntry$LWS.length > prefixLength$LWS && cookieEntry$LWS[prefixLength$LWS] === '=' ? prefixLength$LWS + 1 : prefixLength$LWS;
  return ReflectApply$1$LWS(StringProtoSlice$LWS, cookieEntry$LWS, [pos$LWS]);
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreDelete$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp$LWS;

  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }

      return ReflectApply$1$LWS(originalDelete$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreGet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp2$LWS;

  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreGet$LWS({
    key: key$LWS
  }) {
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }

      const getResultPromise$LWS = ReflectApply$1$LWS(originalGet$LWS, this, args$LWS);
      return ReflectApply$1$LWS(PromiseProtoThen$LWS, getResultPromise$LWS, [cookieListItem$LWS => {
        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;

          if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
            return cookieListItem$LWS;
          }
        }

        return null;
      }]);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreGetAll$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp3$LWS;

  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreGetAll$LWS({
    key: key$LWS
  }) {
    return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
      }

      const getAllResultPromise$LWS = ReflectApply$1$LWS(originalGetAll$LWS, this, args$LWS);
      return ReflectApply$1$LWS(PromiseProtoThen$LWS, getAllResultPromise$LWS, [result$LWS => {
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;

        for (let i$LWS = 0, {
          length: length$LWS
        } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cookieListItem$LWS = result$LWS[i$LWS];

          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;

            if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
              sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
            }
          }
        }

        return sandboxedCookies$LWS;
      }]);
    }];
  };
}

const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;

  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
}

function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }

  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
} // istanbul ignore next: only available in secure context


function onchange$LWS() {
  throw new LockerSecurityError$LWS('Cannot set cookieStore.onchange.');
} // istanbul ignore next: only available in secure context


function initDistortionCookieStoreOnChange$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  const originalOnChangeSetter$LWS = ObjectLookupOwnSetter$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionMapEntry$LWS = [originalOnChangeSetter$LWS, onchange$LWS];
  return function distortionCookieStoreOnChange$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, CookieStore$LWS, 'change');
    return distortionMapEntry$LWS;
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreSet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp4$LWS;

  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreSet$LWS({
    key: key$LWS
  }) {
    return [originalSet$LWS, function set$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;

      if (length$LWS > 1) {
        args$LWS[0] = prefixNamespace$LWS(args$LWS[0], key$LWS);
      } else if (length$LWS) {
        const {
          0: details$LWS
        } = args$LWS;

        if (isObjectLike$LWS(details$LWS)) {
          const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
          clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
          args$LWS[0] = clonedDetails$LWS;
        }
      }

      return ReflectApply$1$LWS(originalSet$LWS, this, args$LWS);
    }];
  };
}

function initDistortionCSSStyleRuleStyleGetter$LWS({
  globalObject: {
    CSSStyleRule: CSSStyleRule$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$1$LWS(CSSStyleRule$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$1$LWS(originalStyleGetter$LWS, this, []));
  }];
  return function distortionCSSStyleRuleStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionCustomElementRegistryGet$LWS({
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS
  }
}) {
  var _CustomElementRegistr$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalGet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCustomElementRegistryGet$LWS({
    key: key$LWS
  }) {
    const loweredNsPrefix$LWS = `${ReflectApply$1$LWS(StringProtoToLowerCase$LWS, key$LWS, [])}-`;
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length) {
        const sanitizedName$LWS = toString$LWS(args$LWS[0]);
        const loweredName$LWS = ReflectApply$1$LWS(StringProtoToLowerCase$LWS, sanitizedName$LWS, []);

        if (!ReflectApply$1$LWS(StringProtoStartsWith$LWS, loweredName$LWS, [loweredNsPrefix$LWS])) {
          return undefined;
        }

        args$LWS[0] = sanitizedName$LWS;
      }

      return ReflectApply$1$LWS(originalGet$LWS, this, args$LWS);
    }];
  };
}

function initDistortionDocumentCookieGetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$1$LWS(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieGetter$LWS, function get$LWS() {
      const documentCookieValue$LWS = ReflectApply$1$LWS(DocumentProtoCookieGetter$LWS, this, []);
      const cookies$LWS = ReflectApply$1$LWS(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);

        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }

      return ReflectApply$1$LWS(ArrayProtoJoin$1$LWS, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
    }];
  };
}

function initDistortionDocumentCookieSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
      const cookieEntries$LWS = ReflectApply$1$LWS(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
      let {
        0: newCookieEntry$LWS
      } = cookieEntries$LWS;

      if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
        newCookieEntry$LWS = ReflectApply$1$LWS(StringProtoSlice$LWS, newCookieEntry$LWS, [1]);
      }

      cookieEntries$LWS[0] = prefixNamespace$LWS(newCookieEntry$LWS, key$LWS);
      const cookie$LWS = ReflectApply$1$LWS(ArrayProtoJoin$1$LWS, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
      ReflectApply$1$LWS(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
    }];
  };
}

function domain$LWS() {
  throw new LockerSecurityError$LWS('Cannot set document.domain.');
}

function initDistortionDocumentDomainSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');
  const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
  return function distortionDocumentDomainSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$m$LWS
} = selfValidator$LWS;

function initDistortionDocumentExecCommand$LWS({
  globalObject: {
    Document: {
      prototype: {
        execCommand: originalExecCommand$LWS
      }
    },
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalActiveElement$LWS = ObjectLookupOwnGetter$1$LWS(Document.prototype, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$1$LWS(HTMLElement$LWS.prototype, 'isContentEditable');
  return function distortionDocumentExecCommand$LWS({
    type: type$LWS
  }) {
    return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
      if (args$LWS.length > 2) {
        const {
          2: unsanitizedValue$LWS
        } = args$LWS; // istanbul ignore else: needs default platform behavior test

        if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
          const command$LWS = toString$LWS(args$LWS[0]); // istanbul ignore else: LWS does not test for all possible commands

          if (ReflectApply$1$LWS(StringProtoToLowerCase$LWS, command$LWS, []) === 'inserthtml') {
            // istanbul ignore else: external is the default sandbox type for coverage runs
            if (type$LWS === 0
            /* SandboxType.External */
            ) {
              const activeElement$LWS = ReflectApply$1$LWS(originalActiveElement$LWS, this, []);

              if (isSharedElement$m$LWS(activeElement$LWS) && ReflectApply$1$LWS(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, activeElement$LWS, [])}.`);
              }
            }

            args$LWS[0] = command$LWS;
            args$LWS[2] = sanitize$LWS(unsanitizedValue$LWS);
          }
        }
      }

      return ReflectApply$1$LWS(originalExecCommand$LWS, this, args$LWS);
    }];
  };
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    const windowFeatures$LWS = toString$LWS(sanitizedArgs$LWS[2]);
    let loweredWindowFeatures$LWS = ReflectApply$1$LWS(StringProtoToLowerCase$LWS, windowFeatures$LWS, []); // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

    if (ReflectApply$1$LWS(RegExpProtoTest$LWS, noopenerRegExp$LWS, [windowFeatures$LWS])) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      loweredWindowFeatures$LWS = ReflectApply$1$LWS(StringProtoReplace$LWS, loweredWindowFeatures$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
    }

    sanitizedArgs$LWS[2] = loweredWindowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function initDistortionDocumentOpen$LWS({
  globalObject: {
    Document: {
      prototype: {
        open: originalDocumentOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias
      // for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      return ReflectApply$1$LWS(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$1$LWS(originalDocumentOpen$LWS, this, args$LWS);
  }];
  return function distortionDocumentOpen$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$l$LWS
} = selfValidator$LWS;

function initDistortionDocumentReplaceChildren$LWS({
  globalObject: {
    Document: {
      prototype: {
        replaceChildren: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check
    // if its `head` property is a shared element. This will allow
    // magenta window documents to call replaceChildren successfully.
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$l$LWS(ReflectApply$1$LWS(DocumentProtoHeadGetter$LWS, this, []))) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$1$LWS(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionDocumentReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionDOMParserParseFromString$LWS({
  globalObject: {
    DOMParser: {
      prototype: {
        parseFromString: originalParseFromString$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with
    // exactly two arguments. If it receives one argument, it will fail.
    // Some implementations will also fail if it receives more than two
    // arguments. Since any call that does not have at least two arguments
    // will fail no matter what, we only need to expend effort to sanitize
    // when we know that the operation is definitely NOT going to fail.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = toString$LWS(args$LWS[0]);
      const mimeType$LWS = toString$LWS(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? sanitizeSvgInnerHtml$LWS(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : sanitize$LWS(string$LWS);
    }

    return ReflectApply$1$LWS(originalParseFromString$LWS, this, args$LWS);
  }];
  return function distortionDOMParserParseFromString$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$k$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
} = selfValidator$LWS;

function initDistortionElementAfter$LWS({
  globalObject: {
    Element: {
      prototype: {
        after: originalAfter$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$k$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$1$LWS(originalAfter$LWS, this, args$LWS);
  }];
  return function distortionElementAfter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$j$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
} = selfValidator$LWS;

function initDistortionElementAppend$LWS({
  globalObject: {
    Element: {
      prototype: {
        append: originalAppend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$j$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number
      // of arguments which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared
        // element child which is limited to script and link, an
        // exception is thrown.

        if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$1$LWS(originalAppend$LWS, this, args$LWS);
  }];
  return function distortionElementAppend$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementAttachShadow$LWS({
  globalObject: {
    Element: {
      prototype: {
        attachShadow: originalAttachShadow$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit
        // because attachShadow() accepts inherited shadowRootInit
        // properties.


        const shadowRootInit$LWS = ObjectAssign$1$LWS({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment
        // of mode to avoid complications with inherited
        // non-configurable/non-writable mode properties.

        const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$1$LWS(originalShadowRootInit$LWS);
        ReflectSetPrototypeOf$1$LWS(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return ReflectApply$1$LWS(originalAttachShadow$LWS, this, args$LWS);
  }];
  return function distortionElementAttachShadow$LWS() {
    return distortionEntry$LWS;
  };
}

const namedNodeMapToElementRegistry$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementRegistry$LWS.set(attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementRegistry$LWS.get(nodeNameMap$LWS); // istanbul ignore else: nothing to do if there's no element

  if (element$LWS) {
    const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: nothing to do if there's no distortion

    if (distortion$LWS) {
      const attrValue$LWS = ReflectApply$1$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
      return ReflectApply$1$LWS(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  } // istanbul ignore next: needs default platform behavior test


  return ReflectApply$1$LWS(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function initDistortionElementAttributesGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$1$LWS(Element$LWS.prototype, 'attributes');
  const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
    const attrs$LWS = ReflectApply$1$LWS(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }];
  return function distortionElementAttributesGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$i$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
} = selfValidator$LWS;

function initDistortionElementBefore$LWS({
  globalObject: {
    Element: {
      prototype: {
        before: originalBefore$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$i$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // istanbul ignore else: needs default platform behavior test

        if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$1$LWS(originalBefore$LWS, this, args$LWS);
  }];
  return function distortionElementBefore$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$h$LWS
} = selfValidator$LWS;

function initDistortionElementInnerHTMLSetter$LWS({
  globalObject: {
    Element: Element$LWS,
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'innerHTML');
  const distortionEntry$LWS = [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
    const isOwnerXMLDocument$LWS = ReflectApply$1$LWS(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;

    if (!isOwnerXMLDocument$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$h$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }

      value$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS);
    }

    ReflectApply$1$LWS(originalInnerHTMLSetter$LWS, this, [value$LWS]);
  }];
  return function distortionElementInnerHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$g$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
} = selfValidator$LWS;

function initDistortionElementInsertAdjacentElement$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentElement: originalInsertAdjacentElement$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$g$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
    }

    return ReflectApply$1$LWS(originalInsertAdjacentElement$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentElement$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$f$LWS
} = selfValidator$LWS;

function initDistortionElementInsertAdjacentHTML$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentHTML: originalInsertAdjacentHTML$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$f$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}`);
    } // istanbul ignore else: needs default platform behavior test


    if (args$LWS.length > 1) {
      args$LWS[1] = sanitize$LWS(args$LWS[1]);
    }

    ReflectApply$1$LWS(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentHTML$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$e$LWS
} = selfValidator$LWS;

function initDistortionElementOuterHTMLSetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML');
  const distortionEntry$LWS = [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$e$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$1$LWS(originalOuterHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }];
  return function distortionElementOuterHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$d$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
} = selfValidator$LWS;

function initDistortionElementPrepend$LWS({
  globalObject: {
    Element: {
      prototype: {
        prepend: originalPrepend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$d$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary
      // number of arguments which can be comprised of Nodes and
      // DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared
        // element child, which is limited to script and link, an
        // exception is thrown.

        if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$1$LWS(originalPrepend$LWS, this, args$LWS);
  }];
  return function distortionElementPrepend$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$c$LWS
} = selfValidator$LWS;

function initDistortionElementRemove$LWS({
  globalObject: {
    Element: {
      prototype: {
        remove: originalRemove$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$c$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$1$LWS(originalRemove$LWS, this, []);
  }];
  return function distortionElementRemove$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$b$LWS
} = selfValidator$LWS;

function initDistortionElementReplaceChildren$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceChildren: originalReplaceChildren$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$b$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    return ReflectApply$1$LWS(originalReplaceChildren$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$a$LWS
} = selfValidator$LWS;

function initDistortionElementReplaceWith$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceWith: originalReplaceWith$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$a$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    return ReflectApply$1$LWS(originalReplaceWith$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceWith$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementSetAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttribute$LWS(record$LWS) {
    return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
      if (args$LWS.length > 1) {
        const attrName$LWS = toString$LWS(args$LWS[0]);
        const attrValue$LWS = toString$LWS(args$LWS[1]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$1$LWS(distortion$LWS, this, [attrValue$LWS]);
          return;
        } // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".


        args$LWS[0] = attrName$LWS;
        args$LWS[1] = attrValue$LWS;
      }

      ReflectApply$1$LWS(originalSetAttribute$LWS, this, args$LWS);
    }];
  };
}

function initDistortionElementSetAttributeNode$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNode: originalSetAttributeNode$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNode$LWS(record$LWS) {
    return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$1$LWS(originalSetAttributeNode$LWS, this, args$LWS);
      } // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test


      if (ReflectApply$1$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$1$LWS(originalSetAttributeNode$LWS, this, args$LWS);
      }

      const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$1$LWS(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

        if (oldAttr$LWS) {
          // Disconnect old attribute.
          ReflectApply$1$LWS(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        const attrValue$LWS = ReflectApply$1$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$1$LWS(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$1$LWS(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

        if (newAttr$LWS) {
          // Remove distorted attribute.
          ReflectApply$1$LWS(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }

        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$1$LWS(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$1$LWS(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

          ReflectApply$1$LWS(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

          return ReflectApply$1$LWS(originalSetAttributeNode$LWS, this, [attr$LWS]);
        }

        return undefined;
      }

      return ReflectApply$1$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    }];
  };
}

function initDistortionElementSetAttributeNodeNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNodeNS: originalSetAttributeNodeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
    return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$1$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
      } // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test


      if (ReflectApply$1$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$1$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }

      const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$1$LWS(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

        if (oldAttr$LWS) {
          // Disconnect the old attribute.
          ReflectApply$1$LWS(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        const attrValue$LWS = ReflectApply$1$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$1$LWS(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$1$LWS(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

        if (newAttr$LWS) {
          // Remove the distorted attribute.
          ReflectApply$1$LWS(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }

        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$1$LWS(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
        }

        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$1$LWS(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

          ReflectApply$1$LWS(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

          return ReflectApply$1$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
        }

        return null;
      }

      return ReflectApply$1$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
    }];
  };
}

function initDistortionElementSetAttributeNS$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttributeNS: originalSetAttributeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNS$LWS(record$LWS) {
    return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
      // istanbul ignore next: needs default platform behavior test
      if (args$LWS.length < 3) {
        ReflectApply$1$LWS(originalSetAttributeNS$LWS, this, args$LWS);
        return;
      }

      let {
        0: attrNamespace$LWS
      } = args$LWS;

      if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
        attrNamespace$LWS = toString$LWS(attrNamespace$LWS);
      }

      const attrName$LWS = toString$LWS(args$LWS[1]);
      const attrValue$LWS = toString$LWS(args$LWS[2]);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        ReflectApply$1$LWS(distortion$LWS, this, [attrValue$LWS]);
        return;
      } // istanbul ignore next: needs default platform behavior test
      // eslint-disable-next-line no-lone-blocks


      {
        // This is in a block to avoid requiring an
        // "istanbul ignore next" for all for lines.
        // We could avoid this entirely by testing the default
        // platform behavior.
        args$LWS[0] = attrNamespace$LWS; // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".

        args$LWS[1] = attrName$LWS;
        args$LWS[2] = attrValue$LWS;
        ReflectApply$1$LWS(originalSetAttributeNS$LWS, this, args$LWS);
      }
    }];
  };
}

function initDistortionElementShadowRootGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$1$LWS(Element$LWS.prototype, 'shadowRoot');
  const distortionEntry$LWS = [originalShadowRootGetter$LWS, alwaysNull$LWS];
  return function distortionElementShadowRootGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementToggleAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        hasAttribute: ElementProtoHasAttribute$LWS,
        toggleAttribute: originalToggleAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementToggleAttribute$LWS(record$LWS) {
    return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (length$LWS > 0) {
        const attrName$LWS = toString$LWS(args$LWS[0]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely,
          // if the distortion throws.

          ReflectApply$1$LWS(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to
          // return true | false, based on the presence or absence
          // of this attribute.

          return ReflectApply$1$LWS(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
        } // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        // istanbul ignore next: needs default platform behavior test


        args$LWS[0] = attrName$LWS;
      } // istanbul ignore next: needs default platform behavior test


      return ReflectApply$1$LWS(originalToggleAttribute$LWS, this, args$LWS);
    }];
  };
}

function initDistortionEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    eval: originalEval$LWS
  }
}) {
  return function distortionEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalEval$LWS, sourceText$LWS => sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(toString$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS)];
  };
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function composedPath$LWS() {
  return createDistortedComposedPath$LWS(this);
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = ReflectApply$1$LWS(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$1$LWS(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = ReflectApply$1$LWS(ArrayProtoIndexOf$1$LWS, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ReflectApply$1$LWS(ArrayProtoSlice$1$LWS, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }

  return distortedComposedPath$LWS;
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function initDistortionEventComposedPath$LWS({
  globalObject: {
    Event: {
      prototype: {
        composedPath: originalComposedPath$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalComposedPath$LWS, composedPath$LWS];
  return function distortionEventComposedPath$LWS() {
    return distortionEntry$LWS;
  };
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function path$LWS() {
  return createDistortedComposedPath$LWS(this);
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function initDistortionEventPathGetter$LWS({
  globalObject: {
    Event: Event$LWS
  }
}) {
  const originalPathGetter$LWS = ObjectLookupOwnGetter$1$LWS(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalPathGetter$LWS, path$LWS];
  return function distortionEventPathGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionEventTargetAddEventListener$LWS({
  globalObject: {
    EventTarget: {
      prototype: {
        addEventListener: originalAddEventListener$LWS
      }
    }
  }
}) {
  return function distortionEventTargetAddEventListener$LWS(record$LWS) {
    function addEventListener$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // Ensure that we fallback to the default platform behavior which
      // should fail if less than 2 arguments are provided.
      // istanbul ignore else: needs default platform behavior test

      if (length$LWS > 1) {
        const eventName$LWS = toString$LWS(args$LWS[0]);

        if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
          let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
          const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(this.constructor, 'name'); // istanbul ignore else: needs default platform behavior test

          if (safeDesc$LWS) {
            ReflectSetPrototypeOf$1$LWS(safeDesc$LWS, null);
            const {
              value: name$LWS
            } = safeDesc$LWS; // istanbul ignore else: needs default platform behavior test

            if (typeof name$LWS === 'string') {
              exceptionMessage$LWS += ` to ${name$LWS} object`;
            }
          }

          throw new LockerSecurityError$LWS(`${exceptionMessage$LWS}.`);
        }

        args$LWS[0] = eventName$LWS;
      }

      return ReflectApply$1$LWS(originalAddEventListener$LWS, this, args$LWS);
    }

    return [originalAddEventListener$LWS, addEventListener$LWS];
  };
}

function initDistortionFunction$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    Function: originalFunction$LWS
  }
}) {
  return function distortionFunction$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalFunction$LWS, function Function$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;

      if (length$LWS) {
        const lastIndex$LWS = length$LWS - 1;
        args$LWS[lastIndex$LWS] = transformUncompiledSourceText$LWS(toString$LWS(args$LWS[lastIndex$LWS]));
      } // NOTE: Function constructor and eval are controlled by the same CSP rules,
      // which means we can rely on eval to fulfill the behavior of the Function
      // constructor.


      const fn$LWS = sandboxEvaluator$LWS(`(...args) => Function(...args)`, UNCOMPILED_CONTEXT$LWS);
      return ReflectApply$1$LWS(fn$LWS, this, args$LWS);
    }];
  };
}

function initDistortionHistoryPushState$LWS({
  globalObject: {
    History: {
      prototype: {
        pushState: originalPushState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$1$LWS(originalPushState$LWS, this, args$LWS);
  }];
  return function distortionHistoryPushState$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHistoryReplaceState$LWS({
  globalObject: {
    History: {
      prototype: {
        replaceState: originalReplaceState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$1$LWS(originalReplaceState$LWS, this, args$LWS);
  }];
  return function distortionHistoryReplaceState$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLElementDatasetGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$1$LWS(HTMLElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$1$LWS(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionHTMLElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$9$LWS
} = selfValidator$LWS;

function initDistortionHTMLElementInnerTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$9$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$1$LWS(originalInnerTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementInnerTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$8$LWS
} = selfValidator$LWS; // The outerText property is non-standard, so the descriptor could be undefined,
// like in the case of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility

function initDistortionHTMLElementOuterTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$8$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$1$LWS(originalOuterTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementOuterTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLElementStyleGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$1$LWS(HTMLElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$1$LWS(originalStyleGetter$LWS, this, []));
  }];
  return function distortionHTMLElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function src$LWS(value$LWS) {
  const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

  if (!isValidURLScheme$LWS(urlString$LWS)) {
    throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
  }

  ReflectApply$1$LWS(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
}

function initDistortionHTMLIFrameElementSrcSetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');
  const distortionMapEntry$LWS = [originalSrcSetter$LWS, src$LWS];
  return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return distortionMapEntry$LWS;
  };
}

const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !ReflectApply$1$LWS(RegExpProtoTest$LWS, importRegExp$LWS, [value$LWS]);
}

function initDistortionHTMLLinkElementRelSetter$LWS({
  globalObject: {
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const valueAsString$LWS = toString$LWS(value$LWS);

    if (isValidRelValue$LWS(valueAsString$LWS)) {
      ReflectApply$1$LWS(originalRelSetter$LWS, this, [valueAsString$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
  return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', NAMESPACE_DEFAULT$LWS, rel$LWS);
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLLinkElementRelListSetter$LWS({
  globalObject: {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');
  const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ?
    /* istanbul ignore next: needs default platform behavior test */
    ReflectApply$1$LWS(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toString$LWS(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$1$LWS(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }];
  return function distortionHTMLLinkElementRelListSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLObjectElementDataSetter$LWS({
  globalObject: {
    HTMLObjectElement: HTMLObjectElement$LWS
  }
}) {
  const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, 'data');

  function data$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLObjectElement.data supports http://, https:// schemes and relative urls.');
    }

    const parsedURL$LWS = parseURL$LWS(urlString$LWS);

    if (!isValidURL$LWS(parsedURL$LWS)) {
      throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }

    ReflectApply$1$LWS(originalDataSetter$LWS, this, [urlString$LWS]);
  }

  const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
  return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', NAMESPACE_DEFAULT$LWS, data$LWS);
    return distortionEntry$LWS;
  };
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = ReflectApply$1$LWS(HTMLElementProtoDatasetGetter$LWS, el$LWS, []);
  const distortedSrc$LWS = ObjectLookupOwnValue$LWS(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function initDistortionHTMLScriptElementSrcGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$1$LWS(HTMLScriptElement$LWS.prototype, 'src');
  const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS() {
    return getDatasetSrcValue$LWS(this) || ReflectApply$1$LWS(originalSrcGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const BLOB_SCRIPT_OPTIONS$LWS = {
  __proto__: null,
  type: 'text/javascript'
};
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_PAYLOAD_TOKEN$LWS = '$payload$';
const SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}("${SCRIPT_PAYLOAD_TOKEN$LWS}")`;
const SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}()`;
const seenNodesThatSetTextContent$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());

function defineEvaluatorProperty$LWS(host$LWS, callback$LWS) {
  if (!ReflectDefineProperty$LWS(host$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter source as "[native code]".
    get: ReflectApply$1$LWS(FunctionProtoBind$LWS, () => {
      ReflectDeleteProperty$1$LWS(host$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
      const ownerDoc$LWS = ReflectApply$1$LWS(NodeProtoOwnerDocumentGetter$LWS, host$LWS, []);
      const defaultView$LWS = ReflectApply$1$LWS(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []); // We don't need to use something like `WindowLocationGetter()`
      // because the 'location' property is non-configurable.

      const context$LWS = {
        [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
        [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
      };
      return (...args$LWS) => {
        callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS, args$LWS);
      };
    }, [])
  })) {
    // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
    throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, host$LWS, [])}`);
  }
}

function defineSrcEvaluatorProperty$LWS(host$LWS, sandboxEvaluator$LWS) {
  // prettier-ignore
  defineEvaluatorProperty$LWS(host$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS, {
    0: encodedPayload$LWS
  }) => {
    sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(WindowDecodeURIComponent$LWS(toString$LWS(encodedPayload$LWS))), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function defineTextContentEvaluatorProperty$LWS(host$LWS, textContent$LWS, sandboxEvaluator$LWS) {
  // The textContent of a script element is only evaluated on the first set.
  // Subsequent sets change the textContent value but are not evaluated.
  if (seenNodesThatSetTextContent$LWS.has(host$LWS)) {
    return false;
  }

  seenNodesThatSetTextContent$LWS.add(host$LWS); // prettier-ignore

  defineEvaluatorProperty$LWS(host$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
    sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(textContent$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function getSrcEvaluatorHookSourceText$LWS(sourceText$LWS) {
  // Creates a blob URL to invoke the evaluator hook with encoded source text.
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([ReflectApply$1$LWS(StringProtoReplace$LWS, SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS, [SCRIPT_PAYLOAD_TOKEN$LWS, WindowEncodeURIComponent$LWS(sourceText$LWS)])], BLOB_SCRIPT_OPTIONS$LWS));
}

const getTextContentEvaluatorHookSourceText$LWS = () => SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS;

const documentToPropertyDescriptorRegistryMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());

function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
  return function initDistortionBlockedAttribute$LWS() {
    const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
    const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`; // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.

    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
      }
    };
    return function distortionBlockedAttribute$LWS(record$LWS) {
      registerElementSetDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, distortion$LWS);
      return null;
    };
  };
}

function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalGet$LWS = ObjectLookupOwnGetter$1$LWS(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalGet$LWS, // eslint-disable-next-line prefer-arrow-callback
  function get$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function getThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function getThrowerDistortionFactoryInitializer$LWS() {
    return getThrowerDistortionFactory$LWS;
  };
}

function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalSet$LWS, // eslint-disable-next-line prefer-arrow-callback
  function set$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function setThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function setThrowerDistortionFactoryInitializer$LWS() {
    return setThrowerDistortionFactory$LWS;
  };
}

function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const {
    [key$LWS]: originalValue$LWS
  } = proto$LWS;
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalValue$LWS, // eslint-disable-next-line prefer-arrow-callback
  function value$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function valueThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function valueThrowerDistortionFactoryInitializer$LWS() {
    return valueThrowerDistortionFactory$LWS;
  };
}

function createBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
  }

  return factoryInitializers$LWS;
}

function createBlockedPropertyDistortionFactoryInitializers$LWS({
  document: document$LWS
}, proto$LWS, properties$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  let descRegistryMap$LWS = documentToPropertyDescriptorRegistryMap$LWS.get(document$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (descRegistryMap$LWS === undefined) {
    descRegistryMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
    documentToPropertyDescriptorRegistryMap$LWS.set(document$LWS, descRegistryMap$LWS);
  }

  let descRegistry$LWS = descRegistryMap$LWS.get(proto$LWS); // istanbul ignore else: need a test for this on the same document but different namespace

  if (descRegistry$LWS === undefined) {
    descRegistry$LWS = {
      __proto__: null
    };
    descRegistryMap$LWS.set(proto$LWS, descRegistry$LWS);
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = properties$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = properties$LWS[i$LWS];
    let safeDesc$LWS = descRegistry$LWS[prop$LWS];

    if (safeDesc$LWS === undefined) {
      var _ReflectGetOwnPropert$LWS;

      safeDesc$LWS = (_ReflectGetOwnPropert$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS)) != null ? _ReflectGetOwnPropert$LWS : null;

      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$1$LWS(safeDesc$LWS, null);
      }

      descRegistry$LWS[prop$LWS] = safeDesc$LWS;
    }

    if (safeDesc$LWS) {
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS; // istanbul ignore else

        if (getter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {}
        // because prettier won't allow a multi-line comment between
        // "else" and "if", which is where the istanbul ignore directive
        // must go to be effective.
        // istanbul ignore else: currently unreachable via tests
        if (typeof value$LWS === 'function') {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }

  return factoryInitializers$LWS;
}

function createScriptDistortion$LWS({
  sandboxEvaluator: sandboxEvaluator$LWS
}, attributeName$LWS, datasetGetter$LWS) {
  const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`; // Use a computed property to dynamically set the distortion function name
  // without using `Reflect.defineProperty()`.

  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](value$LWS) {
      const originalValue$LWS = value$LWS;
      const elementNamespaceURI$LWS = ReflectApply$1$LWS(ElementProtoNamespaceURIGetter$LWS, this, []);
      const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;

      if (value$LWS === '') {
        ReflectApply$1$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, value$LWS]);
        return;
      } // Normalize the URL.


      ReflectApply$1$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [value$LWS]);
      value$LWS = ReflectApply$1$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []); // Create a dataset attribute to expose the undistorted attribute value.

      const dataset$LWS = ReflectApply$1$LWS(datasetGetter$LWS, this, []);
      dataset$LWS[`distorted${capitalizeFirstChar$LWS(attributeName$LWS)}`] = originalValue$LWS; // Create XHR.

      const hostname$LWS = ReflectApply$1$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
      const xhr$LWS = new XhrCtor$LWS(); // istanbul ignore if: currently unreachable via tests

      if (ReflectApply$1$LWS(RegExpProtoTest$LWS, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS])) {
        ReflectApply$1$LWS(XhrProtoWithCredentialsSetter$LWS, xhr$LWS, [true]);
      }

      ReflectApply$1$LWS(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
        const status$LWS = ReflectApply$1$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []);

        if (status$LWS === 200) {
          if (defineSrcEvaluatorProperty$LWS(this, sandboxEvaluator$LWS)) {
            const responseText$LWS = ReflectApply$1$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []); // Set and run the src evaluator hook.

            ReflectApply$1$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, getSrcEvaluatorHookSourceText$LWS(responseText$LWS)]);
          }
        } else {
          // The following if statement is enclosed in a dedicated
          // else {} because prettier won't allow a multi-line
          // comment between "else" and "if", which is where the
          // istanbul ignore directive must go to be effective.
          // istanbul ignore else: cannot produce codes beyond 200, 404 in tests
          if (status$LWS === 404) {
            ReflectApply$1$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found']);
          }
        }
      }]);
      ReflectApply$1$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', value$LWS]);
      ReflectApply$1$LWS(XhrProtoSend$LWS, xhr$LWS, []);
    }

  };
  return distortion$LWS;
}

function initDistortionHTMLScriptElementSrcSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLScriptElement$LWS.prototype, 'src');
  return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
    const src$LWS = createScriptDistortion$LWS(record$LWS, 'src', HTMLElementProtoDatasetGetter$LWS);
    registerElementSetDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return [originalSrcSetter$LWS, src$LWS];
  };
}

function initDistortionIDBObjectStoreAdd$LWS({
  globalObject: {
    IDBObjectStore: {
      prototype: {
        add: originalAdd$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$1$LWS(originalAdd$LWS, this, args$LWS);
  }];
  return function distortionIDBObjectStoreAdd$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionIDBObjectStorePut$LWS({
  globalObject: {
    IDBObjectStore: {
      prototype: {
        put: originalPut$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$1$LWS(originalPut$LWS, this, args$LWS);
  }];
  return function distortionIDBObjectStorePut$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNamedNodeMapSetNamedItem$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItem: originalSetNamedItem$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
    return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
      }

      return ReflectApply$1$LWS(originalSetNamedItem$LWS, this, args$LWS);
    }];
  };
}

function initDistortionNamedNodeMapSetNamedItemNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItemNS: originalSetNamedItemNS$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
    return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
      }

      return ReflectApply$1$LWS(originalSetNamedItemNS$LWS, this, args$LWS);
    }];
  };
}

function initDistortionNavigatorSendBeacon$LWS({
  globalObject: {
    Navigator: {
      prototype: {
        sendBeacon: originalSendBeacon$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(args$LWS[0]));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return ReflectApply$1$LWS(originalSendBeacon$LWS, this, args$LWS);
  }];
  return function distortionNavigatorSendBeacon$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNavigatorServiceWorkerGetter$LWS({
  globalObject: {
    Navigator: Navigator$LWS
  }
}) {
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$1$LWS(Navigator$LWS.prototype, 'serviceWorker'); // istanbul ignore if: needs default platform behavior test

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, noop$1$LWS];
  return function distortionNavigatorServiceWorkerGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$7$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
} = selfValidator$LWS;

function initDistortionNodeInsertBefore$LWS({
  globalObject: {
    Node: {
      prototype: {
        insertBefore: originalInsertBefore$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$7$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, [])} into ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])},`);
      }
    }

    return ReflectApply$1$LWS(originalInsertBefore$LWS, this, args$LWS);
  }];
  return function distortionNodeInsertBefore$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNodeValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS
  }
}) {
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');
  return function distortionNodeValueSetter$LWS(record$LWS) {
    return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the nodeValue property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$1$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

        if (ownerEl$LWS === null) {
          ReflectApply$1$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
          return;
        }

        const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          ReflectApply$1$LWS(distortion$LWS, ownerEl$LWS, [value$LWS]);
          return;
        }
      } // istanbul ignore next: needs default platform behavior test


      ReflectApply$1$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
    }];
  };
}

const {
  isSharedElement: isSharedElement$6$LWS
} = selfValidator$LWS;

function initDistortionNodeRemoveChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        removeChild: originalRemoveChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception
    // is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$6$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$1$LWS(originalRemoveChild$LWS, this, args$LWS);
  }];
  return function distortionNodeRemoveChild$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$5$LWS
} = selfValidator$LWS;

function initDistortionNodeReplaceChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        replaceChild: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments.
    // If the "old element" argument is a valid shared element, an
    // exception is thrown.
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$5$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$1$LWS(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionNodeReplaceChild$LWS() {
    return distortionEntry$LWS;
  };
} // IMPORTANT! This validator MUST use the top "window" global object, and not
// the provided "globalObject" because magenta objects (arbitrary user-code
// created global objects) must be allowed to interact with their OWN <html>,
// <head> and <body> (within the iframe content window). Using the provided
// "globalObject" here would result in receiving a validator bound to the
// magenta global object, which would erroneously prevent code from interacting
// with that document's <html>, <head> and <body>.


const {
  isSharedElement: isSharedElement$4$LWS
} = selfValidator$LWS;

function initDistortionNodeTextContentSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalTextContentSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'textContent');
  return function distortionNodeTextContentSetter$LWS(record$LWS) {
    const {
      sandboxEvaluator: sandboxEvaluator$LWS
    } = record$LWS;
    return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
      const valueAsString$LWS = toString$LWS(value$LWS); // There are two existence of the attribute textContent, one on
      // Attr and one on Node. This first if statement is checking to
      // figure out which distortion should be applied. The instanceof
      // operator tests to see if the current global object, this,
      // is of the type Attr, while also taking inheritance into
      // consideration.
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the textContent property.
      // istanbul ignore else: needs default platform behavior test

      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$1$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

        if (ownerEl$LWS === null) {
          ReflectApply$1$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          return;
        }

        const attrName$LWS = ReflectApply$1$LWS(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$1$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          ReflectApply$1$LWS(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
          return;
        }
      }

      if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        if (defineTextContentEvaluatorProperty$LWS(this, valueAsString$LWS, (sourceText$LWS, context$LWS, globalObject$LWS, document$LWS) => {
          // Set the textContent immediately after the
          // evaluator hook fires to overwrite the evaluator
          // hook source text. Subsequent sets change the
          // textContent value but are not evaluated.
          ReflectApply$1$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          sandboxEvaluator$LWS(sourceText$LWS, context$LWS, globalObject$LWS, document$LWS);
        })) {
          // Set and run the textContent evaluator hook.
          ReflectApply$1$LWS(originalTextContentSetter$LWS, this, [getTextContentEvaluatorHookSourceText$LWS()]);
          return;
        }
      } // istanbul ignore else: needs default platform behavior test
      else if (isSharedElement$4$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set textContent of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, this, [])} elements.`);
      }

      ReflectApply$1$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
    }];
  };
}

function initDistortionNotificationCtor$LWS({
  globalObject: {
    Notification: originalNotificationCtor$LWS
  }
}) {
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalNotificationCtor$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = partialStructuredClone$LWS(args$LWS[1]);
    }

    return ReflectApply$1$LWS(originalNotificationCtor$LWS, this, args$LWS);
  }];
  return function distortionNotificationCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionRangeCreateContextualFragment$LWS({
  globalObject: {
    Range: {
      prototype: {
        createContextualFragment: originalCreateContextualFragment$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = sanitize$LWS(tagString$LWS);
      }
    }

    return ReflectApply$1$LWS(originalCreateContextualFragment$LWS, this, args$LWS);
  }];
  return function distortionRangeCreateContextualFragment$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$3$LWS
} = selfValidator$LWS;

function initDistortionRangeDeleteContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        deleteContents: originalDeleteContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$1$LWS(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$1$LWS(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$1$LWS(originalEndContainerGetter$LWS, this, []), ReflectApply$1$LWS(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$3$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$1$LWS(originalDeleteContents$LWS, this, args$LWS);
  }];
  return function distortionRangeDeleteContents$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$2$LWS
} = selfValidator$LWS;

function initDistortionRangeExtractContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        extractContents: originalExtractContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$1$LWS(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$1$LWS(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$1$LWS(originalEndContainerGetter$LWS, this, []), ReflectApply$1$LWS(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$2$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$1$LWS(originalExtractContents$LWS, this, args$LWS);
  }];
  return function distortionRangeExtractContents$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$1$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
} = selfValidator$LWS;

function initDistortionRangeInsertNode$LWS({
  globalObject: {
    Range: {
      prototype: {
        insertNode: originalInsertNode$LWS
      }
    }
  }
}) {
  const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$1$LWS(Range.prototype, 'commonAncestorContainer');
  const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const commonAncestorContainer$LWS = ReflectApply$1$LWS(originalCommonAncestorContainerGetter$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$1$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
      }
    }

    return ReflectApply$1$LWS(originalInsertNode$LWS, this, args$LWS);
  }];
  return function distortionRangeInsertNode$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$LWS
} = selfValidator$LWS;

function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
  return function initDistortionContentWindowGetter$LWS({
    globalObject: {
      Range: {
        // @ts-ignore: Prevent index type error.
        prototype: {
          [methodName$LWS]: originalMethod$LWS
        }
      }
    }
  }) {
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [methodName$LWS]: distortion$LWS
    } = {
      [methodName$LWS](...args$LWS) {
        if (args$LWS.length) {
          const {
            0: node$LWS
          } = args$LWS; // istanbul ignore else: needs default platform behavior test

          if (isSharedElement$LWS(node$LWS)) {
            throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${ReflectApply$1$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, [])}.`);
          }
        }

        return ReflectApply$1$LWS(originalMethod$LWS, this, args$LWS);
      }

    };
    const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
    return function distortionContentWindowGetter$LWS() {
      return distortionEntry$LWS;
    };
  };
}

const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEnd');
const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNode');
const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNodeContents');
const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndAfter');
const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndBefore');
const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStart');
const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartAfter');
const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartBefore');
const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('surroundContents');

function initDistortionServiceWorkerContainerProto$LWS({
  globalObject: {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionServiceWorkerContainerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionShadowRootInnerHTMLSetter$LWS({
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');
  const distortionEntry$LWS = [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
    ReflectApply$1$LWS(originalInnerHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }];
  return function distortionShadowRootInnerHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function mode$LWS() {
  return 'closed';
}

function initDistortionShadowRootModeGetter$LWS({
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalModeGetter$LWS = ObjectLookupOwnGetter$1$LWS(ShadowRoot$LWS.prototype, 'mode');
  const distortionEntry$LWS = [originalModeGetter$LWS, mode$LWS];
  return function distortionShadowRootModeGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function SharedWorker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}

function initDistortionSharedWorkerCtor$LWS({
  globalObject: {
    SharedWorker: originalSharedWorkerCtor$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
  return function distortionSharedWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionSharedWorkerProto$LWS({
  globalObject: {
    SharedWorker: SharedWorker$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof SharedWorker$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionSharedWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (ReflectApply$1$LWS(StringProtoStartsWith$LWS, key$LWS, [storageRootKey$LWS])) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = ArrayCtor$1$LWS(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = ReflectApply$1$LWS(StringProtoReplace$LWS, key$LWS, [storageRootKey$LWS, '']);
  }

  return keys$LWS;
}

const storageToMetaMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS); // istanbul ignore if: currently unreachable via tests

  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(storageTarget$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(storageTarget$LWS, {
    // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
    get(target$LWS, key$LWS, receiver$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$1$LWS(storage$LWS, keyForNamespace$LWS)) {
        return ReflectGet$LWS(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = ReflectGetPrototypeOf$1$LWS(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      ReflectApply$1$LWS(StorageProtoSetItem$LWS, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
      const safeDesc$LWS = unsafePartialDesc$LWS;
      ReflectSetPrototypeOf$1$LWS(safeDesc$LWS, null);

      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDefineProperty$LWS(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$1$LWS(target$LWS, key$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDeleteProperty$1$LWS(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      let safeDesc$LWS;

      if (typeof key$LWS === 'symbol') {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } else {
        const {
          storage: storage$LWS,
          storageRootKey: storageRootKey$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, keyForNamespace$LWS);
      }

      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$1$LWS(safeDesc$LWS, null);
      }

      return safeDesc$LWS;
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },

    // istanbul ignore next: suspicious gap, currently unreachable via tests
    has(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$1$LWS(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = ReflectGetPrototypeOf$1$LWS(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return ReflectHas$LWS(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
  return proxy$LWS;
}

class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new LockerSecurityError$LWS('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return ReflectApply$1$LWS(StringProtoReplace$LWS, resolvedKey$LWS, [storageRootKey$LWS, '']);
    }

    return ReflectApply$1$LWS(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    return ReflectApply$1$LWS(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
      args$LWS[1] = toString$LWS(args$LWS[1]);
    }

    ReflectApply$1$LWS(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    ReflectApply$1$LWS(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$1$LWS(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const proxy$LWS = createStorageProxy$LWS({
    __proto__: PatchedStorage$LWS.prototype
  });
  trackTargetAsLive$LWS(proxy$LWS);
  storageToMetaMap$LWS.set(proxy$LWS, {
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  });
  return proxy$LWS;
}

const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$1$LWS(PatchedStorageProto$LWS, 'length');

function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
  return function initDistortionStorageFactory$LWS({
    globalObject: globalObject$LWS
  }) {
    // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.
    let originalStorageObject$LWS;

    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS]; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {} // istanbul ignore if: currently unreachable via tests


    if (!isObject$LWS(originalStorageObject$LWS)) {
      return alwaysNull$LWS;
    }

    return function distortionStorageFactory$LWS({
      key: key$LWS
    }) {
      return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, getStorageRootKey$LWS(key$LWS))];
    };
  };
}

function initDistortionStorageLength$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$1$LWS(Storage$LWS.prototype, 'length');
  const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
  return function distortionStorageLength$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageGetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        getItem: originalStorageGetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageSetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        setItem: originalStorageSetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageKey$LWS({
  globalObject: {
    Storage: {
      prototype: {
        key: originalStorageKey$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
  return function distortionStorageKey$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageRemoveItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        removeItem: originalStorageRemoveItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
  return function distortionStorageRemoveItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageClear$LWS({
  globalObject: {
    Storage: {
      prototype: {
        clear: originalStorageClear$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
  return function distortionStorageClear$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorage$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
  return function distortionStorage$LWS() {
    return distortionEntry$LWS;
  };
}

const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS('localStorage');
const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS('sessionStorage');

function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$1$LWS(_ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);

        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);

          if (distortion$LWS) {
            ReflectApply$1$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }

    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, function attributeName$LWS(value$LWS) {
      ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'from');
        distortAttribute$LWS(this, 'to');
        distortAttribute$LWS(this, 'values');
      }
    });
    return null;
  };
}

function initDistortionSVGAnimateElementFromAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function from$LWS(value$LWS) {
    if (ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', NAMESPACE_DEFAULT$LWS, from$LWS);
    return null;
  };
}

function initDistortionSVGAnimateElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    return null;
  };
}

function initDistortionSVGAnimateElementValuesAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = ReflectApply$1$LWS(StringProtoSplit$LWS, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = ReflectApply$1$LWS(ArrayProtoJoin$1$LWS, valuesSplit$LWS, [';']);
    }

    ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', NAMESPACE_DEFAULT$LWS, values$LWS);
    return null;
  };
}

function initDistortionSVGElementDatasetGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$1$LWS(SVGElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$1$LWS(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionSVGElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionSVGScriptElementHrefAttribute$LWS({
  globalObject: {
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  return function distortionSVGScriptElementHrefAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'href', SVGElementProtoDatasetGetter$LWS));
    registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href', SVGElementProtoDatasetGetter$LWS));
    return null;
  };
}

function initDistortionSVGSetElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$1$LWS(_ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]); // istanbul ignore else: needs default platform behavior test

        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS); // istanbul ignore else: needs default platform behavior test

          if (distortion$LWS) {
            ReflectApply$1$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }

    function attributeName$LWS(value$LWS) {
      ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'to');
      }
    }

    registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
    return null;
  };
}

function initDistortionSVGSetElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$1$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$1$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    return null;
  };
}

function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactoryInitializer$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS,
          setAttributeNS: originalSetAttributeNS$LWS
        }
      },
      SVGUseElement: SVGUseElement$LWS
    }
  }) {
    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
      /* istanbul ignore next: needs default platform behavior test */
      value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$1$LWS(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }

    return function distortionHrefAttributeFactory$LWS(record$LWS) {
      registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);

      if (attributeName$LWS === 'href') {
        const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
          const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
          /* istanbul ignore next: needs default platform behavior test */
          value$LWS : sanitizeSvgHref$LWS(value$LWS);
          ReflectApply$1$LWS(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
        };

        registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
      }

      return null;
    };
  };
}

const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('href');
const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('xlink:href');

function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
  globalObject: {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  }
}) {
  var _TrustedTypePolicyFac$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null ? void 0 : (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalCreatePolicy$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] :
    /* istanbul ignore next: needs default platform behavior test */
    undefined; // istanbul ignore else: needs default platform behavior test

    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$1$LWS(originalCreatePolicy$LWS, this, args$LWS);
  }];
  return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
    return distortionEntry$LWS;
  };
}

const HTML_MIME_TYPES_LIST$LWS = toSafeArray$1$LWS(['text/html', 'image/svg+xml', 'text/xml']);

function initDistortionURLCreateObjectURL$LWS({
  document: document$LWS,
  globalObject: globalObject$LWS,
  globalObject: {
    MediaSource: MediaSource$LWS,
    URL: {
      createObjectURL: originalCreateObjectURL$LWS
    }
  }
}) {
  // IMPORTANT! This validator MUST use the record's global object to create
  // a validator and not rely on the `selfValidator` because the validator
  // needs to be bound to the global object of the magenta object (arbitrary
  // user-code created global objects).
  const {
    isEqualDomString: isEqualDomString$LWS
  } = getValidator$LWS(globalObject$LWS, document$LWS);
  const distortionEntry$LWS = [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = ReflectApply$1$LWS(originalCreateObjectURL$LWS, this, [blobObject$LWS]);

    if ( // MediaSource may not be defined in some browsers.
    // https://caniuse.com/mdn-api_mediasource
    MediaSource$LWS && // MediaSource does not share the same prototype as Blob or File.
    // It can still be used with `createObjectURL()` however we need
    // to treat it separately. MediaSource does not accept plain text
    // input as Blob or File and does not have a MIME type.
    blobObject$LWS instanceof MediaSource$LWS) {
      return outURL$LWS;
    }

    const blobType$LWS = ReflectApply$1$LWS(BlobProtoTypeGetter$LWS, blobObject$LWS, []);

    if (blobType$LWS === '') {
      // Browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      const plainTextBlob$LWS = ReflectApply$1$LWS(BlobProtoSlice$LWS, blobObject$LWS, [0, undefined, 'text/plain']);
      return ReflectApply$1$LWS(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
    }

    const loweredBlobType$LWS = ReflectApply$1$LWS(StringProtoToLowerCase$LWS, blobType$LWS, []);

    if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
      const blobSize$LWS = ReflectApply$1$LWS(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
      const normalizedBlob$LWS = ReflectApply$1$LWS(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
      URLRevokeObjectURL$LWS(outURL$LWS);
      outURL$LWS = ReflectApply$1$LWS(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new XhrCtor$LWS();
      ReflectApply$1$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', outURL$LWS, false]);
      ReflectApply$1$LWS(XhrProtoSend$LWS, xhr$LWS, []);
      const sanitizer$LWS = blobSanitizer$LWS();
      const responseText$LWS = ReflectApply$1$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS(`Cannot 'createObjectURL' using a unsecure ${toSafeTemplateStringValue$LWS(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
      return outURL$LWS;
    }

    URLRevokeObjectURL$LWS(outURL$LWS);
    throw new LockerSecurityError$LWS('Unsupported MIME type.');
  }];
  return function distortionURLCreateObjectURL$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowFetch$LWS({
  globalObject: {
    fetch: originalFetch$LWS
  }
}) {
  const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(ReflectApply$1$LWS(RequestProtoURLGetter$LWS, url$LWS, []));
      } else {
        parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (!isValidURL$LWS(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
      }
    }

    return ReflectApply$1$LWS(originalFetch$LWS, this, args$LWS);
  }];
  return function distortionWindowFetch$LWS() {
    return distortionEntry$LWS;
  };
}
/* eslint-disable class-methods-use-this, max-classes-per-file */
// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target


class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }

  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }

  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }

  isExtensible(_target$LWS) {
    return true;
  }

  ownKeys(_target$LWS) {
    return [];
  }

  preventExtensions(_target$LWS) {
    return true;
  }

  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }

  setPrototypeOf(_target$LWS) {
    return false;
  }

}

ReflectSetPrototypeOf$1$LWS(BaseFrameHandler$LWS.prototype, null);
ObjectFreeze$1$LWS(BaseFrameHandler$LWS.prototype);

class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

ObjectFreeze$1$LWS(ShadowFramesPrototypeHandler$LWS.prototype);

function initDistortionWindowFramesGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$1$LWS(globalObject$LWS, 'frames'); // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const createFramesProxy$LWS = () => {
    const WindowPrototype$LWS = ReflectGetPrototypeOf$1$LWS(globalObject$LWS);
    const WindowProperties$LWS = ReflectGetPrototypeOf$1$LWS(WindowPrototype$LWS); // Wrap `WindowLengthGetter` in bound function to obscure the getter
    // source as "[native code]".

    const framesLengthGetter$LWS = ReflectApply$1$LWS(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]); // Wrap `noop` in bound function to obscure the setter source as
    // "[native code]".

    const framesLengthSetter$LWS = ReflectApply$1$LWS(FunctionProtoBind$LWS, noop$1$LWS, []);

    const getFrameByIndexKey$LWS = key$LWS => {
      const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;

      if (possibleIndex$LWS > -1 && NumberIsInteger$LWS(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$1$LWS(WindowLengthGetter$LWS, globalObject$LWS, [])) {
        const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);

        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }

      return undefined;
    };

    const getFrameByNameKey$LWS = key$LWS => {
      if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
      !ObjectHasOwn$1$LWS(globalObject$LWS, key$LWS) && // ...Or its prototype.
      !ObjectHasOwn$1$LWS(WindowPrototype$LWS, key$LWS)) {
        const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);

        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }

      return undefined;
    };

    const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? ReflectApply$1$LWS(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);

    class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getValueByKey$LWS(key$LWS);
        return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : // window.frames.length
        // window.frames[n]
        // window.frames['n']
        value$LWS;
      }

      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        if (key$LWS === 'length') {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            get: framesLengthGetter$LWS,
            set: framesLengthSetter$LWS
          };
        }

        const value$LWS = getFrameByIndexKey$LWS(key$LWS);

        if (value$LWS) {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }

        return undefined;
      } // istanbul ignore next: suspicious gap, currently unreachable via tests


      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
      }

      ownKeys() {
        const {
          length: length$LWS
        } = globalObject$LWS;
        const keys$LWS = ArrayCtor$1$LWS(length$LWS + 1);

        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          keys$LWS[i$LWS] = `${i$LWS}`;
        }

        keys$LWS[length$LWS] = 'length';
        return keys$LWS;
      }

    }

    ObjectFreeze$1$LWS(ShadowFrameHandler$LWS.prototype);

    class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) :
        /* istanbul ignore next: needs default platform behavior test */
        value$LWS;
      }

      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);

        if (value$LWS === undefined) {
          return value$LWS;
        }

        return {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: value$LWS,
          writable: false
        };
      } // istanbul ignore next: suspicious gap, currently unreachable via tests


      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
      }

      ownKeys() {
        const keys$LWS = [];
        let keysOffset$LWS = 0;
        const descMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
        ReflectSetPrototypeOf$1$LWS(descMap$LWS, null);

        for (const key$LWS in descMap$LWS) {
          // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
          if (typeof key$LWS === 'string') {
            const unsafeDesc$LWS = descMap$LWS[key$LWS];

            if (ObjectHasOwn$1$LWS(unsafeDesc$LWS, 'value') && isWindow$LWS(unsafeDesc$LWS.value)) {
              keys$LWS[keysOffset$LWS++] = key$LWS;
            }
          }
        }

        return keys$LWS;
      }

    }

    ObjectFreeze$1$LWS(ShadowWindowPropertiesHandler$LWS.prototype); // In order to preserve window.frames === window.frames, create a
    // shadow target object, to be used with the proxy object that is
    // returned by accesses to window.frames.

    const shadowFrames$LWS = {};
    const shadowFramesPrototype$LWS = {};
    const shadowWindowProperties$LWS = {};
    const shadowFramesHandler$LWS = ObjectFreeze$1$LWS(new ShadowFrameHandler$LWS());
    const shadowFramesPrototypeHandler$LWS = ObjectFreeze$1$LWS(new ShadowFramesPrototypeHandler$LWS());
    const shadowWindowPropertiesHandler$LWS = ObjectFreeze$1$LWS(new ShadowWindowPropertiesHandler$LWS());
    const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
    const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
    ReflectSetPrototypeOf$1$LWS(shadowFrames$LWS, framesPrototypeProxy$LWS);
    ReflectSetPrototypeOf$1$LWS(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
    return new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
  };

  let framesProxy$LWS;
  const distortionEntry$LWS = [originalWindowFramesGetter$LWS, // eslint-disable-next-line prefer-arrow-callback
  function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      framesProxy$LWS = createFramesProxy$LWS();
    }

    return framesProxy$LWS;
  }];
  return function distortionWindowFramesGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowGetComputedStyle$LWS({
  globalObject: {
    getComputedStyle: originalGetComputedStyle$LWS
  }
}) {
  const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
    return trackTargetAsLive$LWS(ReflectApply$1$LWS(originalGetComputedStyle$LWS, this, args$LWS));
  }];
  return function distortionWindowGetComputedStyle$LWS() {
    return distortionEntry$LWS;
  };
}

function length$LWS() {
  return 0;
}

function initDistortionWindowLengthGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$1$LWS(globalObject$LWS, 'length'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalLengthGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
  return function distortionWindowLengthGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function onstorage$LWS() {
  throw new LockerSecurityError$LWS('Cannot set window.onstorage.');
}

function initDistortionWindowOnstorage$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  const originalOnstorageSetter$LWS = ObjectLookupOwnSetter$LWS(globalObject$LWS, 'onstorage'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionMapEntry$LWS = [originalOnstorageSetter$LWS, onstorage$LWS];
  return function distortionWindowOnstorage$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, Window$LWS, 'storage');
    return distortionMapEntry$LWS;
  };
}

function initDistortionWindowOpen$LWS({
  globalObject: {
    open: originalWindowOpen$LWS
  }
}) {
  const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    return ReflectApply$1$LWS(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
  }];
  return function distortionWindowOpen$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowPostMessage$LWS({
  globalObject: {
    postMessage: originalPostMessage$LWS
  }
}) {
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$1$LWS(originalPostMessage$LWS, this, args$LWS);
  }];
  return function distortionWindowPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowSetInterval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setInterval: originalSetInterval$LWS
  }
}) {
  return function distortionWndowSetInterval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;

        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toString$LWS(callback$LWS); // Defer transforming source text asynchronously.

          let transformedSourceText$LWS; // Replace callback parameter.

          args$LWS[0] = () => {
            if (transformedSourceText$LWS === undefined) {
              transformedSourceText$LWS = transformUncompiledSourceText$LWS(sourceText$LWS);
            }

            sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
          };
        }
      }

      return ReflectApply$1$LWS(originalSetInterval$LWS, this, args$LWS);
    }];
  };
}

function initDistortionWindowSetTimeout$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setTimeout: originalSetTimeout$LWS
  }
}) {
  return function distortionWindowSetTimeout$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;

        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

          args$LWS[0] = () => {
            // Defer transforming source text asynchronously.
            sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
          };
        }
      }

      return ReflectApply$1$LWS(originalSetTimeout$LWS, this, args$LWS);
    }];
  };
}

function initDistortionWindowStructuredClone$LWS({
  // @ts-ignore: Prevent property existence error.
  globalObject: {
    structuredClone: originalStructuredClone$LWS
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalStructuredClone$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$1$LWS(originalStructuredClone$LWS, this, args$LWS);
  }];
  return function distortionWindowStructuredClone$LWS() {
    return distortionEntry$LWS;
  };
}

function Worker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}

function initDistortionWorkerCtor$LWS({
  globalObject: {
    Worker: originalWorkerCtor$LWS
  }
}) {
  const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
  return function distortionWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWorkerProto$LWS({
  globalObject: {
    Worker: {
      prototype: originalPrototype$LWS
    }
  }
}) {
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestOpen$LWS({
  globalObject: {
    XMLHttpRequest: {
      prototype: {
        open: originalOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    ReflectApply$1$LWS(originalOpen$LWS, this, args$LWS);
  }];
  return function distortionXMLHttpRequestOpen$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestResponseGetter$LWS({
  globalObject: {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$1$LWS(XMLHttpRequest$LWS.prototype, 'response');
  const distortionEntry$LWS = [originalResponseGetter$LWS, function response$LWS() {
    const rawResponse$LWS = ReflectApply$1$LWS(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS) :
    /* istanbul ignore next: needs default platform behavior test */
    rawResponse$LWS;
  }];
  return function distortionXMLHttpRequestResponseGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
  globalObject: {
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$1$LWS(XMLHttpRequest$LWS.prototype, 'responseXML');
  const distortionEntry$LWS = [originalResponseXMLGetter$LWS, function responseXML$LWS() {
    const rawResponseXML$LWS = ReflectApply$1$LWS(originalResponseXMLGetter$LWS, this, []);
    return sanitizeDocument$LWS(rawResponseXML$LWS);
  }];
  return function distortionXMLHttpRequestResponseXMLGetter$LWS() {
    return distortionEntry$LWS;
  };
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const internalDistortionFactoryInitializers$LWS = [// CSSStyleRule
initDistortionCSSStyleRuleStyleGetter$LWS, // Document
initDistortionDocumentDomainSetter$LWS, initDistortionDocumentExecCommand$LWS, initDistortionDocumentOpen$LWS, // DOMParser
initDistortionDOMParserParseFromString$LWS, // Element
initDistortionElementAttachShadow$LWS, initDistortionElementAttributesGetter$LWS, initDistortionElementInnerHTMLSetter$LWS, initDistortionElementOuterHTMLSetter$LWS, initDistortionElementInsertAdjacentHTML$LWS, initDistortionElementRemove$LWS, initDistortionElementReplaceChildren$LWS, initDistortionElementReplaceWith$LWS, // Event
initDistortionEventComposedPath$LWS, initDistortionEventPathGetter$LWS, // Function
initDistortionFunction$LWS, // History
initDistortionHistoryPushState$LWS, initDistortionHistoryReplaceState$LWS, // HTMLElement
initDistortionHTMLElementDatasetGetter$LWS, initDistortionHTMLElementInnerTextSetter$LWS, initDistortionHTMLElementOuterTextSetter$LWS, initDistortionHTMLElementStyleGetter$LWS, // HTMLIFrameElement
initDistortionHTMLIFrameElementSrcSetter$LWS, // HTMLLinkElement
initDistortionHTMLLinkElementRelSetter$LWS, initDistortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
initDistortionHTMLObjectElementDataSetter$LWS, // HTMLScriptElement
initDistortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
initDistortionIDBObjectStoreAdd$LWS, initDistortionIDBObjectStorePut$LWS, // Navigator
initDistortionNavigatorSendBeacon$LWS, initDistortionNavigatorServiceWorkerGetter$LWS, // Node
initDistortionNodeRemoveChild$LWS, initDistortionNodeReplaceChild$LWS, // Notification
initDistortionNotificationCtor$LWS, // Range
initDistortionRangeCreateContextualFragment$LWS, initDistortionRangeDeleteContents$LWS, initDistortionRangeExtractContents$LWS, initDistortionRangeInsertNode$LWS, initDistortionRangeSelectNode$LWS, initDistortionRangeSelectNodeContents$LWS, initDistortionRangeSetEnd$LWS, initDistortionRangeSetEndAfter$LWS, initDistortionRangeSetEndBefore$LWS, initDistortionRangeSetStart$LWS, initDistortionRangeSetStartAfter$LWS, initDistortionRangeSetStartBefore$LWS, initDistortionRangeSurroundContents$LWS, // ServiceWorkerContainer
initDistortionServiceWorkerContainerProto$LWS, // ShadowRoot
initDistortionShadowRootInnerHTMLSetter$LWS, initDistortionShadowRootModeGetter$LWS, // SharedWorker
initDistortionSharedWorkerCtor$LWS, initDistortionSharedWorkerProto$LWS, // Storage
initDistortionStorageLength$LWS, initDistortionStorageGetItem$LWS, initDistortionStorageSetItem$LWS, initDistortionStorageKey$LWS, initDistortionStorageRemoveItem$LWS, initDistortionStorageClear$LWS, initDistortionStorage$LWS, // SVGAnimateElement
initDistortionSVGAnimateElementFromAttribute$LWS, initDistortionSVGAnimateElementToAttribute$LWS, initDistortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
initDistortionSVGElementDatasetGetter$LWS, // SVGSetElement
initDistortionSVGSetElementToAttribute$LWS, // SVGUseElement
initDistortionSVGUseElementHrefAttribute$LWS, initDistortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
initDistortionURLCreateObjectURL$LWS, // Window
initDistortionWindowFetch$LWS, initDistortionWindowFramesGetter$LWS, initDistortionWindowGetComputedStyle$LWS, initDistortionWindowLengthGetter$LWS, initDistortionWindowOpen$LWS, initDistortionWindowPostMessage$LWS, initDistortionWindowStructuredClone$LWS, // Worker
initDistortionWorkerCtor$LWS, initDistortionWorkerProto$LWS, // XHR
initDistortionXMLHttpRequestOpen$LWS, initDistortionXMLHttpRequestResponseGetter$LWS, initDistortionXMLHttpRequestResponseXMLGetter$LWS];
const internalKeyedDistortionFactoryInitializers$LWS = [// Attr
initDistortionAttrValueSetter$LWS, // Aura
initDistortionAuraUtilGlobalEval$LWS, // CacheStorage
initDistortionCacheStorageDelete$LWS, initDistortionCacheStorageHas$LWS, initDistortionCacheStorageKeys$LWS, initDistortionCacheStorageMatch$LWS, initDistortionCacheStorageOpen$LWS, // CookieStore
initDistortionCookieStoreDelete$LWS, initDistortionCookieStoreGet$LWS, initDistortionCookieStoreGetAll$LWS, initDistortionCookieStoreOnChange$LWS, initDistortionCookieStoreSet$LWS, // Document
initDistortionDocumentCookieGetter$LWS, initDistortionDocumentCookieSetter$LWS, initDistortionDocumentReplaceChildren$LWS, // CustomElementRegistry
initDistortionCustomElementRegistryGet$LWS, // Element
initDistortionElementSetAttribute$LWS, initDistortionElementSetAttributeNode$LWS, initDistortionElementSetAttributeNodeNS$LWS, initDistortionElementSetAttributeNS$LWS, initDistortionElementToggleAttribute$LWS, // EventTarget
initDistortionEventTargetAddEventListener$LWS, // HTMLScriptElement,
initDistortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
initDistortionNamedNodeMapSetNamedItem$LWS, initDistortionNamedNodeMapSetNamedItemNS$LWS, // Node
initDistortionNodeValueSetter$LWS, initDistortionNodeTextContentSetter$LWS, // Storage
initDistortionLocalStorage$LWS, initDistortionSessionStorage$LWS, // SVGAnimationElement
initDistortionSVGAnimateElementAttributeNameAttribute$LWS, // SVGScriptElement
initDistortionSVGScriptElementHrefAttribute$LWS, // SVGSetElement
initDistortionSVGSetElementAttributeNameAttribute$LWS, // Window
initDistortionWindowOnstorage$LWS, initDistortionWindowSetInterval$LWS, initDistortionWindowSetTimeout$LWS];
const externalDistortionFactoryInitializers$LWS = ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, [// Element
initDistortionElementAfter$LWS, initDistortionElementAppend$LWS, initDistortionElementBefore$LWS, initDistortionElementInsertAdjacentElement$LWS, initDistortionElementPrepend$LWS, initDistortionElementShadowRootGetter$LWS, // Node
// The initDistortionNodeAppendChild distortion is temporarily disabled
// until W-10409618 is resolved..
// initDistortionNodeAppendChild,
initDistortionNodeInsertBefore$LWS]);
const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
const evaluationDistortionFactoryInitializers$LWS = [// eval
initDistortionEval$LWS];
const opaqueDistortionFactoryInitializers$LWS = [// Window
initDistortionWindowPostMessage$LWS];
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument']; // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];

const {
  apply: ReflectApply$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn$LWS(object$LWS, __key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [__key$LWS]);
};

function ObjectLookupOwnGetter$LWS(object$LWS, __key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, __key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [__key$LWS]);
}

const {
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = Symbol;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  filter: ArrayProtoFilter$LWS,
  find: ArrayProtoFind$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  shift: ArrayProtoShift$LWS,
  slice: ArrayProtoSlice$LWS,
  some: ArrayProtoSome$LWS,
  sort: ArrayProtoSort$LWS,
  splice: ArrayProtoSplice$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  unshift: ArrayProtoUnshift$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  push: ArrayProtoPush$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;

function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}

const ErrorCtor$LWS = Error;
const TypeErrorCtor$LWS = TypeError;

function noop$LWS() {// No operation performed.
}

const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  has: WeakMapProtoHas$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;

function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}
/**
 * This file contains an exportable (portable) function `init()` used to initialize
 * one side of a membrane on any realm. The only prerequisite is the ability to
 * evaluate the sourceText of the `init()` function there. Once evaluated, the
 * function will return a set of values that can be used to wire up the side of
 * the membrane with another existing `init()` function from another realm, in
 * which case they will exchange callable functions that are required to connect
 * the two realms via the membrane.
 *
 * About the mechanics of the membrane, there are few important considerations:
 *
 * 1. Pointers are the way to pass reference to object and functions.
 * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed
 *    to represent the absence of a value.
 * 3. The realm that owns the object or function is responsible for projecting
 *    the proxy onto the other side (via callablePushTarget), which returns a
 *    Pointer that can be used by the realm to pass the reference to the same
 *    proxy over and over again.
 * 4. The realm that owns the proxy (after the other side projects it into it)
 *    will hold a Pointer alongside the proxy to signal what original object or
 *    function should the foreign operation operates, it is always the first
 *    argument of the foreign callable for proxies, and the other side can use
 *    it via `selectedTarget!`.
 */


const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS()); // istanbul ignore next

function createMembraneMarshall$LWS(_globalObject$LWS) {
  var _ReflectApply$LWS, _ref$LWS, _ref2$LWS;
  /* eslint-disable prefer-object-spread */


  const ArrayCtor$LWS = Array;
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const ErrorCtor$LWS = Error;
  const NumberCtor$LWS = Number;
  const ObjectCtor$LWS = Object;
  const ProxyCtor$LWS = Proxy;
  const ReflectRef$LWS = Reflect;
  const RegExpCtor$LWS = RegExp;
  const StringCtor$LWS = String;
  const SymbolCtor$LWS = Symbol;
  const TypeErrorCtor$LWS = TypeError; // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow

  const WeakMapCtor$LWS = WeakMap;
  const {
    for: SymbolFor$LWS,
    toStringTag: SymbolToStringTag$LWS
  } = SymbolCtor$LWS;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = ReflectRef$LWS;
  const {
    assign: ObjectAssign$LWS,
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS,
    getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    isFrozen: ObjectIsFrozen$LWS,
    isSealed: ObjectIsSealed$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS,
    seal: ObjectSeal$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
    propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __defineGetter__: ObjectProtoDefineGetter$LWS,
    __defineSetter__: ObjectProtoDefineSetter$LWS,
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : (object$LWS, __key$LWS) => ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [__key$LWS]);
  const IS_IN_SHADOW_REALM$LWS = typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerDebugMode') : undefined;
  const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembraneSerializedValue') : undefined;
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembrane') : undefined;
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue'); // The default stack trace limit in Chrome is 10.
  // Set to 20 to account for stack trace filtering.

  const LOCKER_STACK_TRACE_LIMIT$LWS = 20; // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime.

  const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
  /* $LWS */
  1}`.includes('*'); // Indicate whether debug support is available.

  const LOCKER_DEBUGGABLE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS && !IS_IN_SHADOW_REALM$LWS; // BigInt is not supported in Safari 13.1.
  // https://caniuse.com/bigint

  const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : undefined; // Minification safe reference to the private `BoundaryProxyHandler`
  // 'serializedValue' property name.

  let MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS; // Minification safe references to the private `BoundaryProxyHandler`
  // 'apply' and 'construct' trap variant's property names.

  let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
  const {
    isArray: isArrayOrThrowForRevoked$LWS
  } = ArrayCtor$LWS;
  const {
    includes: ArrayProtoIncludes$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    slice: ArrayProtoSlice$LWS
  } = ArrayCtor$LWS.prototype;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;
  const {
    toString: ErrorProtoToString$LWS
  } = ErrorCtor$LWS.prototype;
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  const {
    isInteger: NumberIsInteger$LWS
  } = NumberCtor$LWS;
  const {
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS.prototype;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS,
    toString: RegExProtoToString$LWS
  } = RegExpProto$LWS; // Edge 15 does not support RegExp.prototype.flags.
  // https://caniuse.com/mdn-javascript_builtins_regexp_flags

  const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['flags'])) != null ? _ReflectApply$LWS : function flags$LWS() {
    const _string$LWS = ReflectApply$LWS(RegExProtoToString$LWS, this, []);
    return ReflectApply$LWS(RegExpProtoExec$LWS, FLAGS_REG_EXP$LWS, [_string$LWS])[0];
  } : undefined;
  const RegExpProtoSourceGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['source']);
  const {
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringCtor$LWS.prototype;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS.prototype;
  const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, // eslint-disable-next-line no-proto
  Uint8Array.prototype.__proto__, ['length']);
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    has: WeakMapProtoHas$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  const consoleObject$LWS = !IS_IN_SHADOW_REALM$LWS && typeof console === 'object' && console !== null ? console : undefined;
  const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
  const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : undefined;
  const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = _globalObject$LWS != null ? _globalObject$LWS : // Support for globalThis was added in Chrome 71.
  // https://caniuse.com/mdn-javascript_builtins_globalthisfor
  typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2$LWS : // However, environments like Android emulators are running Chrome 69.
  // eslint-disable-next-line no-restricted-globals
  typeof self !== 'undefined' ? self : undefined) != null ? _ref$LWS : ( // See https://mathiasbynens.be/notes/globalthis for more details.
  ReflectDefineProperty$LWS(ObjectProto$LWS, 'globalThis', {
    __proto__: null,
    configurable: true,

    get() {
      ReflectDeleteProperty$LWS(ObjectProto$LWS, 'globalThis'); // Safari 12 on iOS 12.1 has a `this` of `undefined` so we
      // fallback to `self`.
      // eslint-disable-next-line no-restricted-globals

      return this != null ? this : self;
    }

  }), globalThis); // Install flags to ensure things are installed once per realm.

  let installedErrorPrepareStackTraceFlag$LWS = false;
  let installedPropertyDescriptorMethodWrappersFlag$LWS = false;

  function alwaysFalse$LWS() {
    return false;
  }

  const installErrorPrepareStackTrace$LWS = LOCKER_UNMINIFIED_FLAG$LWS ? () => {
    if (installedErrorPrepareStackTraceFlag$LWS) {
      return;
    }

    installedErrorPrepareStackTraceFlag$LWS = true; // Feature detect the V8 stack trace API.
    // https://v8.dev/docs/stack-trace-api

    const CallSite$LWS = (() => {
      try {
        var _callSites$$LWS;

        ErrorCtor$LWS.prepareStackTrace = (_error$LWS, callSites) => callSites;

        const callSites = new ErrorCtor$LWS().stack;
        ReflectDeleteProperty$LWS(ErrorCtor$LWS, 'prepareStackTrace');
        return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : undefined; // eslint-disable-next-line no-empty
      } catch (__unused$LWS) {}

      return undefined;
    })();

    if (typeof CallSite$LWS !== 'function') {
      return;
    }

    const {
      getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
      getFunctionName: CallSiteProtoGetFunctionName$LWS,
      toString: CallSiteProtoToString$LWS
    } = CallSite$LWS.prototype; // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.

    const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS(`${// Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.
    ReflectApply$LWS(StringProtoReplace$LWS, LOCKER_IDENTIFIER_MARKER$LWS, [/[\\^$.*+?()[\]{}|]/g, '\\$&']) // Function name references in call sites also contain
    // the name of the class they belong to,
    // e.g. myClassName.myFunctionName.
    }(?=\\.|$)`);

    const formatStackTrace = function formatStackTrace(error, callSites) {
      // Based on V8's default stack trace formatting:
      // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371
      let stackTrace$LWS = '';

      try {
        stackTrace$LWS = ReflectApply$LWS(ErrorProtoToString$LWS, error, []);
      } catch (_unused2$LWS) {
        stackTrace$LWS = '<error>';
      }

      let consecutive$LWS = false;

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = callSites; _i$LWS < _length$LWS; _i$LWS += 1) {
        const callSite$LWS = callSites[_i$LWS];
        const funcName$LWS = ReflectApply$LWS(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
        let isMarked$LWS = false;

        if (typeof funcName$LWS === 'string' && funcName$LWS !== 'eval' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
          isMarked$LWS = true;
        }

        if (!isMarked$LWS) {
          const evalOrigin$LWS = ReflectApply$LWS(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);

          if (typeof evalOrigin$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
            isMarked$LWS = true;
          }
        } // Only write a single LWS entry per consecutive LWS stacks.


        if (isMarked$LWS) {
          if (!consecutive$LWS) {
            consecutive$LWS = true;
            stackTrace$LWS += '\n    at LWS';
          }

          continue;
        } else {
          consecutive$LWS = false;
        }

        try {
          stackTrace$LWS += `\n    at ${ReflectApply$LWS(CallSiteProtoToString$LWS, callSite$LWS, [])}`; // eslint-disable-next-line no-empty
        } catch (_unused3$LWS) {}
      }

      return stackTrace$LWS;
    };

    try {
      // Error.prepareStackTrace cannot be a bound or proxy wrapped
      // function, so to obscure its source we wrap the call to
      // formatStackTrace().
      ErrorCtor$LWS.prepareStackTrace = function prepareStackTrace(error, callSites) {
        return formatStackTrace(error, callSites);
      }; // eslint-disable-next-line no-empty

    } catch (_unused4$LWS) {}

    try {
      const {
        stackTraceLimit: stackTraceLimit$LWS
      } = ErrorCtor$LWS;

      if (typeof stackTraceLimit$LWS !== 'number' || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
        ErrorCtor$LWS.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
      } // eslint-disable-next-line no-empty

    } catch (_unused5$LWS) {}
  } : noop$LWS;

  function noop$LWS() {// No-operation.
  }

  const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? bigIntObject$LWS => // Section 21.2.3 Properties of the BigInt Prototype Object
  // https://tc39.es/ecma262/#thisbigintvalue
  // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
  //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
  ReflectApply$LWS(BigIntProtoValueOf$LWS, bigIntObject$LWS, []) : noop$LWS;
  const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? booleanObject$LWS => // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  ReflectApply$LWS(BooleanProtoValueOf$LWS, booleanObject$LWS, []) : noop$LWS;
  const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? numberObject$LWS => // 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  ReflectApply$LWS(NumberProtoValueOf$LWS, numberObject$LWS, []) : noop$LWS;
  const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? __value$LWS => {
    // 22.2.5.12 get RegExp.prototype.source
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (__value$LWS !== RegExpProto$LWS) {
      const source$LWS = ReflectApply$LWS(RegExpProtoSourceGetter$LWS, __value$LWS, []);
      return JSONStringify$LWS({
        __proto__: null,
        flags: ReflectApply$LWS(RegExpProtoFlagsGetter$LWS, __value$LWS, []),
        source: source$LWS
      });
    }

    return undefined;
  } : noop$LWS;
  const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? stringObject$LWS => // 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  ReflectApply$LWS(StringProtoValueOf$LWS, stringObject$LWS, []) : noop$LWS;
  const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? symbolObject$LWS => // 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  ReflectApply$LWS(SymbolProtoValueOf$LWS, symbolObject$LWS, []) : noop$LWS;
  const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []);

    switch (brand$LWS) {
      // The brand checks below represent boxed primitives of
      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
      // which are not remapped or reflective.
      case '[object Boolean]':
        return serializeBooleanObject$LWS(__target$LWS);

      case '[object Number]':
        return serializeNumberObject$LWS(__target$LWS);

      case '[object RegExp]':
        return serializeRegExp$LWS(__target$LWS);

      case '[object String]':
        return serializeStringObject$LWS(__target$LWS);

      case '[object Object]':
        try {
          // Symbol.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
          return serializeSymbolObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
        } catch (_unused6$LWS) {}

        if (SUPPORTS_BIG_INT$LWS) {
          // BigInt.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
          try {
            return serializeBigIntObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
          } catch (_unused7$LWS) {}
        }

      // eslint-disable-next-line no-fallthrough

      default:
        return undefined;
    }
  } : noop$LWS;
  const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
    // The serialization attempts below represent boxed primitives of
    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
    // which are not remapped or reflective.
    try {
      // Symbol.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
      return serializeSymbolObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}

    if (SUPPORTS_BIG_INT$LWS) {
      // BigInt.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
      try {
        return serializeBigIntObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
      } catch (_unused9$LWS) {}
    }

    try {
      return serializeBooleanObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused10$LWS) {}

    try {
      return serializeNumberObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused11$LWS) {}

    try {
      return serializeRegExp$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}

    try {
      return serializeStringObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}

    return undefined;
  } : noop$LWS;

  function toSafeTemplateStringValue$LWS(__value$LWS) {
    if (typeof __value$LWS === 'string') {
      return __value$LWS;
    }

    try {
      if (typeof __value$LWS === 'object' && __value$LWS !== null) {
        const _result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __value$LWS, []);
        return _result$LWS === '[object Symbol]' ? ReflectApply$LWS(SymbolProtoToString$LWS, __value$LWS, []) : _result$LWS;
      }

      if (typeof __value$LWS === 'function') {
        return ReflectApply$LWS(FunctionProtoToString$LWS, __value$LWS, []);
      } // Attempt to coerce `value` to a string with the String() constructor.
      // Section 22.1.1.1 String ( value )
      // https://tc39.es/ecma262/#sec-string-constructor-string-value


      return StringCtor$LWS(__value$LWS); // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}

    return '[Object Unknown]';
  } // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }

  return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, options$LWS) {
    if (IS_IN_SHADOW_REALM$LWS) {
      options$LWS = undefined;
    }

    const {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS // eslint-disable-next-line prefer-object-spread

    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    !IS_IN_SHADOW_REALM$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
    const arityToApplyTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const arityToConstructTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const localProxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const proxyTargetToPointerMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
    let foreignCallablePushErrorTarget$LWS;
    let foreignCallablePushTarget$LWS;
    let foreignCallableApply$LWS;
    let foreignCallableConstruct$LWS;
    let foreignCallableDefineProperty$LWS;
    let foreignCallableDeleteProperty$LWS;
    let foreignCallableGet$LWS;
    let foreignCallableGetOwnPropertyDescriptor$LWS;
    let foreignCallableGetPrototypeOf$LWS;
    let foreignCallableHas$LWS;
    let foreignCallableIsExtensible$LWS;
    let foreignCallableOwnKeys$LWS;
    let foreignCallablePreventExtensions$LWS;
    let foreignCallableSet$LWS;
    let foreignCallableSetPrototypeOf$LWS;
    let foreignCallableDebugInfo$LWS;
    let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableGetTargetIntegrityTraits$LWS;
    let foreignCallableGetToStringTagOfTarget$LWS;
    let foreignCallableGetTypedArrayIndexedValue$LWS;
    let foreignCallableInstallErrorPrepareStackTrace$LWS;
    let foreignCallableIsTargetLive$LWS;
    let foreignCallableIsTargetRevoked$LWS;
    let foreignCallableSerializeTarget$LWS;
    let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
    let nearMembraneSymbolFlag$LWS = false;
    let lastProxyTrapCalled$LWS = 0;
    let selectedTarget$LWS;
    const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, __key$LWS, state$LWS) => {
      state$LWS[__key$LWS] = false;
      const foreignTargetPointer$LWS = getTransferablePointer$LWS(__target$LWS);
      let _safeDesc$LWS;

      try {
        foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        });
      } catch (error) {
        var _selectedTarget$LWS;

        const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }

      if (_safeDesc$LWS) {
        ReflectDefineProperty$LWS(__target$LWS, __key$LWS, _safeDesc$LWS);
      } else {
        ReflectDeleteProperty$LWS(__target$LWS, __key$LWS);
      }
    } : noop$LWS;
    let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
      try {
        if (ObjectHasOwn$LWS(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
          checkDebugMode$LWS = () => true;

          installErrorPrepareStackTrace$LWS();
          foreignCallableInstallErrorPrepareStackTrace$LWS();
        }
      } catch (_unused15$LWS) {
        checkDebugMode$LWS = alwaysFalse$LWS;
      }

      return false;
    } : alwaysFalse$LWS;

    function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget');
      }

      let protoPointerOrNull$LWS;

      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
          const descriptors$LWS = {};

          for (let _i$LWS = 0, {
            length: _length$LWS
          } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
            const __key$LWS = descriptorTuples$LWS[_i$LWS];
            descriptors$LWS[__key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], // configurable
            descriptorTuples$LWS[_i$LWS + 2], // enumerable
            descriptorTuples$LWS[_i$LWS + 3], // writable
            descriptorTuples$LWS[_i$LWS + 4], // valuePointer
            descriptorTuples$LWS[_i$LWS + 5], // getterPointer
            descriptorTuples$LWS[_i$LWS + 6] // setterPointer
            );
          } // Use `ObjectDefineProperties()` instead of individual
          // `ReflectDefineProperty()` calls for better performance.


          ObjectDefineProperties$LWS(shadowTarget$LWS, descriptors$LWS);
        });
      } catch (error) {
        var _selectedTarget2$LWS;

        const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _proto$LWS;

      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        _proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _proto$LWS = null;
      }

      ReflectSetPrototypeOf$LWS(shadowTarget$LWS, _proto$LWS);

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }
    }

    function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}()`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrap$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 0) {
          var _arityToApplyOrConstr$LWS;

          return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS);
        } catch (error) {
          var _selectedTarget3$LWS;

          const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(1)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForOneOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 1) {
          var _arityToApplyOrConstr2$LWS;

          return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS);
        } catch (error) {
          var _selectedTarget4$LWS;

          const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(2)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 2) {
          var _arityToApplyOrConstr3$LWS;

          return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS);
        } catch (error) {
          var _selectedTarget5$LWS;

          const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(3)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 3) {
          var _arityToApplyOrConstr4$LWS;

          return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS);
        } catch (error) {
          var _selectedTarget6$LWS;

          const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(4)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 4) {
          var _arityToApplyOrConstr5$LWS;

          return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS, // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS);
        } catch (error) {
          var _selectedTarget7$LWS;

          const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(5)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 5) {
          var _arityToApplyOrConstr6$LWS;

          return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS,
            4: arg4$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS, // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS, // Inline getTransferableValue().
          typeof arg4$LWS === 'object' && arg4$LWS !== null || typeof arg4$LWS === 'function' ? getTransferablePointer$LWS(arg4$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg4$LWS === 'undefined' ? undefined : arg4$LWS);
        } catch (error) {
          var _selectedTarget8$LWS;

          const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const nativeMethodName$LWS = isApplyTrap$LWS ? 'apply' : 'construct';
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS; // @ts-ignore: Prevent private property access error.

        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(`Reflect.${nativeMethodName$LWS}(${_length$LWS})`);
        }

        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let combinedOffset$LWS = 2;
        const combinedArgs$LWS = new ArrayCtor$LWS(_length$LWS + combinedOffset$LWS);
        combinedArgs$LWS[0] = foreignTargetPointer$LWS;
        let pointerOrPrimitive$LWS;

        try {
          combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS;

          for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
            const arg$LWS = _args$LWS[_i$LWS]; // Inlining `getTransferableValue()`.

            combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === 'object' && arg$LWS !== null || typeof arg$LWS === 'function' ? getTransferablePointer$LWS(arg$LWS) : // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg$LWS === 'undefined' ? undefined : arg$LWS;
          }

          pointerOrPrimitive$LWS = ReflectApply$LWS(foreignCallableApplyOrConstruct$LWS, undefined, combinedArgs$LWS);
        } catch (error) {
          var _selectedTarget9$LWS;

          const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
      const _safeDesc$LWS = {
        __proto__: null
      };

      if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.configurable = configurable$LWS;
      }

      if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.enumerable = enumerable$LWS;
      }

      if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.writable = writable$LWS;
      }

      if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof getterPointerOrPrimitive$LWS === 'function') {
          getterPointerOrPrimitive$LWS();
          _safeDesc$LWS.get = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.get = undefined;
        }
      }

      if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof setterPointerOrPrimitive$LWS === 'function') {
          setterPointerOrPrimitive$LWS();
          _safeDesc$LWS.set = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.set = undefined;
        }
      }

      if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof valuePointerOrPrimitive$LWS === 'function') {
          valuePointerOrPrimitive$LWS();
          _safeDesc$LWS.value = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
        }
      }

      return _safeDesc$LWS;
    }

    function createPointer$LWS(originalTarget$LWS) {
      const pointer$LWS = () => {
        // assert: selectedTarget is undefined
        selectedTarget$LWS = originalTarget$LWS;
      };

      return pointer$LWS;
    }

    const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
      let state$LWS = localProxyTargetToLazyPropertyDescriptorStateMap$LWS.get(__target$LWS);

      if (state$LWS === undefined) {
        const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS));

        if (typeof statePointerOrUndefined$LWS === 'function') {
          statePointerOrUndefined$LWS();
          state$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;

          if (state$LWS) {
            localProxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
          }
        }
      }

      return state$LWS;
    } : noop$LWS;

    function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
      let proxyPointer$LWS = proxyTargetToPointerMap$LWS.get(originalTarget$LWS);

      if (proxyPointer$LWS) {
        return proxyPointer$LWS;
      }

      let distortionTarget$LWS;

      if (distortionCallback$LWS) {
        distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS); // If a distortion entry is found, it must be a valid proxy target.

        if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
          throw new TypeErrorCtor$LWS(`Invalid distortion ${toSafeTemplateStringValue$LWS(originalTarget$LWS)}.`);
        }
      } else {
        distortionTarget$LWS = originalTarget$LWS;
      }

      let isPossiblyRevoked$LWS = true;
      let targetFunctionArity$LWS = 0;
      let targetFunctionName$LWS = '';
      let targetTypedArrayLength$LWS = 0;
      let targetTraits$LWS = 16
      /* TargetTraits.IsObject */
      ;

      if (typeof distortionTarget$LWS === 'function') {
        isPossiblyRevoked$LWS = false;
        targetFunctionArity$LWS = 0;
        targetTraits$LWS = 4
        /* TargetTraits.IsFunction */
        ;

        try {
          // Detect arrow functions.
          if (!('prototype' in distortionTarget$LWS)) {
            targetTraits$LWS |= 8
            /* TargetTraits.IsArrowFunction */
            ;
          }

          const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'length');

          if (safeLengthDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeLengthDesc$LWS, null);
            const {
              value: safeLengthDescValue$LWS
            } = safeLengthDesc$LWS;

            if (typeof safeLengthDescValue$LWS === 'number') {
              targetFunctionArity$LWS = safeLengthDescValue$LWS;
            }
          }

          const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'name') : undefined;
          if (safeNameDesc$LWS) ;
        } catch (_unused16$LWS) {
          isPossiblyRevoked$LWS = true;
        }
      } else if (ArrayBufferIsView$LWS(distortionTarget$LWS)) {
        isPossiblyRevoked$LWS = false;
        targetTraits$LWS = 2
        /* TargetTraits.IsArrayBufferView */
        ;

        try {
          targetTypedArrayLength$LWS = ReflectApply$LWS(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
          targetTraits$LWS |= 32
          /* TargetTraits.IsTypedArray */
          ; // eslint-disable-next-line no-empty
        } catch (_unused17$LWS) {
          // Could be a DataView object or a revoked proxy.
          isPossiblyRevoked$LWS = true;
        }
      }

      if (isPossiblyRevoked$LWS) {
        try {
          if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
            targetTraits$LWS = 1
            /* TargetTraits.IsArray */
            ;
          }
        } catch (_unused18$LWS) {
          targetTraits$LWS = 64
          /* TargetTraits.Revoked */
          ;
        }
      }

      proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS); // The WeakMap is populated with the original target rather then the
      // distorted one while the pointer always uses the distorted one.
      // TODO: This mechanism poses another issue, which is that the return
      // value of selectedTarget! can never be used to call across the
      // membrane because that will cause a wrapping around the potential
      // distorted value instead of the original value. This is not fatal,
      // but implies that for every distorted value where are two proxies
      // that are not ===, which is weird. Guaranteeing this is not easy
      // because it means auditing the code.

      proxyTargetToPointerMap$LWS.set(originalTarget$LWS, proxyPointer$LWS);
      return proxyPointer$LWS;
    }

    const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? unforgeableGlobalThisKeys$LWS => {
      if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
        return;
      }

      installedPropertyDescriptorMethodWrappersFlag$LWS = true; // We wrap property descriptor methods to activate lazy
      // descriptors and/or workaround browser bugs. The following
      // methods are wrapped:
      //   Object.getOwnPropertyDescriptors()
      //   Object.getOwnPropertyDescriptor()
      //   Reflect.defineProperty()
      //   Reflect.getOwnPropertyDescriptor()
      //   Object.prototype.__defineGetter__()
      //   Object.prototype.__defineSetter__()
      //   Object.prototype.__lookupGetter__()
      //   Object.prototype.__lookupSetter__()
      //
      // Chromium based browsers have a bug that nulls the result
      // of `window` getters in detached iframes when the property
      // descriptor of `window.window` is retrieved.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
      //
      // Methods may be poisoned when they interact with the `window`
      // object and retrieve property descriptors, like 'window',
      // that contain the `window` object itself. The following
      // built-in methods are susceptible to this issue:
      //     console.log(window);
      //     Object.getOwnPropertyDescriptors(window);
      //     Object.getOwnPropertyDescriptor(window, 'window');
      //     Reflect.getOwnPropertyDescriptor(window, 'window');
      //     window.__lookupGetter__('window');
      //     window.__lookupSetter__('window');
      //
      // We side step issues with `console` by mapping it to the
      // primary realm's `console`. Since we're already wrapping
      // property descriptor methods to activate lazy descriptors
      // we use the wrapper to workaround the `window` getter
      // nulling bug.

      const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0; // Lazily populated by `getUnforgeableGlobalThisGetter()`;

      const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
        __proto__: null
      } : undefined;
      const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? {
        configurable: false,
        enumerable: ReflectApply$LWS(ObjectProtoPropertyIsEnumerable$LWS, __target$LWS, [__key$LWS]),
        get: getUnforgeableGlobalThisGetter$LWS(__key$LWS),
        set: undefined
      } : ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS) : undefined;
      const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? __key$LWS => {
        let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[__key$LWS];

        if (globalThisGetter$LWS === undefined) {
          // Wrap `unboundGlobalThisGetter` in bound function
          // to obscure the getter source as "[native code]".
          globalThisGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS, unboundGlobalThisGetter$LWS, []); // Preserve identity continuity of getters.

          keyToGlobalThisGetterRegistry$LWS[__key$LWS] = globalThisGetter$LWS;
        }

        return globalThisGetter$LWS;
      } : undefined;
      const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(__key$LWS) : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, __target$LWS, [__key$LWS]) : undefined;
      const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, __target$LWS, [__key$LWS]) : undefined;
      const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : undefined;

      const wrapDefineAccessOrProperty$LWS = originalFunc$LWS => {
        const {
          length: originalFuncLength$LWS
        } = originalFunc$LWS; // `__defineGetter__()` and `__defineSetter__()` have
        // function lengths of 2 while `Reflect.defineProperty()`
        // has a function length of 3.

        const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
        return new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
            if (_args$LWS.length >= originalFuncLength$LWS) {
              const __target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : _args$LWS[0];

              if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
                const __key$LWS = useThisArgAsTarget$LWS ? _args$LWS[0] : _args$LWS[1];
                const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

                if (state$LWS != null && state$LWS[__key$LWS]) {
                  // Activate the descriptor by triggering
                  // its getter.
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  __target$LWS[__key$LWS];
                }
              }
            }

            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }

        });
      };

      const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          if (_args$LWS.length && (typeof thisArg$LWS === 'object' && thisArg$LWS !== null || typeof thisArg$LWS === 'function')) {
            const {
              0: __key$LWS
            } = _args$LWS;
            const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);

            if (state$LWS != null && state$LWS[__key$LWS]) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              thisArg$LWS[__key$LWS];
            }

            if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
              return lookupFixedAccessor$LWS(thisArg$LWS, __key$LWS);
            }
          }

          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
        }

      });

      const wrapGetOwnPropertyDescriptor$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          if (_args$LWS.length > 1) {
            const {
              0: __target$LWS,
              1: __key$LWS
            } = _args$LWS;

            if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
              const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

              if (state$LWS != null && state$LWS[__key$LWS]) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                __target$LWS[__key$LWS];
              }

              if (shouldFixChromeBug$LWS && __target$LWS === globalThisRef$LWS) {
                return getFixedDescriptor$LWS(__target$LWS, __key$LWS);
              }
            }
          }

          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
        }

      });

      const wrapGetOwnPropertyDescriptors$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          const __target$LWS = _args$LWS.length ? _args$LWS[0] : undefined;

          if (!(typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function')) {
            // Defer to native method to throw exception.
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }

          const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
          const isFixingChromeBug$LWS = __target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
          const unsafeDescMap$LWS = isFixingChromeBug$LWS ? // Create an empty property descriptor map
          // to populate with curated descriptors.
          {} : // Since this is not a global object it is
          // safe to use the native method.
          ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);

          if (!isFixingChromeBug$LWS && state$LWS === undefined) {
            // Exit early if the target is not a global
            // object and there are no lazy descriptors.
            return unsafeDescMap$LWS;
          }

          const ownKeys$LWS = ReflectOwnKeys$LWS(isFixingChromeBug$LWS ? __target$LWS : unsafeDescMap$LWS);

          for (let _i$LWS = 0, {
            length: _length$LWS
          } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
            const ownKey$LWS = ownKeys$LWS[_i$LWS];
            const isLazyProp$LWS = !!(state$LWS != null && state$LWS[ownKey$LWS]);

            if (isLazyProp$LWS) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              __target$LWS[ownKey$LWS];
            }

            if (isLazyProp$LWS || isFixingChromeBug$LWS) {
              const _unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(__target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, ownKey$LWS); // Update the descriptor map entry.

              if (_unsafeDesc$LWS) {
                unsafeDescMap$LWS[ownKey$LWS] = _unsafeDesc$LWS;
              } else if (!isFixingChromeBug$LWS) {
                ReflectDeleteProperty$LWS(unsafeDescMap$LWS, ownKey$LWS);
              }
            }
          }

          return unsafeDescMap$LWS;
        }

      });

      try {
        ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS); // eslint-disable-next-line no-empty
      } catch (_unused19$LWS) {}

      try {
        ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS); // eslint-disable-next-line no-empty
      } catch (_unused20$LWS) {}

      try {
        ObjectCtor$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS); // eslint-disable-next-line no-empty
      } catch (_unused21$LWS) {}

      try {
        ObjectCtor$LWS.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS); // eslint-disable-next-line no-empty
      } catch (_unused22$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused23$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused24$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS, lookupFixedGetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused25$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS, lookupFixedSetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused26$LWS) {}
    } : noop$LWS;

    function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('lookupForeignDescriptor');
      }

      let protoPointerOrNull$LWS;
      let _safeDesc$LWS;

      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
          _safeDesc$LWS = {
            __proto__: null,
            foreign: true
          };

          if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.configurable = configurable$LWS;
          }

          if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.enumerable = enumerable$LWS;
          }

          if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.writable = writable$LWS;
          }

          if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof getterPointerOrPrimitive$LWS === 'function') {
              getterPointerOrPrimitive$LWS();
              _safeDesc$LWS.get = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.get = undefined;
            }
          }

          if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof setterPointerOrPrimitive$LWS === 'function') {
              setterPointerOrPrimitive$LWS();
              _safeDesc$LWS.set = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.set = undefined;
            }
          }

          if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof valuePointerOrPrimitive$LWS === 'function') {
              valuePointerOrPrimitive$LWS();
              _safeDesc$LWS.value = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
            }
          }

          if (configurable$LWS === false) {
            // Update the descriptor to non-configurable on
            // the shadow target.
            ReflectDefineProperty$LWS(shadowTarget$LWS, __key$LWS, _safeDesc$LWS);
          }
        });
      } catch (error) {
        var _selectedTarget10$LWS;

        const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      if (_safeDesc$LWS === undefined) {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;

        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }

        while (currentObject$LWS) {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(currentObject$LWS, __key$LWS);

          if (_safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
            break;
          }

          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }

        if (_safeDesc$LWS) {
          var _ref3$LWS;

          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: localValue$LWS
          } = _safeDesc$LWS;
          const possibleProxy$LWS = (_ref3$LWS = _getter$LWS != null ? _getter$LWS : _setter$LWS) != null ? _ref3$LWS : localValue$LWS;
          _safeDesc$LWS.foreign = (typeof possibleProxy$LWS === 'object' && possibleProxy$LWS !== null || typeof possibleProxy$LWS === 'function') && proxyTargetToPointerMap$LWS.get(possibleProxy$LWS) !== undefined;
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _safeDesc$LWS;
    }

    function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
      const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS); // Following the specification steps for
      // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).
      // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor

      if (_safeDesc$LWS) {
        if ('get' in _safeDesc$LWS || 'set' in _safeDesc$LWS) {
          const {
            set: _setter$LWS
          } = _safeDesc$LWS;

          if (_setter$LWS) {
            if (_safeDesc$LWS.foreign) {
              foreignCallableApply$LWS(getTransferablePointer$LWS(_setter$LWS), // Inline getTransferableValue().
              typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof __receiver$LWS === 'undefined' ? undefined : __receiver$LWS, // Inline getTransferableValue().
              typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof __value$LWS === 'undefined' ? undefined : __value$LWS);
            } else {
              // Even though the setter function exists, we can't
              // use `ReflectSet()` because there might be a
              // distortion for that setter function, in which
              // case we must resolve the local setter and call
              // it instead.
              ReflectApply$LWS(_setter$LWS, __receiver$LWS, [__value$LWS]);
            } // If there is a setter, it either throw or we can assume
            // the value was set.


            return true;
          }

          return false;
        }

        if (_safeDesc$LWS.writable === false) {
          return false;
        }
      } // Exit early if receiver is not object like.


      if (!(typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function')) {
        return false;
      }

      const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__receiver$LWS, __key$LWS);

      if (safeReceiverDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeReceiverDesc$LWS, null); // Exit early for accessor descriptors or non-writable data
        // descriptors.

        if ('get' in safeReceiverDesc$LWS || 'set' in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
          return false;
        } // Setting the descriptor with only a value entry should not
        // affect existing descriptor traits.


        ReflectDefineProperty$LWS(__receiver$LWS, __key$LWS, {
          __proto__: null,
          value: __value$LWS
        });
        return true;
      } // `ReflectDefineProperty()` and `ReflectSet()` both are expected
      // to return `false` when attempting to add a new property if the
      // receiver is not extensible.


      return ReflectDefineProperty$LWS(__receiver$LWS, __key$LWS, {
        __proto__: null,
        configurable: true,
        enumerable: true,
        value: __value$LWS,
        writable: true
      });
    }

    function pushErrorAcrossBoundary$LWS(error) {
      if (LOCKER_DEBUGGABLE_FLAG$LWS) {
        checkDebugMode$LWS();
      } // Inline getTransferableValue().


      if (typeof error === 'object' && error !== null || typeof error === 'function') {
        const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
        foreignErrorPointer$LWS();
      }

      return error;
    }

    function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
      const {
        proxy: _proxy$LWS
      } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      proxyTargetToPointerMap$LWS.set(_proxy$LWS, foreignTargetPointer$LWS);
      return createPointer$LWS(_proxy$LWS);
    }

    const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, state$LWS) => {
      localProxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
      foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS), getTransferablePointer$LWS(state$LWS));
    } : noop$LWS;

    class BoundaryProxyHandler$LWS {
      constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        let shadowTarget$LWS;
        const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1
        /* TargetTraits.IsArray */
        ;
        const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4
        /* TargetTraits.IsFunction */
        ;

        if (isForeignTargetFunction$LWS) {
          // This shadow target is never invoked. It's needed to avoid
          // proxy trap invariants. Because it's not invoked the code
          // does not need to be instrumented for code coverage.
          //
          // istanbul ignore next
          shadowTarget$LWS = foreignTargetTraits$LWS & 8
          /* TargetTraits.IsArrowFunction */
          ? () => {} : function () {};
        } else if (isForeignTargetArray$LWS) {
          shadowTarget$LWS = [];
        } else {
          shadowTarget$LWS = {};
        }

        const {
          proxy: _proxy$LWS,
          revoke: revoke$LWS
        } = ProxyRevocable$LWS(shadowTarget$LWS, this);
        this.foreignTargetPointer = foreignTargetPointer$LWS;
        this.foreignTargetTraits = foreignTargetTraits$LWS;
        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS; // Define in the BoundaryProxyHandler constructor so it is bound
        // to the BoundaryProxyHandler instance.

        this.nonConfigurableDescriptorCallback = (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          // Update the descriptor to non-configurable on the shadow
          // target.
          ReflectDefineProperty$LWS(this.shadowTarget, __key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
        };

        this.proxy = _proxy$LWS;
        this.revoke = revoke$LWS;
        this.serializedValue = undefined;
        this.shadowTarget = shadowTarget$LWS;
        this.staticToStringTag = 'Object'; // Define traps.

        if (isForeignTargetFunction$LWS) {
          var _arityToApplyTrapName$LWS, _arityToConstructTrap$LWS;

          this.apply = this[(_arityToApplyTrapName$LWS = arityToApplyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _arityToApplyTrapName$LWS : arityToApplyTrapNameRegistry$LWS.n];
          this.construct = this[(_arityToConstructTrap$LWS = arityToConstructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _arityToConstructTrap$LWS : arityToConstructTrapNameRegistry$LWS.n];
        }

        this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
        this.get = foreignTargetTraits$LWS & 32
        /* TargetTraits.IsTypedArray */
        ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
        this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
        this.set = BoundaryProxyHandler$LWS.defaultSetTrap;

        if (foreignTargetTraits$LWS & 64
        /* TargetTraits.Revoked */
        ) {
          // Future optimization: Hoping proxies with frozen handlers
          // can be faster.
          ObjectFreeze$LWS(this);
          this.revoke();
        } else if (IS_IN_SHADOW_REALM$LWS) {
          if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2
          /* TargetTraits.IsArrayBufferView */
          ) {
            this.makeProxyLive();
          }
        } else {
          if (foreignTargetTraits$LWS & 16
          /* TargetTraits.IsObject */
          ) {
            // Lazily define serializedValue.
            let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
            const {
              serializedValue: serializedValue$LWS
            } = this;

            if (MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS === undefined) {
              // A minification safe way to get the 'serializedValue'
              // property name.
              ({
                0: MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS
              } = ObjectKeys$LWS({
                serializedValue: serializedValue$LWS
              }));
            }

            ReflectApply$LWS(ObjectProtoDefineGetter$LWS, this, [MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS, () => {
              if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
                cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
              }

              return cachedSerializedValue$LWS;
            }]);
          } // Future optimization: Hoping proxies with frozen handlers
          // can be faster. If local mutations are not trapped, then
          // freezing the handler is ok because it is not expecting to
          // change in the future.


          ObjectFreeze$LWS(this);
        }
      } // Internal shadow realm side utilities:


      makeProxyLive() {
        // Replace pending traps with live traps that can work with the
        // target without taking snapshots.
        this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
        this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
        this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap; // Future optimization: Hoping proxies with frozen handlers can
        // be faster.

        ObjectFreeze$LWS(this);
      }

      makeProxyStatic() {
        // Reset all traps except apply and construct for static proxies
        // since the proxy target is the shadow target and all operations
        // are going to be applied to it rather than the real target.
        this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
        this.get = BoundaryProxyHandler$LWS.staticGetTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
        this.has = BoundaryProxyHandler$LWS.staticHasTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
        this.set = BoundaryProxyHandler$LWS.staticSetTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          shadowTarget: shadowTarget$LWS
        } = this; // We don't wrap `foreignCallableGetTargetIntegrityTraits()`
        // in a try-catch because it cannot throw.

        const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS);

        if (targetIntegrityTraits$LWS & 8
        /* TargetIntegrityTraits.Revoked */
        ) {
          // Future optimization: Hoping proxies with frozen
          // handlers can be faster.
          ObjectFreeze$LWS(this); // the target is a revoked proxy, in which case we revoke
          // this proxy as well.

          this.revoke();
          return;
        } // A proxy can revoke itself when traps are triggered and break
        // the membrane, therefore we need protection.


        try {
          copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
        } catch (_unused27$LWS) {
          // We don't wrap `foreignCallableIsTargetRevoked()` in a
          // try-catch because it cannot throw.
          if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS)) {
            // Future optimization: Hoping proxies with frozen
            // handlers can be faster.
            ObjectFreeze$LWS(this);
            this.revoke();
            return;
          }
        }

        if (foreignTargetTraits$LWS & 16
        /* TargetTraits.IsObject */
        && !(SymbolToStringTag$LWS in shadowTarget$LWS)) {
          let toStringTag$LWS = 'Object';

          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS); // eslint-disable-next-line no-empty
          } catch (_unused28$LWS) {}

          this.staticToStringTag = toStringTag$LWS;
        } // Preserve the semantics of the target.


        if (targetIntegrityTraits$LWS & 4
        /* TargetIntegrityTraits.IsFrozen */
        ) {
          ObjectFreeze$LWS(shadowTarget$LWS);
        } else {
          if (targetIntegrityTraits$LWS & 2
          /* TargetIntegrityTraits.IsSealed */
          ) {
            ObjectSeal$LWS(shadowTarget$LWS);
          } else if (targetIntegrityTraits$LWS & 1
          /* TargetIntegrityTraits.IsNotExtensible */
          ) {
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }

          if (LOCKER_UNMINIFIED_FLAG$LWS) {
            // We don't wrap `foreignCallableDebugInfo()` in a try-catch
            // because it cannot throw.
            foreignCallableDebugInfo$LWS('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer$LWS);
          }
        } // Future optimization: Hoping proxies with frozen handlers can
        // be faster.


        ObjectFreeze$LWS(this);
      } // Passthru traps:


      static passthruDefinePropertyTrap(_shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
        lastProxyTrapCalled$LWS = 4
        /* ProxyHandlerTraps.DefineProperty */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.defineProperty');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
        } = this;
        const safePartialDesc$LWS = _unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS(safePartialDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = safePartialDesc$LWS;
        const valuePointer$LWS = 'value' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const getterPointer$LWS = 'get' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const setterPointer$LWS = 'set' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, __key$LWS, 'configurable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, nonConfigurableDescriptorCallback$LWS);
        } catch (error) {
          var _selectedTarget11$LWS;

          const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruDeletePropertyTrap(_shadowTarget$LWS, __key$LWS) {
        lastProxyTrapCalled$LWS = 8
        /* ProxyHandlerTraps.DeleteProperty */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.deleteProperty');
        }

        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, __key$LWS);
        } catch (error) {
          var _selectedTarget12$LWS;

          const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 64
        /* ProxyHandlerTraps.GetPrototypeOf */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.getPrototypeOf');
        }

        let protoPointerOrNull$LWS;

        try {
          protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
        } catch (error) {
          var _selectedTarget13$LWS;

          const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _proto$LWS;

        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          _proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _proto$LWS = null;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _proto$LWS;
      }

      static passthruIsExtensibleTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 256
        /* ProxyHandlerTraps.IsExtensible */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.isExtensible');
        }

        const {
          shadowTarget: shadowTarget$LWS
        } = this;
        let _result$LWS = false; // Check if already locked.

        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;

          try {
            _result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget14$LWS;

            const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          }

          if (!_result$LWS) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruOwnKeysTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 512
        /* ProxyHandlerTraps.OwnKeys */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.ownKeys');
        }

        let ownKeys$LWS;

        try {
          foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (..._args$LWS) => {
            ownKeys$LWS = _args$LWS;
          });
        } catch (error) {
          var _selectedTarget15$LWS;

          const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return ownKeys$LWS || [];
      }

      static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, __key$LWS) {
        lastProxyTrapCalled$LWS = 32
        /* ProxyHandlerTraps.GetOwnPropertyDescriptor */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.getOwnPropertyDescriptor');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let _safeDesc$LWS;

        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);

            if (_safeDesc$LWS.configurable === false) {
              // Update the descriptor to non-configurable on
              // the shadow target.
              ReflectDefineProperty$LWS(shadowTarget$LWS, __key$LWS, _safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget16$LWS;

          const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _safeDesc$LWS;
      }

      static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 1024
        /* ProxyHandlerTraps.PreventExtensions */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.preventExtensions');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let _result$LWS = true;

        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          let resultEnum$LWS = 0
          /* PreventExtensionsResult.None */
          ;

          try {
            resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget17$LWS;

            const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          } // If the target is a proxy it might reject the
          // preventExtension call, in which case we should not
          // attempt to lock down the shadow target.


          if (!(resultEnum$LWS & 1
          /* PreventExtensionsResult.Extensible */
          )) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }

          _result$LWS = !(resultEnum$LWS & 2
          /* PreventExtensionsResult.False */
          );
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruSetPrototypeOfTrap(_shadowTarget$LWS, _proto$LWS) {
        lastProxyTrapCalled$LWS = 4096
        /* ProxyHandlerTraps.SetPrototypeOf */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.setPrototypeOf');
        }

        const transferableProto$LWS = _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableSetPrototypeOf$LWS(this.foreignTargetPointer, transferableProto$LWS);
        } catch (error) {
          var _selectedTarget18$LWS;

          const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruSetTrap(_shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048
        /* ProxyHandlerTraps.Set */
        ;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          proxy: _proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this; // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot

        if (typeof __value$LWS === 'undefined') {
          __value$LWS = undefined;
        }

        if (typeof __receiver$LWS === 'undefined') {
          __receiver$LWS = _proxy$LWS;
        }

        const isFastPath$LWS = _proxy$LWS === __receiver$LWS;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(isFastPath$LWS ? 'Reflect.set' : 'passthruForeignTraversedSet');
        }

        let _result$LWS = false;

        try {
          _result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, __key$LWS, // Inline getTransferableValue().
          typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS, LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
        } catch (error) {
          var _selectedTarget19$LWS;

          const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

    } // Logic implementation of all traps.
    // Hybrid traps:
    // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):


    BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridGetTrap');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: _proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);
      let _result$LWS;

      if (_safeDesc$LWS) {
        const {
          get: _getter$LWS,
          value: localValue$LWS
        } = _safeDesc$LWS;

        if (_getter$LWS) {
          if (_safeDesc$LWS.foreign) {
            const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
            const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
            typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
            let pointerOrPrimitive$LWS;

            try {
              pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
            } catch (error) {
              var _selectedTarget20$LWS;

              const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
              selectedTarget$LWS = undefined;

              if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                activity$LWS.error(errorToThrow$LWS);
              }

              throw errorToThrow$LWS;
            }

            if (typeof pointerOrPrimitive$LWS === 'function') {
              pointerOrPrimitive$LWS();
              _result$LWS = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _result$LWS = pointerOrPrimitive$LWS;
            }
          } else {
            // Even though the getter function exists,
            // we can't use `ReflectGet()` because there
            // might be a distortion for that getter function,
            // in which case we must resolve the local getter
            // and call it instead.
            _result$LWS = ReflectApply$LWS(_getter$LWS, __receiver$LWS, []);
          }
        } else {
          _result$LWS = localValue$LWS;
        }
      } else {
        const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
        typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
        let pointerOrPrimitive$LWS;

        try {
          pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
        } catch (error) {
          var _selectedTarget21$LWS;

          const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16
        /* TargetTraits.IsObject */
        ) {
          let toStringTag$LWS;

          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget22$LWS;

            const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          } // The default language toStringTag is "Object". If we
          // receive "Object" we return `undefined` to let the
          // language resolve it naturally without projecting a
          // value.


          if (toStringTag$LWS !== 'Object') {
            _result$LWS = toStringTag$LWS;
          }
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridGetTrapForTypedArray');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
        proxy: _proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      const _possibleIndex$LWS = typeof __key$LWS === 'string' ? +__key$LWS : -1;
      let _result$LWS;

      if (_possibleIndex$LWS > -1 && _possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS(_possibleIndex$LWS)) {
        try {
          _result$LWS = foreignCallableGetTypedArrayIndexedValue$LWS(foreignTargetPointer$LWS, __key$LWS);
        } catch (error) {
          var _selectedTarget23$LWS;

          const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }
      } else {
        const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);

        if (_safeDesc$LWS) {
          const {
            get: _getter$LWS,
            value: localValue$LWS
          } = _safeDesc$LWS;

          if (_getter$LWS) {
            if (_safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
              const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
              typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
              let pointerOrPrimitive$LWS;

              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget24$LWS;

                const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
                selectedTarget$LWS = undefined;

                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                  activity$LWS.error(errorToThrow$LWS);
                }

                throw errorToThrow$LWS;
              }

              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                _result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                _result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              _result$LWS = ReflectApply$LWS(_getter$LWS, __receiver$LWS, []);
            }
          } else {
            _result$LWS = localValue$LWS;
          }
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridHasTrap');
      }

      let trueOrProtoPointerOrNull$LWS;

      try {
        trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, __key$LWS);
      } catch (error) {
        var _selectedTarget25$LWS;

        const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _result$LWS = false;

      if (trueOrProtoPointerOrNull$LWS === true) {
        _result$LWS = true;
      } else {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;

        if (typeof trueOrProtoPointerOrNull$LWS === 'function') {
          trueOrProtoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }

        while (currentObject$LWS) {
          if (ObjectHasOwn$LWS(currentObject$LWS, __key$LWS)) {
            _result$LWS = true;
            break;
          }

          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.passthruGetTrap = !IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      // Only allow accessing near-membrane symbol values if the
      // BoundaryProxyHandler.has trap has been called immediately
      // before and the symbol does not exist.
      nearMembraneSymbolFlag$LWS && (nearMembraneSymbolFlag$LWS = lastProxyTrapCalled$LWS === 128
      /* ProxyHandlerTraps.Has */
      );
      lastProxyTrapCalled$LWS = 16
      /* ProxyHandlerTraps.Get */
      ;

      if (nearMembraneSymbolFlag$LWS) {
        // Exit without performing a [[Get]] for near-membrane
        // symbols because we know when the nearMembraneSymbolFlag
        // is on that there is no shadowed symbol value.
        if (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS) {
          return true;
        }

        if (__key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS) {
          return this.serializedValue;
        }
      }

      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('Reflect.get');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: _proxy$LWS
      } = this;

      if (typeof __receiver$LWS === 'undefined') {
        __receiver$LWS = _proxy$LWS;
      }

      const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS : // Inline getTransferableValue().
      typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
      let pointerOrPrimitive$LWS;

      try {
        pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
      } catch (error) {
        var _selectedTarget26$LWS;

        const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _result$LWS;

      if (typeof pointerOrPrimitive$LWS === 'function') {
        pointerOrPrimitive$LWS();
        _result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _result$LWS = pointerOrPrimitive$LWS;
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.passthruHasTrap = !IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS) {
      lastProxyTrapCalled$LWS = 128
      /* ProxyHandlerTraps.Has */
      ;
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('Reflect.has');
      }

      let _result$LWS;

      try {
        _result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, __key$LWS);
      } catch (error) {
        var _selectedTarget27$LWS;

        const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      } // The near-membrane symbol flag is on if the symbol does not
      // exist on the object or its [[Prototype]].


      nearMembraneSymbolFlag$LWS = !_result$LWS && (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS);

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : alwaysFalse$LWS; // Pending traps:

    BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.defineProperty(shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.deleteProperty(shadowTarget$LWS, __key$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.preventExtensions(shadowTarget$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, _proto$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.setPrototypeOf(shadowTarget$LWS, _proto$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.set(shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
    } : alwaysFalse$LWS; //  Static traps:

    BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS : noop$LWS;
    BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS : () => null;
    BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      const {
        foreignTargetTraits: foreignTargetTraits$LWS,
        staticToStringTag: staticToStringTag$LWS
      } = this;
      const _result$LWS = ReflectGet$LWS(shadowTarget$LWS, __key$LWS, __receiver$LWS);

      if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16
      /* TargetTraits.IsObject */
      && // The default language toStringTag is "Object". If we
      // receive "Object" we return `undefined` to let the
      // language resolve it naturally without projecting a
      // value.
      staticToStringTag$LWS !== 'Object' && !(__key$LWS in shadowTarget$LWS)) {
        return staticToStringTag$LWS;
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS : () => [];
    BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS : alwaysFalse$LWS; // Default traps:
    // Pending traps are needed for the shadow realm side of the membrane
    // to avoid leaking mutation operations on the primary realm side.

    BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
    BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
    BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
    BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
    BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
    BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
    BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
    BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
    BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
    BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
    BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap; // Export callable hooks to a foreign realm.

    foreignCallableHooksCallback$LWS( // globalThisPointer
    // When crossing, should be mapped to the foreign globalThis
    createPointer$LWS(globalThisRef$LWS), // getSelectedTarget
    !IS_IN_SHADOW_REALM$LWS ? () => {
      const _result$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      return _result$LWS;
    } : noop$LWS, // getTransferableValue
    __value$LWS => {
      if (typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function') {
        return getTransferablePointer$LWS(__value$LWS);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      return typeof __value$LWS === 'undefined' ? undefined : __value$LWS;
    }, // callableGetPropertyValuePointer: this callable function allows
    // the foreign realm to access a linkable pointer for a property value.
    // In order to do that, the foreign side must provide a pointer and
    // a key access the value in order to produce a pointer
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const __value$LWS = __target$LWS == null ? void 0 : __target$LWS[__key$LWS]; // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot

      return createPointer$LWS(typeof __value$LWS === 'undefined' ? undefined : __value$LWS);
    }, // callableEvaluate
    IS_IN_SHADOW_REALM$LWS ? _sourceText$LWS => {
      let _result$LWS;

      try {
        _result$LWS = localEval$LWS(_sourceText$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : _result$LWS;
    } : noop$LWS, // callableLinkPointers: this callable function allows the foreign
    // realm to define a linkage between two values across the membrane.
    (targetPointer$LWS, newPointer$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
        proxyTargetToPointerMap$LWS.set(__target$LWS, newPointer$LWS);
      }
    }, // callablePushErrorTarget
    LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
      const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);

      const pointerWrapper$LWS = () => {
        checkDebugMode$LWS();
        return pointer$LWS();
      };

      return pointerWrapper$LWS;
    } : pushTarget$LWS, // callablePushTarget: This function can be used by a foreign realm
    // to install a proxy into this realm that correspond to an object
    // from the foreign realm. It returns a Pointer that can be used by
    // the foreign realm to pass back a reference to this realm when
    // passing arguments or returning from a foreign callable invocation.
    // This function is extremely important to understand the mechanics
    // of this membrane.
    pushTarget$LWS, // callableApply
    (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ..._args$LWS) => {
      targetPointer$LWS();
      const func$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let thisArg$LWS;

      if (typeof thisArgPointerOrUndefined$LWS === 'function') {
        thisArgPointerOrUndefined$LWS();
        thisArg$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _args$LWS[_i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, _args$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableConstruct
    (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ..._args$LWS) => {
      targetPointer$LWS();
      const constructor$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let newTarget$LWS;

      if (typeof newTargetPointerOrUndefined$LWS === 'function') {
        newTargetPointerOrUndefined$LWS();
        newTarget$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _args$LWS[_i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectConstruct$LWS(constructor$LWS, _args$LWS, newTarget$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableDefineProperty
    (targetPointer$LWS, __key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
      let _result$LWS = false;

      try {
        _result$LWS = ReflectDefineProperty$LWS(__target$LWS, __key$LWS, safePartialDesc$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_result$LWS && configurable$LWS === false) {
        let _safeDesc$LWS;

        try {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }

        if (_safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);

          if (_safeDesc$LWS.configurable === false) {
            const {
              get: _getter$LWS,
              set: _setter$LWS,
              value: __value$LWS
            } = _safeDesc$LWS;
            foreignCallableNonConfigurableDescriptorCallback$LWS(__key$LWS, false, // configurable
            'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
          }
        }
      }

      return _result$LWS;
    }, // callableDeleteProperty
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return ReflectDeleteProperty$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableGet
    (targetPointer$LWS, targetTraits$LWS, __key$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let __receiver$LWS;

      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        __receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? __target$LWS : receiverPointerOrPrimitive$LWS;
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectGet$LWS(__target$LWS, __key$LWS, __receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      if (typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function') {
        return getTransferablePointer$LWS(_result$LWS);
      }

      if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && targetTraits$LWS & 16
      /* TargetTraits.IsObject */
      ) {
        try {
          if (!(__key$LWS in __target$LWS)) {
            // Section 19.1.3.6 Object.prototype.toString()
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []); // The default language toStringTag is "Object". If
            // we receive "[object Object]" we return `undefined`
            // to let the language resolve it naturally without
            // projecting a value.

            if (brand$LWS !== '[object Object]') {
              _result$LWS = ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
            }
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      return typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableGetOwnPropertyDescriptor
    (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _safeDesc$LWS;

      try {
        _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(__key$LWS, 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
      }
    }, // callableGetPrototypeOf
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableHas
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return __key$LWS in __target$LWS;
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableIsExtensible
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return ReflectIsExtensible$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableOwnKeys
    (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let ownKeys$LWS;

      try {
        ownKeys$LWS = ReflectOwnKeys$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      ReflectApply$LWS(foreignCallableKeysCallback$LWS, undefined, ownKeys$LWS);
    }, // callablePreventExtensions
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _result$LWS = 2
      /* PreventExtensionsResult.False */
      ;

      try {
        if (ReflectPreventExtensions$LWS(__target$LWS)) {
          _result$LWS = 4
          /* PreventExtensionsResult.True */
          ;
        } else if (ReflectIsExtensible$LWS(__target$LWS)) {
          _result$LWS |= 1
          /* PreventExtensionsResult.Extensible */
          ;
        }
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      return _result$LWS;
    }, // callableSet
    (targetPointer$LWS, __key$LWS, valuePointerOrPrimitive$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let __value$LWS;

      if (typeof valuePointerOrPrimitive$LWS === 'function') {
        valuePointerOrPrimitive$LWS();
        __value$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __value$LWS = valuePointerOrPrimitive$LWS;
      }

      let __receiver$LWS;

      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        __receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? __target$LWS : receiverPointerOrPrimitive$LWS;
      }

      try {
        return ReflectSet$LWS(__target$LWS, __key$LWS, __value$LWS, __receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableSetPrototypeOf
    (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        _proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _proto$LWS = null;
      }

      try {
        return ReflectSetPrototypeOf$LWS(__target$LWS, _proto$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableDebugInfo
    LOCKER_DEBUGGABLE_FLAG$LWS ? (..._args$LWS) => {
      if (checkDebugMode$LWS()) {
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            _args$LWS[_i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }

        try {
          ReflectApply$LWS(consoleInfo$LWS, consoleObject$LWS, _args$LWS); // eslint-disable-next-line no-empty
        } catch (_unused29$LWS) {}
      }
    } : noop$LWS, // callableDefineProperties
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
        // We don't use `ObjectDefineProperties()` here because it
        // will throw an exception if it fails to define one of its
        // properties.
        ReflectDefineProperty$LWS(__target$LWS, descriptorTuples$LWS[_i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], // configurable
        descriptorTuples$LWS[_i$LWS + 2], // enumerable
        descriptorTuples$LWS[_i$LWS + 3], // writable
        descriptorTuples$LWS[_i$LWS + 4], // valuePointer
        descriptorTuples$LWS[_i$LWS + 5], // getterPointer
        descriptorTuples$LWS[_i$LWS + 6] // setterPointer
        ));
      }
    } : noop$LWS, // callableGetLazyPropertyDescriptorStateByTarget
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // We don't wrap the weak map `get()` call in a try-catch
      // because we know `target` is an object.

      const state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(__target$LWS);
      return state$LWS ? getTransferablePointer$LWS(state$LWS) : state$LWS;
    } : noop$LWS, // callableGetTargetIntegrityTraits
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // A target may be a proxy that is revoked or throws in its
      // "isExtensible" trap.

      try {
        if (!ReflectIsExtensible$LWS(__target$LWS)) {
          if (ObjectIsFrozen$LWS(__target$LWS)) {
            return 4
            /* TargetIntegrityTraits.IsFrozen */
            & 2
            /* TargetIntegrityTraits.IsSealed */
            & 1
            /* TargetIntegrityTraits.IsNotExtensible */
            ;
          }

          if (ObjectIsSealed$LWS(__target$LWS)) {
            return 2
            /* TargetIntegrityTraits.IsSealed */
            & 1
            /* TargetIntegrityTraits.IsNotExtensible */
            ;
          }

          return 1
          /* TargetIntegrityTraits.IsNotExtensible */
          ;
        }
      } catch (_unused30$LWS) {
        try {
          isArrayOrThrowForRevoked$LWS(__target$LWS);
        } catch (_unused31$LWS) {
          return 8
          /* TargetIntegrityTraits.Revoked */
          ;
        }
      }

      return 0
      /* TargetIntegrityTraits.None */
      ;
    } : () => 0
    /* TargetIntegrityTraits.None */
    , // callableGetToStringTagOfTarget
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        // Section 19.1.3.6 Object.prototype.toString()
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []);
        return brand$LWS === '[object Object]' ? 'Object' : ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableGetTypedArrayIndexedValue
    !IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, _index$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return __target$LWS[_index$LWS];
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    } : noop$LWS, // callableInstallErrorPrepareStackTrace
    installErrorPrepareStackTrace$LWS, // callableInstallLazyPropertyDescriptors
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const sliceIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS]);
      let ownKeys$LWS;
      let unforgeableGlobalThisKeys$LWS;

      if (sliceIndex$LWS === -1) {
        ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      } else {
        ownKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
        unforgeableGlobalThisKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
      }

      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

      if (state$LWS === undefined) {
        state$LWS = {
          __proto__: null
        };
        setLazyPropertyDescriptorStateByTarget$LWS(__target$LWS, state$LWS);
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        state$LWS[ownKey$LWS] = true;
        ReflectDefineProperty$LWS(__target$LWS, ownKey$LWS, // The role of this descriptor is to serve as a
        // bouncer. When either a getter or a setter is
        // invoked the descriptor will be replaced with
        // the descriptor from the foreign side and the
        // get/set operation will carry on from there.
        {
          __proto__: null,
          // We DO explicitly set configurability in the
          // off chance that the property doesn't exist.
          configurable: true,

          // We DON'T explicitly set enumerability to
          // defer to the enumerability of the existing
          // property. In the off chance the property
          // doesn't exist the property will be defined
          // as non-enumerable.
          get() {
            activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, state$LWS);
            return __target$LWS[ownKey$LWS];
          },

          set(__value$LWS) {
            activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, state$LWS);
            ReflectSet$LWS(__target$LWS, ownKey$LWS, __value$LWS);
          }

        });
      }

      installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
    } : noop$LWS, // callableIsTargetLive
    !IS_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return liveTargetCallback$LWS(__target$LWS, targetTraits$LWS); // eslint-disable-next-line no-empty
      } catch (_unused32$LWS) {}

      return false;
    } : alwaysFalse$LWS, // callableIsTargetRevoked
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        isArrayOrThrowForRevoked$LWS(__target$LWS);
        return false; //  eslint-disable-next-line no-empty
      } catch (_unused33$LWS) {}

      return true;
    } : alwaysFalse$LWS, // callableSerializeTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return SymbolToStringTag$LWS in __target$LWS ? serializeTargetByTrialAndError$LWS(__target$LWS) : // Fast path.
        serializeTargetByBrand$LWS(__target$LWS); // eslint-disable-next-line no-empty
      } catch (_unused34$LWS) {}

      return undefined;
    } : noop$LWS, // callableSetLazyPropertyDescriptorStateByTarget
    !IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      statePointer$LWS();
      const state$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // We don't wrap the weak map `set()` call in a try-catch
      // because we know `target` is an object.

      proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
    } : noop$LWS, // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors
    (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let unsafeDescMap$LWS;

      try {
        unsafeDescMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeDescMap$LWS);
      const {
        length: _length$LWS
      } = ownKeys$LWS;
      const descriptorTuples$LWS = new ArrayCtor$LWS(_length$LWS * 7);

      for (let _i$LWS = 0, _j$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        const _safeDesc$LWS = unsafeDescMap$LWS[ownKey$LWS];
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        descriptorTuples$LWS[_j$LWS] = ownKey$LWS;
        descriptorTuples$LWS[_j$LWS + 1] = 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 2] = 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 3] = 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 4] = 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 5] = 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 6] = 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }

      ReflectApply$LWS(foreignCallableDescriptorsCallback$LWS, undefined, descriptorTuples$LWS);
      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableBatchGetPrototypeOfWhenHasNoOwnProperty
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      try {
        if (ObjectHasOwn$LWS(__target$LWS, __key$LWS)) {
          return true;
        }

        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor
    (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _safeDesc$LWS;

      try {
        _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(__key$LWS, 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
        return undefined;
      }

      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    });
    let foreignCallablesHooked$LWS = false;
    return (...hooks$LWS) => {
      if (foreignCallablesHooked$LWS) {
        return;
      }

      foreignCallablesHooked$LWS = true;
      ({
        // 0: globalThisPointer,
        // 1: getSelectedTarget,
        // 2: getTransferableValue,
        // 3: callableGetPropertyValuePointer,
        // 4: callableEvaluate,
        // 5: callableLinkPointers,
        6: foreignCallablePushErrorTarget$LWS,
        7: foreignCallablePushTarget$LWS,
        8: foreignCallableApply$LWS,
        9: foreignCallableConstruct$LWS,
        10: foreignCallableDefineProperty$LWS,
        11: foreignCallableDeleteProperty$LWS,
        12: foreignCallableGet$LWS,
        13: foreignCallableGetOwnPropertyDescriptor$LWS,
        14: foreignCallableGetPrototypeOf$LWS,
        15: foreignCallableHas$LWS,
        16: foreignCallableIsExtensible$LWS,
        17: foreignCallableOwnKeys$LWS,
        18: foreignCallablePreventExtensions$LWS,
        19: foreignCallableSet$LWS,
        20: foreignCallableSetPrototypeOf$LWS,
        21: foreignCallableDebugInfo$LWS,
        // 22: callableDefineProperties,
        23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: foreignCallableGetTargetIntegrityTraits$LWS,
        25: foreignCallableGetToStringTagOfTarget$LWS,
        26: foreignCallableGetTypedArrayIndexedValue$LWS,
        27: foreignCallableInstallErrorPrepareStackTrace$LWS,
        // 28: callableInstallLazyPropertyDescriptors,
        29: foreignCallableIsTargetLive$LWS,
        30: foreignCallableIsTargetRevoked$LWS,
        31: foreignCallableSerializeTarget$LWS,
        32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        33: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        34: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = hooks$LWS);
      const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );

      if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === undefined) {
        // A minification safe way to get the 'apply' and 'construct'
        // trap property names.
        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS({
          applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
          applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
          applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
          applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
          applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
          applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
          applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
          constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
          constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
          constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
          constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
          constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
          constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
          constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
        });
      }

      arityToApplyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
      arityToApplyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
      arityToApplyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
      arityToApplyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
      arityToApplyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
      arityToApplyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
      arityToApplyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
      arityToConstructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
      arityToConstructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
      arityToConstructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
      arityToConstructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
      arityToConstructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
      arityToConstructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
      arityToConstructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
      const {
        prototype: BoundaryProxyHandlerProto$LWS
      } = BoundaryProxyHandler$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
      ReflectSetPrototypeOf$LWS(BoundaryProxyHandlerProto$LWS, null); // Future optimization: Hoping proxies with frozen handlers can be faster.

      ObjectFreeze$LWS(BoundaryProxyHandlerProto$LWS);
    };
  };
  /* eslint-enable prefer-object-spread */
}

const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;

function createBlueConnector$LWS(_globalObject$LWS) {
  if (typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing globalObject.');
  }

  return createMembraneMarshall$LWS(_globalObject$LWS);
}

function createRedConnector$LWS(evaluator$LWS) {
  if (typeof evaluator$LWS !== 'function') {
    throw new TypeErrorCtor$LWS('Missing evaluator function.');
  }

  return evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
}

const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = Symbol.for('@@lockerNearMembraneUndefinedValue');

class VirtualEnvironment$LWS {
  constructor(options$LWS) {
    if (options$LWS === undefined) {
      throw new ErrorCtor$LWS('Missing required VirtualEnvironment options.');
    } // prettier-ignore


    const {
      blueConnector: blueConnector$LWS,
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      redConnector: redConnector$LWS // eslint-disable-next-line prefer-object-spread

    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    let blueHooks$LWS;
    const blueConnect$LWS = blueConnector$LWS('blue', (...hooks$LWS) => {
      blueHooks$LWS = hooks$LWS;
    }, {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS
    });
    const {
      0: blueGlobalThisPointer$LWS,
      1: blueGetSelectedTarget$LWS,
      2: blueGetTransferableValue$LWS,
      3: blueCallableGetPropertyValuePointer$LWS,
      // 4: blueCallableEvaluate,
      5: blueCallableLinkPointers$LWS,
      6: blueCallablePushErrorTarget$LWS,
      7: blueCallablePushTarget$LWS,
      8: blueCallableApply$LWS,
      9: blueCallableConstruct$LWS,
      10: blueCallableDefineProperty$LWS,
      11: blueCallableDeleteProperty$LWS,
      12: blueCallableGet$LWS,
      13: blueCallableGetOwnPropertyDescriptor$LWS,
      14: blueCallableGetPrototypeOf$LWS,
      15: blueCallableHas$LWS,
      16: blueCallableIsExtensible$LWS,
      17: blueCallableOwnKeys$LWS,
      18: blueCallablePreventExtensions$LWS,
      19: blueCallableSet$LWS,
      20: blueCallableSetPrototypeOf$LWS,
      21: blueCallableDebugInfo$LWS,
      // 22: blueCallableDefineProperties,
      23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: blueCallableGetTargetIntegrityTraits$LWS,
      25: blueCallableGetToStringTagOfTarget$LWS,
      26: blueCallableGetTypedArrayIndexedValue$LWS,
      27: blueCallableInstallErrorPrepareStackTrace$LWS,
      // 28: blueCallableInstallLazyPropertyDescriptors,
      29: blueCallableIsTargetLive$LWS,
      30: blueCallableIsTargetRevoked$LWS,
      31: blueCallableSerializeTarget$LWS,
      32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      34: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      35: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = blueHooks$LWS;
    let redHooks$LWS;
    const redConnect$LWS = redConnector$LWS('red', (...hooks$LWS) => {
      redHooks$LWS = hooks$LWS;
    });
    const {
      0: redGlobalThisPointer$LWS,
      // 1: redGetSelectedTarget,
      // 2: redGetTransferableValue,
      3: redCallableGetPropertyValuePointer$LWS,
      4: redCallableEvaluate$LWS,
      5: redCallableLinkPointers$LWS,
      6: redCallablePushErrorTarget$LWS,
      7: redCallablePushTarget$LWS,
      8: redCallableApply$LWS,
      9: redCallableConstruct$LWS,
      10: redCallableDefineProperty$LWS,
      11: redCallableDeleteProperty$LWS,
      12: redCallableGet$LWS,
      13: redCallableGetOwnPropertyDescriptor$LWS,
      14: redCallableGetPrototypeOf$LWS,
      15: redCallableHas$LWS,
      16: redCallableIsExtensible$LWS,
      17: redCallableOwnKeys$LWS,
      18: redCallablePreventExtensions$LWS,
      19: redCallableSet$LWS,
      20: redCallableSetPrototypeOf$LWS,
      21: redCallableDebugInfo$LWS,
      22: redCallableDefineProperties$LWS,
      23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: redCallableGetTargetIntegrityTraits$LWS,
      25: redCallableGetToStringTagOfTarget$LWS,
      26: redCallableGetTypedArrayIndexedValue$LWS,
      27: redCallableInstallErrorPrepareStackTrace$LWS,
      28: redCallableInstallLazyPropertyDescriptors$LWS,
      29: redCallableIsTargetLive$LWS,
      30: redCallableIsTargetRevoked$LWS,
      31: redCallableSerializeTarget$LWS,
      32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      34: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      35: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = redHooks$LWS;
    blueConnect$LWS(noop$LWS, // redGlobalThisPointer,
    noop$LWS, // redGetSelectedTarget,
    noop$LWS, // redGetTransferableValue,
    noop$LWS, // redCallableGetPropertyValuePointer,
    noop$LWS, // redCallableEvaluate,
    noop$LWS, // redCallableLinkPointers,
    redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS, // redCallableDefineProperties,
    redCallableGetLazyPropertyDescriptorStateByTarget$LWS, redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableGetTypedArrayIndexedValue$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, // redCallableInstallLazyPropertyDescriptors,
    redCallableIsTargetLive$LWS, redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    redConnect$LWS(noop$LWS, // blueGlobalThisPointer,
    noop$LWS, // blueGetSelectedTarget,
    noop$LWS, // blueGetTransferableValue,
    noop$LWS, // blueCallableGetPropertyValuePointer,
    noop$LWS, // blueCallableEvaluate,
    noop$LWS, // blueCallableLinkPointers,
    blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, blueCallableDebugInfo$LWS, noop$LWS, // blueCallableDefineProperties,
    blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableGetTypedArrayIndexedValue$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, // blueCallableInstallLazyPropertyDescriptors,
    blueCallableIsTargetLive$LWS, blueCallableIsTargetRevoked$LWS, blueCallableSerializeTarget$LWS, blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
    this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
    this.blueGetTransferableValue = blueGetTransferableValue$LWS;
    this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
    this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
    this.redGlobalThisPointer = redGlobalThisPointer$LWS;
    this.redCallableGetPropertyValuePointer = redCallableGetPropertyValuePointer$LWS;
    this.redCallableEvaluate = redCallableEvaluate$LWS;
    this.redCallableLinkPointers = redCallableLinkPointers$LWS;
    this.redCallableSetPrototypeOf = redCallableSetPrototypeOf$LWS;
    this.redCallableDefineProperties = redCallableDefineProperties$LWS;
    this.redCallableInstallLazyPropertyDescriptors = redCallableInstallLazyPropertyDescriptors$LWS;
  }

  evaluate(_sourceText$LWS) {
    try {
      const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(_sourceText$LWS);

      if (typeof bluePointerOrPrimitiveValue$LWS === 'function') {
        bluePointerOrPrimitiveValue$LWS();
        return this.blueGetSelectedTarget();
      }

      return bluePointerOrPrimitiveValue$LWS;
    } catch (error) {
      var _this$blueGetSelected$LWS;

      throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
    }
  }

  lazyRemapProperties(__target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const _args$LWS = [this.blueGetTransferableValue(__target$LWS)];
      ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, ownKeys$LWS);

      if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
        // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit
        // `ownKeys` and `unforgeableGlobalThisKeys`.
        _args$LWS[_args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, unforgeableGlobalThisKeys$LWS);
      }

      ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, undefined, _args$LWS);
    }
  }

  link(..._keys$LWS) {
    let bluePointer$LWS = this.blueGlobalThisPointer;
    let redPointer$LWS = this.redGlobalThisPointer;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const __key$LWS = _keys$LWS[_i$LWS];
      bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, __key$LWS);
      redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, __key$LWS);
      this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
      this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
    }
  }

  remapProperties(__target$LWS, unsafeBlueDescMap$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const targetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescMap$LWS);
      const {
        length: _length$LWS
      } = ownKeys$LWS;
      const _args$LWS = new ArrayCtor$LWS(1 + _length$LWS * 7);
      _args$LWS[0] = targetPointer$LWS;

      for (let _i$LWS = 0, _j$LWS = 1; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        const unsafeBlueDesc$LWS = unsafeBlueDescMap$LWS[ownKey$LWS]; // Avoid poisoning by only installing own properties from unsafeBlueDescMap.
        // We don't use a toSafeDescriptor() style helper since that mutates
        // the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread

        const safeBlueDesc$LWS = ObjectAssign$LWS({
          __proto__: null
        }, unsafeBlueDesc$LWS);
        _args$LWS[_j$LWS] = ownKey$LWS;
        _args$LWS[_j$LWS + 1] = 'configurable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 2] = 'enumerable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 3] = 'writable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 4] = 'value' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 5] = 'get' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 6] = 'set' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }

      ReflectApply$LWS(this.redCallableDefineProperties, this, _args$LWS);
    }
  }

  remapProto(__target$LWS, _proto$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const foreignTargetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
      const transferableProto$LWS = _proto$LWS ? this.blueGetTransferableValue(_proto$LWS) : _proto$LWS;
      this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
    }
  }

}
/**
 * This list must be in sync with ecma-262, anything new added to the global object
 * should be considered, to decide whether or not they need remapping. The default
 * behavior, if missing form the following list, is to be remapped, which is safer.
 *
 * Note: remapped means the functionality is provided by the blue realm, rather than
 * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects
 * have the same identity because it is always derived from the outer realm's Set.
 *
 * Note 1: We have identified 3 types of intrinsics
 * A: primitives driven intrinsics
 * B: syntax driven intrinsics (they usually have a imperative form as well)
 * C: imperative only intrinsics
 *
 * While A is not remapped, it is safe, and works fast that way, and C is remapped to
 * preserve the identity of all produced objects from the same realm, B is really
 * problematic, and requires a lot more work to guarantee that objects from both sides
 * can be considered equivalents (without identity discontinuity).
 */


const ESGlobalKeys$LWS = [// *** 19.1 Value Properties of the Global Object
'globalThis', 'Infinity', 'NaN', 'undefined', // *** 19.2 Function Properties of the Global Object
// 'eval', // dangerous & Reflective
'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', // *** 19.3 Constructor Properties of the Global Object
// 'AggregateError', // Reflective
// 'Array', // Reflective
// 'ArrayBuffer', // Remapped
'BigInt', // 'BigInt64Array', // Remapped
// 'BigUint64Array', // Remapped
'Boolean', // 'DataView', // Remapped
// 'Date', // Remapped
// 'Error', // Reflective
// 'EvalError', // Reflective
'FinalizationRegistry', // 'Float32Array', // Remapped
// 'Float64Array', // Remapped
// 'Function', // dangerous & Reflective
// 'Int8Array', // Remapped
// 'Int16Array', // Remapped
// 'Int32Array', // Remapped
// 'Map', // Remapped
'Number', // 'Object', // Reflective
// Allow blue `Promise` constructor to overwrite the Red one so that promises
// created by the `Promise` constructor or APIs like `fetch` will work.
// 'Promise', // Remapped
// 'Proxy', // Reflective
// 'RangeError', // Reflective
// 'ReferenceError', // Reflective
'RegExp', // 'Set', // Remapped
// 'SharedArrayBuffer', // Remapped
'String', 'Symbol', // 'SyntaxError', // Reflective
// 'TypeError', // Reflective
// 'Uint8Array', // Remapped
// 'Uint8ClampedArray', // Remapped
// 'Uint16Array', // Remapped
// 'Uint32Array', // Remapped
// 'URIError', // Reflective
// 'WeakMap', // Remapped
// 'WeakSet', // Remapped
'WeakRef', // *** 18.4 Other Properties of the Global Object
// 'Atomics', // Remapped
'JSON', 'Math', 'Reflect', // *** Annex B
'escape', 'unescape' // *** ECMA-402
// 'Intl',  // Remapped
]; // These are foundational things that should never be wrapped but are equivalent
// TODO: revisit this list.

const ReflectiveIntrinsicObjectNames$LWS = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];
const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);

function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(_descMap$LWS, source$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[_i$LWS]; // Avoid overriding ECMAScript global names that correspond to
    // global intrinsics. This guarantee that those entries will be
    // ignored if present in the source property descriptor map.

    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      const _unsafeDesc$LWS = source$LWS[ownKey$LWS];

      if (_unsafeDesc$LWS) {
        // Avoid poisoning by only installing own properties from
        // unsafeDesc. We don't use a toSafeDescriptor() style helper
        // since that mutates the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        _descMap$LWS[ownKey$LWS] = ObjectAssign$LWS({
          __proto__: null
        }, _unsafeDesc$LWS);
      }
    }
  }

  return _descMap$LWS;
}

function getFilteredGlobalOwnKeys$LWS(source$LWS) {
  const _result$LWS = [];
  let resultOffset$LWS = 0;
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[_i$LWS]; // Avoid overriding ECMAScript global names that correspond to global
    // intrinsics. This guarantees that those entries will be ignored if
    // present in the source object.

    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      _result$LWS[resultOffset$LWS++] = ownKey$LWS;
    }
  }

  return _result$LWS;
}

function linkIntrinsics$LWS(env$LWS, _globalObject$LWS) {
  // Remap intrinsics that are realm agnostic.
  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ReflectiveIntrinsicObjectNames$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[_i$LWS];
    const reflectiveValue$LWS = _globalObject$LWS[globalName$LWS];

    if (reflectiveValue$LWS) {
      // Proxy.prototype is undefined.
      if (reflectiveValue$LWS.prototype) {
        env$LWS.link(globalName$LWS, 'prototype');
      } else {
        env$LWS.link(globalName$LWS);
      }
    }
  }
}

const {
  prototype: DocumentProto$LWS
} = Document;
const {
  close: DocumentProtoClose$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');
const {
  remove: ElementProtoRemove$LWS,
  setAttribute: ElementProtoSetAttribute$LWS
} = Element.prototype;
const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'style');
const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, 'contentWindow');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS
} = NodeProto$LWS;
const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');
const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap()); // Chromium based browsers have a bug that nulls the result of `window`
// getters in detached iframes when the property descriptor of `window.window`
// is retrieved.
// https://bugs.chromium.org/p/chromium/issues/detail?id=1305302

const unforgeablePoisonedWindowKeys$LWS = (() => {
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = window; // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata

  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;

  if ( // While experimental, `navigator.userAgentData.brands` may be defined
  // as an empty array in headless Chromium based browsers.
  ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ? // Use user-agent client hints API if available to avoid
  // deprecation warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  brands$LWS.find(item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium') : // Fallback to a standard user-agent string sniff.
  // Note: Chromium identifies itself as Chrome in its user-agent string.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  / (?:Headless)?Chrome\/\d+/.test(navigator$LWS.userAgent)) {
    return ['window'];
  }

  return undefined;
})();

function getCachedGlobalObjectReferences$LWS(_globalObject$LWS) {
  const {
    window: window$LWS
  } = _globalObject$LWS;
  let _record$LWS;
  let _document$LWS; // Suppress errors thrown on cross-origin opaque windows.

  try {
    ({
      document: _document$LWS
    } = _globalObject$LWS);
    _record$LWS = blueDocumentToRecordMap$LWS.get(_document$LWS); // eslint-disable-next-line no-empty
  } catch (__unused$LWS) {
    return undefined;
  }

  if (_record$LWS) {
    return _record$LWS;
  } // Cache references to object values that can't be replaced
  // window -> Window -> WindowProperties -> EventTarget


  const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
  const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
  const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
  _record$LWS = {
    document: _document$LWS,
    DocumentProto: ReflectGetPrototypeOf$LWS(_document$LWS),
    window: window$LWS,
    WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
    WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
    EventTargetProto: EventTargetProto$LWS,
    EventTargetProtoOwnKeys: ReflectOwnKeys$LWS(EventTargetProto$LWS)
  };
  blueDocumentToRecordMap$LWS.set(_document$LWS, _record$LWS);
  return _record$LWS;
}

function filterWindowKeys$LWS(_keys$LWS) {
  const _result$LWS = [];
  let resultOffset$LWS = 0;

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const __key$LWS = _keys$LWS[_i$LWS];

    if ( // Filter out unforgeable property keys that cannot be installed.
    __key$LWS !== 'document' && __key$LWS !== 'location ' && __key$LWS !== 'top' && __key$LWS !== 'window' && // Remove other browser specific unforgeables.
    __key$LWS !== 'chrome') {
      _result$LWS[resultOffset$LWS++] = __key$LWS;
    }
  }

  return _result$LWS;
}
/**
 * global descriptors are a combination of 3 set of descriptors:
 * - first, the key of the red descriptors define the descriptors
 *   provided by the browser when creating a brand new window.
 * - second, once we know the base keys, we get the actual descriptors
 *   from the blueDescriptors, since those are the one we want to provide
 *   access to via the membrane.
 * - third, the user of this library can provide endowments, which define
 *   global descriptors that should be installed into the sandbox on top
 *   of the base descriptors.
 *
 * Note: The main reason for using redDescriptors as the base keys instead
 * of blueDescriptor is because there is no guarantee that this library is
 * the first one to be evaluated in the host app, which means it has no ways
 * to determine what is a real DOM API vs app specific globals.
 *
 * Quirk: The only quirk here is for the case in which this library runs
 * after some other code that patches some of the DOM APIs. This means
 * the installed proxy in the sandbox will point to the patched global
 * API in the blue realm, rather than the original, because we don't have
 * a way to access the original anymore. This should not be a deal-breaker
 * if the patched API behaves according to the spec.
 *
 * The result of this method is a descriptor map that contains everything
 * that will be installed (via the membrane) as global descriptors in
 * the red realm.
 */


function removeWindowDescriptors$LWS(unsafeDescMap$LWS) {
  // Remove unforgeable descriptors that cannot be installed.
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'document');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'location');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'top');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'window'); // Remove other browser specific unforgeables.

  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'chrome');
  return unsafeDescMap$LWS;
}
/**
 * Initialization operation to capture and cache all unforgeable references
 * and their respective descriptor maps before any other code runs, this
 * usually help because this library runs before anything else that can poison
 * the environment.
 */


getCachedGlobalObjectReferences$LWS(window);
const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = 'allow-same-origin allow-scripts';
const blueDocumentToBlueCreateHooksCallbackMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
let defaultGlobalOwnKeys$LWS = null;

function createDetachableIframe$LWS(doc$LWS) {
  var _ReflectApply$LWS;

  const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ['iframe']); // It is impossible to test whether the NodeProtoLastChildGetter branch is
  // reached in a normal Karma test environment.

  const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS :
  /* istanbul ignore next */
  ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
  const _style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
  _style$LWS.display = 'none';
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ['sandbox', IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
  return iframe$LWS;
}

function createIframeVirtualEnvironment$LWS(_globalObject$LWS, options$LWS) {
  if (typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing global object virtualization target.');
  }

  const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(_globalObject$LWS);

  if (typeof blueRefs$LWS !== 'object' || blueRefs$LWS === null) {
    throw new TypeErrorCtor$LWS('Invalid virtualization target.');
  }

  const {
    distortionCallback: distortionCallback$LWS,
    endowments: endowments$LWS,
    globalObjectShape: globalObjectShape$LWS,
    instrumentation: instrumentation$LWS,
    keepAlive: keepAlive$LWS = false,
    liveTargetCallback: liveTargetCallback$LWS // eslint-disable-next-line prefer-object-spread

  } = ObjectAssign$LWS({
    __proto__: null
  }, options$LWS);
  const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
  const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
  const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== 'object' || globalObjectShape$LWS === null;

  if (shouldUseDefaultGlobalOwnKeys$LWS && defaultGlobalOwnKeys$LWS === null) {
    defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS));
  }

  let blueConnector$LWS = blueDocumentToBlueCreateHooksCallbackMap$LWS.get(blueRefs$LWS.document);

  if (blueConnector$LWS === undefined) {
    blueConnector$LWS = createBlueConnector$LWS(_globalObject$LWS);
    blueDocumentToBlueCreateHooksCallbackMap$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
  }

  const env$LWS = new VirtualEnvironment$LWS({
    blueConnector: blueConnector$LWS,
    distortionCallback: distortionCallback$LWS,
    instrumentation: instrumentation$LWS,
    liveTargetCallback: liveTargetCallback$LWS,
    redConnector: createRedConnector$LWS(redWindow$LWS.eval)
  });
  linkIntrinsics$LWS(env$LWS, _globalObject$LWS); // window
  // window.document
  // In browsers globalThis is === window.

  if (typeof globalThis === 'undefined') {
    // Support for globalThis was added in Chrome 71.
    // However, environments like Android emulators are running Chrome 69.
    env$LWS.link('window', 'document');
  } else {
    // document is === window.document.
    env$LWS.link('document');
  } // window.__proto__ (aka Window.prototype)
  // window.__proto__.__proto__ (aka WindowProperties.prototype)
  // window.__proto__.__proto__.__proto__ (aka EventTarget.prototype)


  env$LWS.link('__proto__', '__proto__', '__proto__');
  env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
  env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS)), // Chromium based browsers have a bug that nulls the result of `window`
  // getters in detached iframes when the property descriptor of `window.window`
  // is retrieved.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
  keepAlive$LWS ? undefined : unforgeablePoisonedWindowKeys$LWS);

  if (endowments$LWS) {
    const filteredEndowments$LWS = {};
    assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS);
    removeWindowDescriptors$LWS(filteredEndowments$LWS);
    env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
  } // We intentionally skip remapping Window.prototype because there is nothing
  // in it that needs to be remapped.


  env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys); // We don't remap `blueRefs.WindowPropertiesProto` because it is "magical"
  // in that it provides access to elements by id.
  //
  // Once we get the iframe info ready, and all mapped, we can proceed to
  // detach the iframe only if `options.keepAlive` isn't true.

  if (keepAlive$LWS) {
    // TODO: Temporary hack to preserve the document reference in Firefox.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=543435
    const {
      document: redDocument$LWS
    } = redWindow$LWS;
    ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
    ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
  } else {
    ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
  }

  return env$LWS;
} // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md
// istanbul ignore next


const HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function redHelpersFactory$LWS(_context$LWS) {
  const {
    elementToLoadingPromiseMap: elementToLoadingPromiseMap$LWS
  } = _context$LWS;
  const ArrayCtor$LWS = Array;
  const PromiseCtor$LWS = Promise;
  const TypeErrorCtor$LWS = TypeError;
  const {
    asyncIterator: SymbolAsyncIterator$LWS,
    iterator: SymbolIterator$LWS
  } = Symbol;
  const {
    [SymbolIterator$LWS]: ArrayIterator$LWS
  } = ArrayCtor$LWS.prototype; // The Generator prototype object is %GeneratorFunction.prototype.prototype%.
  // https://tc39.es/ecma262/#sec-generatorfunction.prototype.prototype
  // eslint-disable-next-line @typescript-eslint/no-empty-function, func-names

  const GeneratorProto$LWS = function* () {}.constructor.prototype.prototype;

  const {
    next: GeneratorProtoNext$LWS,
    throw: GeneratorProtoThrow$LWS
  } = GeneratorProto$LWS;
  const {
    delete: MapProtoDelete$LWS,
    get: MapProtoGet$LWS,
    set: MapProtoSet$LWS
  } = Map.prototype;
  const {
    appendChild: NodeProtoAppendChild$LWS
  } = Node.prototype;
  const {
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS
  } = Object;
  const {
    then: PromiseProtoThen$LWS
  } = PromiseCtor$LWS.prototype;
  const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
  const {
    apply: ReflectApply$LWS,
    get: ReflectGet$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  const {
    replace: StringProtoReplace$LWS
  } = String.prototype;
  const {
    get: WeakMapProtoGet$LWS,
    set: WeakMapProtoSet$LWS
  } = WeakMap.prototype;
  const {
    createElement: DocumentProtoCreateElement$LWS
  } = Document.prototype;
  const {
    querySelector: ElementProtoQuerySelector$LWS,
    setAttribute: ElementProtoSetAttribute$LWS
  } = Element.prototype;
  const {
    stopPropagation: EventProtoStopPropagation$LWS
  } = Event.prototype;
  const {
    addEventListener: EventTargetProtoAddEventListener$LWS,
    removeEventListener: EventTargetProtoRemoveEventListener$LWS
  } = EventTarget.prototype;
  const {
    head: headRef$LWS
  } = document; // We don't use `toSafeMap()` here because `Map` is remapped from the
  // primary realm and dot notation is actually more complex internally for
  // cross-realm objects.

  const forOfStateMap$LWS = new Map();
  const singleQuotesRegExp$LWS = /\\?'/g;
  const LOCKER_ID_DATA_NAME$LWS = 'data-locker-id'; // Generate a UID for this sandbox run for <script> elements.

  const LOCKER_ID_DATA_VALUE$LWS = `${crypto.getRandomValues(new Uint32Array(1))[0]}`;

  class LockerSecurityError$LWS extends Error {
    constructor(message$LWS) {
      super(`Lightning Web Security: ${message$LWS}`);
    }

  } // This helper is used to wrap the bodies of async functions that are
  // transformed into generator functions. It's based on @babel/helpers
  // `helpers.asyncToGenerator()`:
  // https://github.com/babel/babel/blob/a967910/packages/babel-helpers/src/helpers.js#L255-L288


  function asyncToGen$LWS(func$LWS, thisArg$LWS) {
    return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      const gen$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, []);

      function next$LWS(__value$LWS) {
        genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorProtoNext$LWS, __value$LWS);
      }

      function thrower$LWS(error) {
        genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorProtoThrow$LWS, error);
      }

      next$LWS(undefined);
    });
  }

  function escapeSingleQuotes$LWS(_string$LWS) {
    // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    return ReflectApply$LWS(StringProtoReplace$LWS, _string$LWS, [singleQuotesRegExp$LWS, "\\'"]);
  }

  function forAwaitOf$LWS(_index$LWS, stage$LWS, object$LWS) {
    if (stage$LWS === 0
    /* init */
    ) {
      let sync$LWS = false;
      let {
        [SymbolAsyncIterator$LWS]: iterator$LWS
      } = object$LWS;

      if (iterator$LWS === null || iterator$LWS === undefined) {
        sync$LWS = true;
        ({
          [SymbolIterator$LWS]: iterator$LWS
        } = object$LWS);
      }

      if (typeof iterator$LWS !== 'function') {
        throw new TypeErrorCtor$LWS('Object is not iterable.');
      }

      ReflectApply$LWS(MapProtoSet$LWS, forOfStateMap$LWS, [_index$LWS, {
        iterable: ReflectApply$LWS(iterator$LWS, object$LWS, []),
        step: undefined,
        sync: sync$LWS
      }]);
      return undefined;
    }

    const state$LWS = ReflectApply$LWS(MapProtoGet$LWS, forOfStateMap$LWS, [_index$LWS]);

    if (stage$LWS === 1
    /* step */
    ) {
      const _result$LWS = state$LWS.iterable.next();
      return state$LWS.sync ? new PromiseCtor$LWS(resolve$LWS => {
        state$LWS.step = _result$LWS;
        resolve$LWS();
      }) : ReflectApply$LWS(PromiseProtoThen$LWS, _result$LWS, [step$LWS => {
        state$LWS.step = step$LWS;
      }]);
    }

    if (stage$LWS === 2
    /* value */
    ) {
      return state$LWS.step.value;
    }

    if (stage$LWS === 3
    /* done */
    ) {
      const done$LWS = !!state$LWS.step.done;

      if (done$LWS) {
        ReflectApply$LWS(MapProtoDelete$LWS, forOfStateMap$LWS, [_index$LWS]);
      }

      return done$LWS;
    }

    return undefined;
  }

  function genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorMethod$LWS, arg$LWS) {
    let info$LWS;
    let __value$LWS;

    try {
      info$LWS = ReflectApply$LWS(GeneratorMethod$LWS, gen$LWS, [arg$LWS]);
      __value$LWS = info$LWS.value;
    } catch (error) {
      reject$LWS(error);
      return;
    }

    if (info$LWS.done) {
      resolve$LWS(__value$LWS);
    } else {
      PromiseResolve$LWS(__value$LWS).then(next$LWS, thrower$LWS);
    }
  } // loadPromise returns a promise to load the given element.


  function loadPromise$LWS(_element$LWS, urlAsString$LWS) {
    const promise$LWS = new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      function onerror$LWS(_event$LWS) {
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['load', onload$LWS]);
        ReflectApply$LWS(EventProtoStopPropagation$LWS, _event$LWS, []);
        reject$LWS(new LockerSecurityError$LWS(`Resource loader error loading '${escapeSingleQuotes$LWS(urlAsString$LWS)}'.`));
      }

      function onload$LWS() {
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['load', onload$LWS]);
        resolve$LWS(undefined);
      }

      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, _element$LWS, ['load', onload$LWS]);
    });
    ReflectApply$LWS(WeakMapProtoSet$LWS, elementToLoadingPromiseMap$LWS, [_element$LWS, promise$LWS]);
    ReflectApply$LWS(NodeProtoAppendChild$LWS, headRef$LWS, [_element$LWS]);
    return promise$LWS;
  } // Functionality based on https://sfdc.co/7FuDU but adjusted for multiple
  // sandboxes. loadScript will create one <script> element in the DOM per url
  // per sandbox.


  function loadScript$LWS(_thisArg$LWS, _url$LWS) {
    const urlAsString$LWS = toString$LWS(_url$LWS);
    let script$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, headRef$LWS, [`script[data-distorted-src='${escapeSingleQuotes$LWS(urlAsString$LWS)}'][${LOCKER_ID_DATA_NAME$LWS}='${LOCKER_ID_DATA_VALUE$LWS}']`]);

    if (script$LWS) {
      var _ReflectApply2$LWS;

      return (_ReflectApply2$LWS = ReflectApply$LWS(WeakMapProtoGet$LWS, elementToLoadingPromiseMap$LWS, [script$LWS])) != null ? _ReflectApply2$LWS : PromiseResolve$LWS();
    }

    script$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['script']);
    ReflectApply$LWS(ElementProtoSetAttribute$LWS, script$LWS, [LOCKER_ID_DATA_NAME$LWS, LOCKER_ID_DATA_VALUE$LWS]);
    script$LWS.type = 'text/javascript';
    script$LWS.src = urlAsString$LWS;
    return loadPromise$LWS(script$LWS, urlAsString$LWS);
  } // Functionality based on http://sfdc.co/bIpMYB but adjusted for multiple
  // sandboxes. loadStyle will create one <link> element in the DOM per url
  // for all the sandboxes.


  function loadStyle$LWS(_thisArg$LWS, _url$LWS) {
    const urlAsString$LWS = toString$LWS(_url$LWS);
    let link$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, headRef$LWS, [`link[href='${escapeSingleQuotes$LWS(urlAsString$LWS)}']`]);

    if (link$LWS) {
      var _ReflectApply3$LWS;

      return (_ReflectApply3$LWS = ReflectApply$LWS(WeakMapProtoGet$LWS, elementToLoadingPromiseMap$LWS, [link$LWS])) != null ? _ReflectApply3$LWS : PromiseResolve$LWS();
    }

    link$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['link']);
    link$LWS.type = 'text/css';
    link$LWS.rel = 'stylesheet';
    link$LWS.href = urlAsString$LWS;
    return loadPromise$LWS(link$LWS, urlAsString$LWS);
  }

  function makeRedGet$LWS(...bindings$LWS) {
    const {
      length: _length$LWS
    } = bindings$LWS;
    const redGet$LWS = ArrayCtor$LWS(_length$LWS);
    const descriptors$LWS = {};

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      descriptors$LWS[_i$LWS] = {
        __proto__: null,
        get: bindings$LWS[_i$LWS]
      };
    }

    ObjectDefineProperties$LWS(redGet$LWS, descriptors$LWS);
    return redGet$LWS;
  }

  function makeRedResyncImports$LWS(bindings$LWS) {
    return function (..._args$LWS) {
      for (let _i$LWS = 0, {
        length: _length$LWS
      } = bindings$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        try {
          // eslint-disable-next-line @typescript-eslint/no-unused-expressions
          bindings$LWS[_i$LWS]; // eslint-disable-next-line no-empty
        } catch (_unused35$LWS) {}
      }

      return spreadable$LWS(_args$LWS);
    };
  }

  function _namespace$LWS(object$LWS) {
    return ObjectFreeze$LWS(object$LWS);
  }

  function spreadable$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS[SymbolIterator$LWS] = ArrayIterator$LWS;
    return array$LWS;
  }

  function superApplyOrGet$LWS(__target$LWS, __key$LWS, thisArgOrReceiver$LWS, _args$LWS) {
    const superProto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);

    if (superProto$LWS === null) {
      return undefined;
    }

    return _args$LWS ? ReflectApply$LWS(superProto$LWS[__key$LWS], thisArgOrReceiver$LWS, _args$LWS) : ReflectGet$LWS(superProto$LWS, __key$LWS, thisArgOrReceiver$LWS);
  }

  function toString$LWS(__value$LWS) {
    return typeof __value$LWS === 'string' ? __value$LWS : `${__value$LWS}`;
  }

  return {
    asyncToGen: asyncToGen$LWS,
    forAwaitOf: forAwaitOf$LWS,
    loadScript: loadScript$LWS,
    loadStyle: loadStyle$LWS,
    makeRedGet: makeRedGet$LWS,
    makeRedResyncImports: makeRedResyncImports$LWS,
    namespace: _namespace$LWS,
    spreadable: spreadable$LWS,
    super: superApplyOrGet$LWS
  };
}})`; // WebKit based browsers have a bug that prematurely removes distortion entries
// from their weak map.

const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = (() => {
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = selfWindow$LWS;
  const webKitRegExp$LWS = /WebKit/i; // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands; // istanbul ignore else: needs default platform behavior test

  if ( // While experimental, `navigator.userAgentData.brands` may be defined
  // as an empty array in headless Chromium based browsers.
  ArrayIsArray$1$LWS(brands$LWS) && brands$LWS.length ? // Use user-agent client hints API if available to avoid
  // deprecation warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  // istanbul ignore next: this code is not reachable in the version of chrome used to measure coverage.
  brands$LWS.find( // istanbul ignore next
  item$LWS => {
    const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
    return typeof brand$LWS === 'string' && webKitRegExp$LWS.test(brand$LWS);
  }) : // Fallback to a standard user-agent string sniff.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  webKitRegExp$LWS.test(navigator$LWS.userAgent)) {
    return false;
  } // istanbul ignore next: needs default platform behavior test


  return true;
})();

const {
  location: selfLocation$LWS,
  top: topWindow$LWS
} = selfWindow$LWS; // Fast path non-configurable document, location, and window objects in the
// virtual environment distortion callback by seeding them in the top window's
// created distortion map.

const selfDistortionMapSeedEntries$LWS = [[selfDocument$LWS, selfDocument$LWS], [selfLocation$LWS, selfLocation$LWS], [selfWindow$LWS, selfWindow$LWS]];
const selfSandboxRegistry$LWS = {
  __proto__: null
};
const documentToSandboxRegistry$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS([[selfDocument$LWS, selfSandboxRegistry$LWS]]));
const documentToDistortionFactoriesMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const documentToEvaluationDistortionFactoriesMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const elementToLoadingPromiseMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const opaqueToDistortionFactoriesMap$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const opaqueToSandboxRegistry$LWS = toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS());
const seenGlobalObjects$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const CORE_SANDBOX_KEY$LWS = 'lws-core-sandbox';
const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
  [SANDBOX_EVAL_CONTEXT_NAME$LWS]: {
    __proto__: null,

    get() {
      return clearEvalContext$LWS();
    }

  },
  [SANDBOX_EVAL_HELPERS_NAME$LWS]: {
    __proto__: null,

    get() {
      return clearEvalHelpers$LWS();
    }

  }
};
const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
const EMPTY_HELPERS$LWS = createEvalHelpersObject$LWS();
const EMPTY_OBJECT$LWS = {};
const TOP_UNCOMPILED_CONTEXT$LWS = {
  [UNCOMPILED_LOCATION_NAME$LWS]: selfLocation$LWS,
  [UNCOMPILED_TOP_NAME$LWS]: topWindow$LWS
};
let lockerEvalContextValue$LWS;
let lockerEvalHelpersValue$LWS;

function clearEvalContext$LWS() {
  const evalContext$LWS = lockerEvalContextValue$LWS;
  lockerEvalContextValue$LWS = undefined;
  return evalContext$LWS;
}

function clearEvalHelpers$LWS() {
  const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
  lockerEvalHelpersValue$LWS = undefined;
  return evalHelpers$LWS;
}

function createChildWindowSandboxRecord$LWS({
  globalObject: _globalObject$LWS,
  document: _document$LWS,
  context: _context$LWS,
  key: __key$LWS,
  type: _type$LWS
}, top$LWS = selfSandboxRegistry$LWS[__key$LWS]) {
  const sandboxRegistry$LWS = getSandboxRegistry$LWS(_document$LWS);
  let _record$LWS = sandboxRegistry$LWS[__key$LWS];

  if (_record$LWS) {
    return _record$LWS;
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = top$LWS;
  const {
    location: location$LWS
  } = _globalObject$LWS;
  const overrideDistortions$LWS = createDistortionMap$LWS();
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: {
      [UNCOMPILED_LOCATION_NAME$LWS]: location$LWS
    },
    context: _context$LWS,
    document: _document$LWS,
    distortions: overrideDistortions$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: _globalObject$LWS,
    helpers: createEvalHelpersObject$LWS(),
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$1$LWS,
    top: top$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$1$LWS
  };
  _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
  _record$LWS.virtualEnvironmentEvaluator = createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS); // Fast path non-configurable document, location, and window objects in the
  // virtual environment distortion callback by adding them to the top window's
  // distortion map.

  distortions$LWS.set(_document$LWS, _document$LWS);
  distortions$LWS.set(location$LWS, location$LWS);
  const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(_globalObject$LWS);

  if (!seenGlobalObject$LWS) {
    // WindowProxy object references don't change when the window location
    // changes.
    // https://developer.mozilla.org/en-US/docs/Glossary/WindowProxy
    distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
  }

  const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS));
  const evaluationEntries$LWS = createDistortionEntries$LWS(_record$LWS, getEvaluationDistortionFactories$LWS(_record$LWS)); // Call `createAttributeDistortionFactories()` last because its factories
  // are populated by the other distortion factories.

  createDistortionEntries$LWS(_record$LWS, createAttributeDistortionFactories$LWS(_record$LWS), entries$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[_i$LWS]; // Add distortion to the top window's distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = evaluationEntries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = evaluationEntries$LWS[_i$LWS]; // Add evaluation distortion for the child window to the top
    // window's distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS); // Add the undistorted entry to the child window's distortion map
    // so the undistorted entry is used in the child window's sandbox
    // instead of the distorted entry.

    overrideDistortions$LWS.set(entryKey$LWS, entryKey$LWS);
  }

  sandboxRegistry$LWS[__key$LWS] = _record$LWS;

  if (seenGlobalObject$LWS) {
    return _record$LWS;
  }

  seenGlobalObjects$LWS.add(_globalObject$LWS);

  const onDOMContentLoadedOrWindowLoad$LWS = () => {
    try {
      // We don't need to use `WindowDocumentGetter()` because we know
      // this is a window object and the 'document' property is
      // non-configurable.
      const {
        document: newDocument$LWS
      } = _globalObject$LWS; // Ensure the document has changed before attempting to create a
      // sandbox record.

      if (_document$LWS !== newDocument$LWS) {
        createChildWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: newDocument$LWS,
          globalObject: _globalObject$LWS,
          key: __key$LWS,
          type: _type$LWS
        }, top$LWS);
      }
    } catch (_unused36$LWS) {
      // istanbul ignore next: this is a safety precaution that is unreachable via tests
      createOpaqueChildWindowSandboxRecord$LWS({
        globalObject: _globalObject$LWS,
        key: __key$LWS,
        type: _type$LWS
      }, top$LWS);
    }
  };

  const frameElement$LWS = ReflectApply$1$LWS(WindowFrameElementGetter$LWS, _globalObject$LWS, []);

  if (frameElement$LWS) {
    // Create a new sandbox record when the iframe window location changes.
    ReflectApply$1$LWS(EventTargetProtoAddEventListener$LWS, frameElement$LWS, ['load', onDOMContentLoadedOrWindowLoad$LWS, // useCapture
    true]);
  } else {
    // Create a new sandbox record when the opened window location changes.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes
    //
    // The 'unload' event handler is okay to use here under the assumption
    // that most `window.open()` calls are not done with the 'noopener'
    // option, so the back/forward cache (i.e. bfcache) is likely being
    // skipped anyways.
    // https://web.dev/bfcache/#avoid-window.opener-references
    ReflectApply$1$LWS(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['unload', function onWindowUnload$LWS() {
      WindowQueueMicrotask$LWS(() => {
        try {
          // Ensure the document has changed before adding event
          // listeners.
          const {
            document: newDocument$LWS
          } = _globalObject$LWS;

          if (_document$LWS !== newDocument$LWS) {
            ReflectApply$1$LWS(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['DOMContentLoaded', onDOMContentLoadedOrWindowLoad$LWS, true]);
            ReflectApply$1$LWS(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['unload', onWindowUnload$LWS, true]);
          }
        } catch (_unused37$LWS) {
          // istanbul ignore next: this is a safety precaution that is unreachable via tests
          createOpaqueChildWindowSandboxRecord$LWS({
            globalObject: _globalObject$LWS,
            key: __key$LWS,
            type: _type$LWS
          }, top$LWS);
        }
      });
    }, // useCapture
    true]);
  }

  return _record$LWS;
}

function createDistortionEntries$LWS(_record$LWS, _factories$LWS, entries$LWS = []) {
  let {
    length: entriesOffset$LWS
  } = entries$LWS;

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = _factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const factory$LWS = _factories$LWS[_i$LWS];
    const entry$LWS = factory$LWS(_record$LWS);

    if (entry$LWS) {
      const {
        0: proxyTarget$LWS,
        1: distortedValue$LWS
      } = entry$LWS;

      if (typeof proxyTarget$LWS === 'function') {
        entries$LWS[entriesOffset$LWS++] = [proxyTarget$LWS, proxyWrapFunctionDistortion$LWS(_record$LWS, factory$LWS.name, proxyTarget$LWS, distortedValue$LWS)];
      } else if (typeof proxyTarget$LWS === 'object' && proxyTarget$LWS !== null) {
        entries$LWS[entriesOffset$LWS++] = entry$LWS;
      }
    }
  }

  return entries$LWS;
}

function createDistortionMap$LWS(entries$LWS) {
  return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? // istanbul ignore next: navigator.userAgentData.brands is used to infer WeakMap support, but the array is empty in Chrome Headless.
  toSafeWeakMap$1$LWS(new WeakMapCtor$1$LWS(entries$LWS)) : toSafeMap$LWS(new MapCtor$LWS(entries$LWS));
}

function createEvalHelpersObject$LWS() {
  return {
    asyncToGen: noop$1$LWS,
    forAwaitOf: noop$1$LWS,
    loadScript: noop$1$LWS,
    loadStyle: noop$1$LWS,
    makeRedGet: noop$1$LWS,
    makeRedResyncImports: noop$1$LWS,
    namespace: noop$1$LWS,
    spreadable: noop$1$LWS,
    super: noop$1$LWS
  };
}

function createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS) {
  // Defer creating a virtual environment and populating `record.helpers`
  // until the first call to `evaluate()`.
  let lazyVirtualEnvironmentEvaluator$LWS;
  return _sourceText$LWS => {
    if (lazyVirtualEnvironmentEvaluator$LWS === undefined) {
      const virtualEnvironmentEvaluator$LWS = createVirtualEnvironmentEvaluator$LWS(_record$LWS); // Overwrite `lazyVirtualEnvironmentEvaluator` with `virtualEnvironmentEvaluator`.

      lazyVirtualEnvironmentEvaluator$LWS = virtualEnvironmentEvaluator$LWS; // Stash old eval context.

      const oldEvalContext$LWS = clearEvalContext$LWS(); // Populate `record.helpers`.

      setEvalContext$LWS(redHelpersFactory$LWS => {
        ObjectAssign$1$LWS(_record$LWS.helpers, redHelpersFactory$LWS({
          elementToLoadingPromiseMap: elementToLoadingPromiseMap$LWS
        }));
      });
      virtualEnvironmentEvaluator$LWS(HELPERS_SOURCE_TEXT$LWS); // Restore old eval context.

      setEvalContext$LWS(oldEvalContext$LWS);
    }

    return lazyVirtualEnvironmentEvaluator$LWS(_sourceText$LWS);
  };
}

function createOpaqueChildWindowSandboxRecord$LWS({
  globalObject: _globalObject$LWS,
  key: __key$LWS,
  type: _type$LWS
}, top$LWS) {
  const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(_globalObject$LWS);
  let _record$LWS = sandboxRegistry$LWS[__key$LWS]; // istanbul ignore if: calls that would evaluate to true here ARE tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered

  if (_record$LWS) {
    return _record$LWS;
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = top$LWS;
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
    context: EMPTY_OBJECT$LWS,
    document,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: _globalObject$LWS,
    helpers: EMPTY_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$1$LWS,
    top: top$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$1$LWS
  }; // Fast path non-configurable location and window objects in the virtual
  // environment distortion callback by adding them to the top window's
  // distortion map.

  const {
    location: location$LWS
  } = _globalObject$LWS;
  distortions$LWS.set(location$LWS, location$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (!seenGlobalObjects$LWS.has(_globalObject$LWS)) {
    distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
  }

  const opaqueEntries$LWS = createDistortionEntries$LWS(_record$LWS, getOpaqueDistortionFactories$LWS(_record$LWS));

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = opaqueEntries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = opaqueEntries$LWS[_i$LWS]; // Add opaque distortion for the child window to the top window's
    // distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  sandboxRegistry$LWS[__key$LWS] = _record$LWS;
  return _record$LWS;
}

function createSandboxEvaluator$LWS({
  LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
  document: _document$LWS,
  globalObject: _globalObject$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS,
  type: _type$LWS
}) {
  return (_sourceText$LWS, evalContext$LWS, evalGlobalObject$LWS = _globalObject$LWS, evalDocument$LWS = _document$LWS) => internalEvaluateInSandbox$LWS({
    context: evalContext$LWS,
    document: evalDocument$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: evalGlobalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: _sourceText$LWS,
    sourceType: 0
    /* SourceType.Script */
    ,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}

function createWindowSandboxRecord$LWS({
  context: _context$LWS,
  endowments: endowments$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS,
  type: _type$LWS,
  verboseInstrumentation: verboseInstrumentation$LWS
}) {
  let _record$LWS = selfSandboxRegistry$LWS[__key$LWS];

  if (_record$LWS) {
    return _record$LWS;
  }

  const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
  // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
  // removed in minified production builds.
  instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
  const distortions$LWS = createDistortionMap$LWS(selfDistortionMapSeedEntries$LWS);
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? {
      sandboxKey: __key$LWS
    } : EMPTY_OBJECT$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    verboseInstrumentation$LWS && LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: TOP_UNCOMPILED_CONTEXT$LWS,
    context: _context$LWS,
    document: selfDocument$LWS,
    distortions: distortions$LWS,
    endowments: endowments$LWS,
    globalObject: selfWindow$LWS,
    helpers: createEvalHelpersObject$LWS(),
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$1$LWS,
    top: EMPTY_OBJECT$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$1$LWS
  };
  _record$LWS.top = _record$LWS;
  _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
  _record$LWS.virtualEnvironmentEvaluator = createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS);
  const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS)); // Call `createAttributeDistortionFactories()` last because its factories
  // are populated by the other distortion factories.

  createDistortionEntries$LWS(_record$LWS, createAttributeDistortionFactories$LWS(_record$LWS), entries$LWS); // Add distortions to the top window's distortion map.

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[_i$LWS];
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  selfSandboxRegistry$LWS[__key$LWS] = _record$LWS;
  return _record$LWS;
}

function createVirtualEnvironmentEvaluator$LWS(_record$LWS) {
  const {
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
    distortions: overrideDistortions$LWS,
    endowments: endowments$LWS,
    globalObject: _globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    type: _type$LWS,
    top: top$LWS,
    top: {
      distortions: distortions$LWS
    }
  } = _record$LWS;
  const isTopRecord$LWS = _record$LWS === top$LWS;
  const env$LWS = createIframeVirtualEnvironment$LWS(_globalObject$LWS, {
    distortionCallback(originalTarget$LWS) {
      const distortedTarget$LWS = distortions$LWS.get(originalTarget$LWS);

      if (distortedTarget$LWS) {
        return isTopRecord$LWS ? distortedTarget$LWS : overrideDistortions$LWS.get(originalTarget$LWS) || distortedTarget$LWS;
      }

      if (typeof originalTarget$LWS === 'function') {
        return originalTarget$LWS;
      } // Perform the first own property check in a try-catch to avoid
      // throwing an error on opaque, non-window, objects of a cross-origin
      // window.


      try {
        // The location property is the only common non-configurable
        // property between window and document, so it serves this check
        // very well.
        if (!ObjectHasOwn$1$LWS(originalTarget$LWS, 'location')) {
          return originalTarget$LWS;
        }
      } catch (_unused38$LWS) {
        // Likely an opaque object of a cross-origin window.
        // istanbul ignore next: an access of property iframe.contentWindow.location.href on an opaque window, that should reach this catch clause IS tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
        return originalTarget$LWS;
      }

      let originalTargetDocument$LWS;
      let originalTargetWindow$LWS; // Do the safe cross-origin window object check first to avoid
      // failure caused by touching non-cross-origin-safe properties.

      if (ObjectHasOwn$1$LWS(originalTarget$LWS, 'window') && originalTarget$LWS.window === originalTarget$LWS) {
        // Slower check to detect a window object.
        try {
          // This will throw if `originalTarget` is not a window
          // object, or if it is an opaque cross-origin window.
          originalTargetDocument$LWS = ReflectApply$1$LWS(WindowDocumentGetter$LWS, originalTarget$LWS, []);
          originalTargetWindow$LWS = originalTarget$LWS;
        } catch (_unused39$LWS) {
          try {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (ReflectApply$1$LWS(WindowLocationGetter$LWS, originalTarget$LWS, [])) {
              createOpaqueChildWindowSandboxRecord$LWS({
                globalObject: originalTarget$LWS,
                key: __key$LWS,
                type: _type$LWS
              }, top$LWS);
              return originalTarget$LWS;
            } // eslint-disable-next-line no-empty

          } catch (_unused40$LWS) {}
        } // Check if originalTarget is a document and get its defaultView.

      } else if ('defaultView' in originalTarget$LWS) {
        // If the object doesn't appear to be a window, same or
        // cross-origin, then it may be a document for window that we
        // haven't seen yet, but can safely check non-cross-origin-safe
        // properties of, specifically `defaultView` which will give us
        // a window if one exists.
        let _defaultView$LWS;

        try {
          // This will throw if `originalTarget` is not a document object.
          _defaultView$LWS = ReflectApply$1$LWS(DocumentProtoDefaultViewGetter$LWS, originalTarget$LWS, []); // eslint-disable-next-line no-empty
        } catch (_unused41$LWS) {}

        if (_defaultView$LWS) {
          originalTargetDocument$LWS = originalTarget$LWS;
          originalTargetWindow$LWS = _defaultView$LWS;
        }
      }

      if (originalTargetWindow$LWS) {
        createChildWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: originalTargetDocument$LWS,
          globalObject: originalTargetWindow$LWS,
          key: __key$LWS,
          type: _type$LWS
        }, top$LWS);
      }

      return originalTarget$LWS;
    },

    endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ? // Normalize the descriptors of the provided endowments object,
    // and the default endowments descriptors so they can be
    // accessible from inside the sandbox.
    ObjectAssign$1$LWS({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, ObjectGetOwnPropertyDescriptors$LWS(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
    instrumentation: verboseInstrumentation$LWS ? instrumentation$LWS : undefined,
    // Flag whether the iframe should remain connected to DOM.
    keepAlive: false,
    liveTargetCallback: isTargetLive$LWS
  });
  return _sourceText$LWS => env$LWS.evaluate(_sourceText$LWS);
}

function getDistortionFactories$LWS(_record$LWS) {
  const {
    document: _document$LWS,
    globalObject: _globalObject$LWS,
    type: _type$LWS
  } = _record$LWS;
  let _factories$LWS = documentToDistortionFactoriesMap$LWS.get(_document$LWS);

  if (_factories$LWS === undefined) {
    const {
      Document: _Document$LWS,
      Element: _Element$LWS,
      HTMLElement: _HTMLElement$LWS,
      HTMLIFrameElement: _HTMLIFrameElement$LWS,
      HTMLScriptElement: _HTMLScriptElement$LWS,
      SVGElement: _SVGElement$LWS,
      XSLTProcessor: XSLTProcessor$LWS
    } = _globalObject$LWS;
    const initializers$LWS = _type$LWS === 1
    /* SandboxType.Internal */
    ? ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, internalKeyedDistortionFactoryInitializers$LWS) : ArrayConcat$LWS(externalDistortionFactoryInitializers$LWS, externalKeyedDistortionFactoryInitializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLElement$LWS, 'HTMLElement', HTMLElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLIFrameElement$LWS, 'HTMLIFrameElement', HTMLIFrameElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLScriptElement$LWS, 'HTMLScriptElement', HTMLScriptElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_SVGElement$LWS, 'SVGElement', SVGElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, CustomElementRegistry.prototype, CustomElementRegistryBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Document$LWS.prototype, DocumentBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Element$LWS.prototype, ElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS, initializers$LWS); // istanbul ignore else: this is a safety precaution that is unreachable via tests

    if (typeof XSLTProcessor$LWS === 'function') {
      createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS, initializers$LWS);
    } // Reuse the `initializers` array as the `factories` array.


    _factories$LWS = initializers$LWS;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = _factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = initializers$LWS[_i$LWS](_record$LWS);
    }

    documentToDistortionFactoriesMap$LWS.set(_document$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getEvaluationDistortionFactories$LWS(_record$LWS) {
  const {
    document: _document$LWS
  } = _record$LWS;
  let _factories$LWS = documentToEvaluationDistortionFactoriesMap$LWS.get(_document$LWS);

  if (_factories$LWS === undefined) {
    const {
      length: _length$LWS
    } = evaluationDistortionFactoryInitializers$LWS;
    _factories$LWS = Array(_length$LWS);

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = evaluationDistortionFactoryInitializers$LWS[_i$LWS](_record$LWS);
    }

    documentToEvaluationDistortionFactoriesMap$LWS.set(_document$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getOpaqueDistortionFactories$LWS(_record$LWS) {
  const {
    globalObject: _globalObject$LWS
  } = _record$LWS;
  let _factories$LWS = opaqueToDistortionFactoriesMap$LWS.get(_globalObject$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (_factories$LWS === undefined) {
    const {
      length: _length$LWS
    } = opaqueDistortionFactoryInitializers$LWS;
    _factories$LWS = Array(_length$LWS);

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = opaqueDistortionFactoryInitializers$LWS[_i$LWS](_record$LWS);
    }

    opaqueToDistortionFactoriesMap$LWS.set(_globalObject$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getOpaqueSandboxRegistry$LWS(_globalObject$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = opaqueToSandboxRegistry$LWS.get(_globalObject$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    opaqueToSandboxRegistry$LWS.set(_globalObject$LWS, sandboxRegistry$LWS);
  }

  return sandboxRegistry$LWS;
}

function getSandboxRegistry$LWS(_document$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = documentToSandboxRegistry$LWS.get(_document$LWS);

  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxRegistry$LWS.set(_document$LWS, sandboxRegistry$LWS);
  }

  return sandboxRegistry$LWS;
}

function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
  const {
    document: _document$LWS,
    context: _context$LWS,
    endowments: endowments$LWS,
    globalObject: _globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: source$LWS,
    sourceType: sourceType$LWS,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = evaluateOptions$LWS;

  if (typeof __key$LWS !== 'string') {
    throw new LockerSecurityError$LWS('Invalid sandbox key.');
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    helpers: helpers$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  } = _globalObject$LWS === selfWindow$LWS ? createWindowSandboxRecord$LWS({
    context: _context$LWS,
    endowments: endowments$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  }) : createChildWindowSandboxRecord$LWS({
    context: _context$LWS,
    document: _document$LWS,
    globalObject: _globalObject$LWS,
    key: __key$LWS,
    type: _type$LWS
  }); // Setting the context before evaluating the sourceText so compiled code
  // can wire up import/exports from both sides of the membrane.

  if (_context$LWS !== EMPTY_OBJECT$LWS) {
    setEvalContext$LWS(_context$LWS);
  }

  setEvalHelpers$LWS(helpers$LWS);
  let _result$LWS;
  const _sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
  const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
  let activity$LWS; // istanbul ignore else: this is a safety precaution that is unreachable via tests

  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
    activity$LWS = startActivity$LWS('evaluateInSandbox', BASIC_INSTRUMENTATION_DATA$LWS);
  }

  try {
    // Protecting against errors during evaluation can guarantee the state
    // of the EvalContext to avoid leaking context values
    _result$LWS = virtualEnvironmentEvaluator$LWS(_sourceText$LWS);
  } catch (error) {
    // istanbul ignore if: this is a safety precaution that is unreachable via tests
    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
      activity$LWS.error({
        sandboxKey: __key$LWS,
        error
      });
    }

    throw error;
  } finally {
    clearEvalContext$LWS();
    clearEvalHelpers$LWS();
  } // istanbul ignore else: this is a safety precaution that is unreachable via tests


  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
    activity$LWS.stop();
  }

  return _result$LWS;
}

function proxyWrapFunctionDistortion$LWS({
  BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
  LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
  LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS
}, factoryName$LWS, originalFunc$LWS, distortedFunc$LWS) {
  const activityName$LWS = LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? factoryName$LWS ? ReflectApply$1$LWS(StringProtoReplace$LWS, factoryName$LWS, [LOCKER_IDENTIFIER_MARKER$LWS, '']) :
  /* istanbul ignore next: currently unreachable via tests */
  '<unknown>' : undefined;
  const startActivity$LWS = LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
  const _proxy$LWS = new ProxyCtor$LWS(originalFunc$LWS, ObjectFreeze$1$LWS({
    apply(__target$LWS, thisArg$LWS, _args$LWS) {
      // istanbul ignore if: this is a safety precaution that is unreachable via tests
      if (thisArg$LWS === _proxy$LWS) {
        thisArg$LWS = distortedFunc$LWS;
      }

      let activity$LWS; // istanbul ignore if: this is a safety precaution that is unreachable via tests

      if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
      }

      try {
        return ReflectApply$1$LWS(distortedFunc$LWS, thisArg$LWS, _args$LWS);
      } catch (error) {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error({
            sandboxKey: __key$LWS,
            error
          });
        }

        throw error;
      } finally {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
      }
    },

    construct(__target$LWS, _args$LWS, newTarget$LWS) {
      // istanbul ignore else: no non-matching path found via tests
      if (newTarget$LWS === _proxy$LWS) {
        newTarget$LWS = distortedFunc$LWS;
      }

      let activity$LWS; // istanbul ignore if: this is a safety precaution that is unreachable via tests

      if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
      }

      try {
        return ReflectConstruct$LWS(distortedFunc$LWS, _args$LWS, newTarget$LWS);
      } catch (error) {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error({
            sandboxKey: __key$LWS,
            error
          });
        }

        throw error;
      } finally {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
      }
    }

  }));
  return _proxy$LWS;
}

function setEvalContext$LWS(evalContext$LWS) {
  lockerEvalContextValue$LWS = evalContext$LWS;
}

function setEvalHelpers$LWS(evalHelpers$LWS) {
  lockerEvalHelpersValue$LWS = evalHelpers$LWS;
}

function toSourceText$LWS(__value$LWS, sourceType$LWS) {
  let _sourceText$LWS = typeof __value$LWS === 'function' ? extractFunctionBodySource$LWS(__value$LWS) : toString$LWS(__value$LWS); // We workaround bundlers, like Rollup, aggressively stripping inline source
  // maps by compiling them with the name "sandboxMappingURL". At runtime the
  // name is changed so the inline source map is registered.

  _sourceText$LWS = ReflectApply$1$LWS(StringProtoReplace$LWS, _sourceText$LWS, [// This regexp looks involved, but it prevents browsers and developer
  // tools from mistaking the regexp or the replacement string for an
  // actual source mapping URL.
  /\/\/# sandbox(?=MappingURL=.*?\s*$)/, '//# source']);
  return sourceType$LWS === 1
  /* SourceType.Module */
  && indexOfPragma$LWS(_sourceText$LWS, 'use strict') === -1 ? // Append "'use strict'" to the extracted function body so it is
  // evaluated in strict mode.
  `'use strict';${_sourceText$LWS}` : _sourceText$LWS;
}

function evaluateInCoreSandbox$LWS(__key$LWS, source$LWS, _context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  return internalEvaluateInSandbox$LWS({
    context: _context$LWS,
    document: selfDocument$LWS,
    endowments: endowments$LWS,
    globalObject: selfWindow$LWS,
    instrumentation: instrumentation$LWS,
    key: CORE_SANDBOX_KEY$LWS,
    source: source$LWS,
    sourceType: 1
    /* SourceType.Module */
    ,
    type: 1
    /* SandboxType.Internal */
    ,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}

function evaluateInSandbox$LWS(__key$LWS, source$LWS, _context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  return internalEvaluateInSandbox$LWS({
    context: _context$LWS,
    document: selfDocument$LWS,
    endowments: endowments$LWS,
    globalObject: selfWindow$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: source$LWS,
    sourceType: 1
    /* SourceType.Module */
    ,
    type: 0
    /* SandboxType.External */
    ,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}

export { CORE_SANDBOX_KEY$LWS as CORE_SANDBOX_KEY, evaluateInCoreSandbox$LWS as evaluateInCoreSandbox, evaluateInSandbox$LWS as evaluateInSandbox };
