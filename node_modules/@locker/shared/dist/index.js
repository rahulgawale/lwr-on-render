/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
var _URLCtor$prototype$LWS;

const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  get: ReflectGet$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  has: ReflectHas$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
};

function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
}

const SymbolCtor$LWS = Symbol;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = SymbolCtor$LWS;
const {
  toString: SymbolProtoToString$LWS,
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  find: ArrayProtoFind$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  some: ArrayProtoSome$LWS,
  splice: ArrayProtoSplice$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  filter: ArrayProtoFilter$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  push: ArrayProtoPush$LWS,
  shift: ArrayProtoShift$LWS,
  slice: ArrayProtoSlice$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);

  for (let i$LWS = 0, {
    length: length$LWS
  } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];

    if (ArrayIsArray$LWS(value$LWS)) {
      ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, value$LWS);
    } else {
      result$LWS[result$LWS.length] = value$LWS;
    }
  }

  return result$LWS;
}

function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength'); // https://caniuse.com/bigint

const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf :
/* istanbul ignore next: currently unreachable via tests */
undefined;
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;
const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore next

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const CHAR_ELLIPSIS$LWS = '\u2026';
const CHAR_QUOTE_DOUBLE$LWS = '"';
const CHAR_QUOTE_SINGLE$LWS = "'";
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_ERROR$LWS = '[object Error]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  now: DateNow$LWS
} = DateCtor$LWS;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  bind: FunctionProtoBind$LWS,
  toString: FunctionProtoToString$LWS
} = Function.prototype;

function alwaysNull$LWS() {
  return null;
}

function noop$LWS() {// No operation performed.
}

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');

function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
  return map$LWS;
}

const NumberCtor$LWS = Number;
const {
  prototype: NumberProto$LWS
} = NumberCtor$LWS;
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS
} = NumberCtor$LWS;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberProto$LWS;
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  endsWith: StringProtoEndsWith$LWS,
  includes: StringProtoIncludes$LWS,
  indexOf: StringProtoIndexOf$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const QUOTE_CHAR_REG_EXP_MAP$LWS = {
  __proto__: null,
  [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
  [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
};
const URLCtor$LWS = typeof URL === 'function' ? URL :
/* istanbul ignore next: unreachable in test env */
undefined; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

const URLProtoToString$LWS = URLCtor$LWS == null ? void 0 : (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString; // To extract the function body start the match from the beginning of the
// source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
// matches everything including newlines where as `.` matches everything except
// newlines. Next, continue matching past the opening left curly bracket of the
// function and beyond optional whitespace and newline. Finally, capture the
// function body up to, but not including, optional newline and whitespace by
// the closing right curly bracket at the end of the source code. The alternate
// pattern matches arrow functions without brackets.

const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (length$LWS) {
    const upper$LWS = ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS[0], []);
    return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [1]);
  }

  return '';
}

function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
  return quoteChar$LWS + ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [QUOTE_CHAR_REG_EXP_MAP$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
}

function extractFunctionBodySource$LWS(func$LWS) {
  var _ref$LWS, _match$$LWS;

  const source$LWS = ReflectApply$LWS(FunctionProtoToString$LWS, func$LWS, []);
  const match$LWS = ReflectApply$LWS(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]); // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

  return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
} // Use `toString()` to coerce values using the default string concatenation
// operation.


function toString$LWS(value$LWS) {
  return typeof value$LWS === 'string' ? value$LWS : // Attempt to coerce `value` to a string with the ToString operation.
  // Section 7.1.17 ToString ( argument )
  // https://tc39.es/ecma262/#sec-tostring
  `${value$LWS}`;
} // Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.


function toSafeTemplateStringValue$LWS(value$LWS) {
  if (typeof value$LWS === 'string') {
    return value$LWS;
  }

  try {
    if (typeof value$LWS === 'function') {
      return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
    }

    if (typeof value$LWS === 'object' && value$LWS !== null) {
      if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
        return ReflectApply$LWS(URLProtoToString$LWS, value$LWS, []);
      }

      const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
      return result$LWS === TO_STRING_BRAND_SYMBOL$LWS ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
    }

    if (typeof value$LWS === 'symbol') {
      return ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []);
    } // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value


    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}

  return '[object Unknown]';
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  exec: RegExpProtoExec$LWS,
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  clear: SetProtoClear$LWS,
  delete: SetProtoDelete$LWS,
  entries: SetProtoEntries$LWS,
  forEach: SetProtoForEach$LWS,
  has: SetProtoHas$LWS,
  keys: SetProtoKeys$LWS,
  [SymbolIterator$LWS]: SetProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: SetProtoSymbolToStringTag$LWS
} = SetProto$LWS;
const {
  add: SetProtoAdd$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');

function toSafeSet$LWS(set$LWS) {
  ReflectSetPrototypeOf$LWS(set$LWS, null);
  set$LWS.add = SetProtoAdd$LWS;
  set$LWS.clear = SetProtoClear$LWS;
  set$LWS.delete = SetProtoDelete$LWS;
  set$LWS.entries = SetProtoEntries$LWS;
  set$LWS.forEach = SetProtoForEach$LWS;
  set$LWS.has = SetProtoHas$LWS;
  set$LWS.keys = SetProtoKeys$LWS;
  ReflectDefineProperty$LWS(set$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: SetProtoSizeGetter$LWS,
    set: undefined
  });
  set$LWS.values = SetProtoValues$LWS;
  set$LWS[SymbolIterator$LWS] = SetProtoSymbolIterator$LWS;
  set$LWS[SymbolToStringTag$LWS] = SetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(set$LWS, SetProto$LWS);
  return set$LWS;
}

const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  has: WeakMapProtoHas$LWS
} = WeakMapProto$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;

function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}

const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;

function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol; // Regular expressions from Acorn:
//     acorn/src/parseutil.js
//     acorn/src/whitespace.js

const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;

function getBrandByTrialAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  //
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value$LWS) {
      ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused3$LWS) {} // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.


  try {
    if ('toLocaleDateString' in value$LWS) {
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_DATE$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused4$LWS) {} // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).


  try {
    if ('get' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused5$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.


  try {
    if (ObjectHasOwn$LWS(value$LWS, 'lastIndex')) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_REG_EXP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused6$LWS) {} // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).


  try {
    if ('add' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused7$LWS) {} // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).


  try {
    if ('get' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused8$LWS) {} // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).


  try {
    if ('add' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused9$LWS) {} // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.


  try {
    if ('toPrecision' in value$LWS) {
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_NUMBER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {} // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.


  try {
    if (ObjectHasOwn$LWS(value$LWS, 'length')) {
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_STRING$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused11$LWS) {} // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.


  try {
    if ('description' in value$LWS) {
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_SYMBOL$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused12$LWS) {} // istanbul ignore else: All platforms that LWS runs tests in support BigInt


  if (SUPPORTS_BIG_INT$LWS) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BIG_INT$LWS; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  try {
    // Section 20.3.3 Properties of the Boolean Prototype Object
    // https://tc39.es/ecma262/#thisbooleanvalue
    // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    //     a. Let b be value.[[BooleanData]].
    //     b. Assert: Type(b) is Boolean.
    ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
    return TO_STRING_BRAND_BOOLEAN$LWS; // eslint-disable-next-line no-empty
  } catch (_unused14$LWS) {} // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
}

const getTimestamp$LWS = typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : ReflectApply$LWS(FunctionProtoBind$LWS, performance.now, [performance]); // Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js

function indexOfPragma$LWS(source$LWS, pragma$LWS) {
  let pos$LWS = 0; // eslint-disable-next-line no-constant-condition

  while (true) {
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    const stringLiteralMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS(StringProtoSlice$LWS, source$LWS, [pos$LWS])]);

    if (stringLiteralMatch$LWS === null) {
      return -1;
    }

    if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
      const spaceAfterMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
      const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
      const nextChar$LWS = source$LWS[end$LWS];

      if (nextChar$LWS === ';' || nextChar$LWS === '}') {
        return pos$LWS;
      }

      const indexAfterNext$LWS = end$LWS + 1;

      if (ReflectApply$LWS(RegExpProtoTest$LWS, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS(RegExpProtoTest$LWS, expressionCharRegExp$LWS, [nextChar$LWS]))) {
        return pos$LWS;
      }
    }

    pos$LWS += stringLiteralMatch$LWS[0].length; // Skip semicolon, if any.

    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;

    if (source$LWS[pos$LWS] === ';') {
      pos$LWS += 1;
    }
  }
}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }

  return false;
}

const SEEN_OBJECTS_MAP$LWS = toSafeMap$LWS(new MapCtor$LWS());

function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(MapProtoSet$LWS, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneSerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = ReflectApply$LWS(SetProtoValues$LWS, set$LWS, []); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(SetProtoAdd$LWS, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ReflectApply$LWS(ArrayProtoShift$LWS, queue$LWS, []); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = SEEN_OBJECTS_MAP$LWS.get(originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = getBrand$LWS(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS(originalValue$LWS);

          if (proto$LWS === ObjectProto$LWS || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = ArrayCtor$LWS(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!isNearMembrane$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN$LWS: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER$LWS: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT$LWS: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING$LWS:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused15$LWS) {}

  SEEN_OBJECTS_MAP$LWS.clear();
  return result$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
} // Used by '@locker/near-membrane-base'


const ErrorCtor$LWS = Error; // Used by '@locker/near-membrane-' packages.

const TypeErrorCtor$LWS = TypeError;

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const trackedLiveTargets$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS()); // This is used by packages/locker-core-engine/src/LockerFilter.js

const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS('@@lockerLiveValue');

function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0
/* TargetTraits.None */
) {
  if (targetTraits$LWS & 1
  /* TargetTraits.IsArray */
  || targetTraits$LWS & 2
  /* TargetTraits.IsArrayBufferView */
  || targetTraits$LWS & 64
  /* TargetTraits.Revoked */
  || target$LWS === null || target$LWS === undefined || target$LWS === ObjectProto$LWS || target$LWS === RegExpProto$LWS) {
    return false;
  }

  if (typeof target$LWS === 'function') {
    try {
      return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS); // eslint-disable-next-line no-empty
    } catch (_unused16$LWS) {}

    return false;
  }

  if (typeof target$LWS === 'object') {
    try {
      if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused17$LWS) {}

    let constructor$LWS;

    try {
      ({
        constructor: constructor$LWS
      } = target$LWS);

      if (constructor$LWS === ObjectCtor$LWS) {
        // If the constructor, own or inherited, points to `Object`
        // then `target` is not likely a prototype object.
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused18$LWS) {}

    try {
      if (ReflectGetPrototypeOf$LWS(target$LWS) === null && ( // Ensure `target` is not an `Object.prototype` from an iframe.
      typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== target$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused19$LWS) {}

    if (targetTraits$LWS === 0
    /* TargetTraits.None */
    ) {
      try {
        if (ArrayIsArray$LWS(target$LWS)) {
          return true;
        }
      } catch (_unused20$LWS) {
        // The target is a revoked proxy.
        return false;
      }

      if (ArrayBufferIsView$LWS(target$LWS)) {
        return true;
      }
    } // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.


    try {
      if (ObjectHasOwn$LWS(target$LWS, 'lastIndex')) {
        ReflectApply$LWS(RegExpProtoSourceGetter$LWS, target$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused21$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).


    try {
      if ('byteLength' in target$LWS) {
        ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused22$LWS) {}
  }

  return false;
}

function markTargetAsLive$LWS(target$LWS) {
  if ((typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') && !isTargetLive$LWS(target$LWS)) {
    ReflectDefineProperty$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS, {
      __proto__: null,
      value: undefined
    });
  }

  return target$LWS;
}

function trackTargetAsLive$LWS(target$LWS) {
  trackedLiveTargets$LWS.add(target$LWS);
  return target$LWS;
}

const {
  min: MathMin$LWS
} = Math;
const PREFIX_HEAD$LWS = 'LSKey-';
const PREFIX_TAIL$LWS = '$';

function getNamespacePrefix$LWS(namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
}

function isNamespacePrefixed$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [`${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`]);
}

function prefixNamespace$LWS(key$LWS, namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}${key$LWS}`;
}

function unprefixNamespace$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const prefix$LWS = `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
    return ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [prefix$LWS]) ? ReflectApply$LWS(StringProtoSlice$LWS, key$LWS, [prefix$LWS.length]) : key$LWS;
  }

  return '';
}

const PromiseCtor$LWS = Promise;
const {
  catch: PromiseProtoCatch$LWS,
  then: PromiseProtoThen$LWS
} = PromiseCtor$LWS.prototype;
const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
const ProxyCtor$LWS = Proxy;
const {
  revocable: ProxyRevocable$LWS
} = ProxyCtor$LWS;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}

export { ArrayBufferIsView$LWS as ArrayBufferIsView, ArrayBufferProtoByteLengthGetter$LWS as ArrayBufferProtoByteLengthGetter, ArrayConcat$LWS as ArrayConcat, ArrayCtor$LWS as ArrayCtor, ArrayIsArray$LWS as ArrayIsArray, ArrayProtoFilter$LWS as ArrayProtoFilter, ArrayProtoIncludes$LWS as ArrayProtoIncludes, ArrayProtoIndexOf$LWS as ArrayProtoIndexOf, ArrayProtoJoin$LWS as ArrayProtoJoin, ArrayProtoPush$LWS as ArrayProtoPush, ArrayProtoShift$LWS as ArrayProtoShift, ArrayProtoSlice$LWS as ArrayProtoSlice, ArrayProtoSort$LWS as ArrayProtoSort, ArrayProtoUnshift$LWS as ArrayProtoUnshift, BigIntProtoValueOf$LWS as BigIntProtoValueOf, BooleanProtoValueOf$LWS as BooleanProtoValueOf, CHAR_ELLIPSIS$LWS as CHAR_ELLIPSIS, CHAR_QUOTE_DOUBLE$LWS as CHAR_QUOTE_DOUBLE, CHAR_QUOTE_SINGLE$LWS as CHAR_QUOTE_SINGLE, DateNow$LWS as DateNow, DateProtoValueOf$LWS as DateProtoValueOf, ErrorCtor$LWS as ErrorCtor, FunctionProtoBind$LWS as FunctionProtoBind, FunctionProtoToString$LWS as FunctionProtoToString, JSONParse$LWS as JSONParse, JSONStringify$LWS as JSONStringify, LOCKER_IDENTIFIER_MARKER$LWS as LOCKER_IDENTIFIER_MARKER, LOCKER_UNMINIFIED_FLAG$LWS as LOCKER_UNMINIFIED_FLAG, LockerSecurityError$LWS as LockerSecurityError, MapCtor$LWS as MapCtor, MapProtoEntries$LWS as MapProtoEntries, MapProtoSet$LWS as MapProtoSet, MapProtoSizeGetter$LWS as MapProtoSizeGetter, MathMin$LWS as MathMin, NumberIsFinite$LWS as NumberIsFinite, NumberIsInteger$LWS as NumberIsInteger, NumberProtoToFixed$LWS as NumberProtoToFixed, NumberProtoValueOf$LWS as NumberProtoValueOf, ObjectAssign$LWS as ObjectAssign, ObjectCtor$LWS as ObjectCtor, ObjectFreeze$LWS as ObjectFreeze, ObjectGetOwnPropertyDescriptors$LWS as ObjectGetOwnPropertyDescriptors, ObjectGetOwnPropertySymbols$LWS as ObjectGetOwnPropertySymbols, ObjectHasOwn$LWS as ObjectHasOwn, ObjectKeys$LWS as ObjectKeys, ObjectLookupOwnGetter$LWS as ObjectLookupOwnGetter, ObjectLookupOwnSetter$LWS as ObjectLookupOwnSetter, ObjectLookupOwnValue$LWS as ObjectLookupOwnValue, ObjectPreventExtensions$LWS as ObjectPreventExtensions, ObjectProto$LWS as ObjectProto, ObjectProtoToString$LWS as ObjectProtoToString, PromiseProtoCatch$LWS as PromiseProtoCatch, PromiseProtoThen$LWS as PromiseProtoThen, PromiseReject$LWS as PromiseReject, PromiseResolve$LWS as PromiseResolve, ProxyCtor$LWS as ProxyCtor, ProxyRevocable$LWS as ProxyRevocable, ReflectApply$LWS as ReflectApply, ReflectConstruct$LWS as ReflectConstruct, ReflectDefineProperty$LWS as ReflectDefineProperty, ReflectDeleteProperty$LWS as ReflectDeleteProperty, ReflectGet$LWS as ReflectGet, ReflectGetOwnPropertyDescriptor$LWS as ReflectGetOwnPropertyDescriptor, ReflectGetPrototypeOf$LWS as ReflectGetPrototypeOf, ReflectHas$LWS as ReflectHas, ReflectOwnKeys$LWS as ReflectOwnKeys, ReflectSet$LWS as ReflectSet, ReflectSetPrototypeOf$LWS as ReflectSetPrototypeOf, RegExpCtor$LWS as RegExpCtor, RegExpProto$LWS as RegExpProto, RegExpProtoExec$LWS as RegExpProtoExec, RegExpProtoSourceGetter$LWS as RegExpProtoSourceGetter, RegExpProtoTest$LWS as RegExpProtoTest, SANDBOX_EVAL_CONTEXT_NAME$LWS as SANDBOX_EVAL_CONTEXT_NAME, SANDBOX_EVAL_HELPERS_NAME$LWS as SANDBOX_EVAL_HELPERS_NAME, SUPPORTS_BIG_INT$LWS as SUPPORTS_BIG_INT, SYMBOL_LIVE_OBJECT$LWS as SYMBOL_LIVE_OBJECT, SetCtor$LWS as SetCtor, SetProtoAdd$LWS as SetProtoAdd, SetProtoSizeGetter$LWS as SetProtoSizeGetter, SetProtoValues$LWS as SetProtoValues, StringCtor$LWS as StringCtor, StringProtoEndsWith$LWS as StringProtoEndsWith, StringProtoIncludes$LWS as StringProtoIncludes, StringProtoIndexOf$LWS as StringProtoIndexOf, StringProtoMatch$LWS as StringProtoMatch, StringProtoReplace$LWS as StringProtoReplace, StringProtoSlice$LWS as StringProtoSlice, StringProtoSplit$LWS as StringProtoSplit, StringProtoStartsWith$LWS as StringProtoStartsWith, StringProtoToLowerCase$LWS as StringProtoToLowerCase, StringProtoToUpperCase$LWS as StringProtoToUpperCase, StringProtoValueOf$LWS as StringProtoValueOf, SymbolFor$LWS as SymbolFor, SymbolIterator$LWS as SymbolIterator, SymbolProtoToString$LWS as SymbolProtoToString, SymbolProtoValueOf$LWS as SymbolProtoValueOf, SymbolToStringTag$LWS as SymbolToStringTag, SymbolUnscopables$LWS as SymbolUnscopables, TO_STRING_BRAND_ARRAY$LWS as TO_STRING_BRAND_ARRAY, TO_STRING_BRAND_ARRAY_BUFFER$LWS as TO_STRING_BRAND_ARRAY_BUFFER, TO_STRING_BRAND_BIG_INT$LWS as TO_STRING_BRAND_BIG_INT, TO_STRING_BRAND_BOOLEAN$LWS as TO_STRING_BRAND_BOOLEAN, TO_STRING_BRAND_DATE$LWS as TO_STRING_BRAND_DATE, TO_STRING_BRAND_ERROR$LWS as TO_STRING_BRAND_ERROR, TO_STRING_BRAND_FUNCTION$LWS as TO_STRING_BRAND_FUNCTION, TO_STRING_BRAND_MAP$LWS as TO_STRING_BRAND_MAP, TO_STRING_BRAND_NULL$LWS as TO_STRING_BRAND_NULL, TO_STRING_BRAND_NUMBER$LWS as TO_STRING_BRAND_NUMBER, TO_STRING_BRAND_OBJECT$LWS as TO_STRING_BRAND_OBJECT, TO_STRING_BRAND_REG_EXP$LWS as TO_STRING_BRAND_REG_EXP, TO_STRING_BRAND_SET$LWS as TO_STRING_BRAND_SET, TO_STRING_BRAND_STRING$LWS as TO_STRING_BRAND_STRING, TO_STRING_BRAND_SYMBOL$LWS as TO_STRING_BRAND_SYMBOL, TO_STRING_BRAND_UNDEFINED$LWS as TO_STRING_BRAND_UNDEFINED, TO_STRING_BRAND_WEAK_MAP$LWS as TO_STRING_BRAND_WEAK_MAP, TO_STRING_BRAND_WEAK_SET$LWS as TO_STRING_BRAND_WEAK_SET, TypeErrorCtor$LWS as TypeErrorCtor, UNCOMPILED_LOCATION_NAME$LWS as UNCOMPILED_LOCATION_NAME, UNCOMPILED_TOP_NAME$LWS as UNCOMPILED_TOP_NAME, WEBPACK_REQUIRE_NAME$LWS as WEBPACK_REQUIRE_NAME, WeakMapCtor$LWS as WeakMapCtor, WeakMapProtoHas$LWS as WeakMapProtoHas, WeakSetCtor$LWS as WeakSetCtor, WeakSetProtoHas$LWS as WeakSetProtoHas, alwaysNull$LWS as alwaysNull, capitalizeFirstChar$LWS as capitalizeFirstChar, consoleWarn$LWS as consoleWarn, createRevokedProxy$LWS as createRevokedProxy, enquote$LWS as enquote, escapeRegExp$LWS as escapeRegExp, extractFunctionBodySource$LWS as extractFunctionBodySource, getBrand$LWS as getBrand, getNamespacePrefix$LWS as getNamespacePrefix, getNearMembraneSerializedValue$LWS as getNearMembraneSerializedValue, getTimestamp$LWS as getTimestamp, indexOfPragma$LWS as indexOfPragma, isConvertibleToString$LWS as isConvertibleToString, isNamespacePrefixed$LWS as isNamespacePrefixed, isNearMembrane$LWS as isNearMembrane, isObject$LWS as isObject, isObjectLike$LWS as isObjectLike, isTargetLive$LWS as isTargetLive, markTargetAsLive$LWS as markTargetAsLive, noop$LWS as noop, partialStructuredClone$LWS as partialStructuredClone, prefixNamespace$LWS as prefixNamespace, shallowCloneArray$LWS as shallowCloneArray, shallowCloneOptions$LWS as shallowCloneOptions, toSafeArray$LWS as toSafeArray, toSafeMap$LWS as toSafeMap, toSafeSet$LWS as toSafeSet, toSafeTemplateStringValue$LWS as toSafeTemplateStringValue, toSafeWeakMap$LWS as toSafeWeakMap, toSafeWeakSet$LWS as toSafeWeakSet, toString$LWS as toString, trackTargetAsLive$LWS as trackTargetAsLive, unprefixNamespace$LWS as unprefixNamespace };
/*! version: 0.17.9 */
