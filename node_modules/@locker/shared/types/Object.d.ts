import type { Getter, Setter } from './types';
export declare const ObjectCtor: ObjectConstructor;
export declare const ObjectAssign: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
}, ObjectFreeze: {
    <T>(a: T[]): readonly T[];
    <T_1 extends Function>(f: T_1): T_1;
    <T_2 extends {
        [idx: string]: object | U | null | undefined;
    }, U extends string | number | bigint | boolean | symbol>(o: T_2): Readonly<T_2>;
    <T_3>(o: T_3): Readonly<T_3>;
}, ObjectGetOwnPropertyDescriptors: <T>(o: T) => { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
    [x: string]: PropertyDescriptor;
}, ObjectGetOwnPropertySymbols: (o: any) => symbol[], ObjectKeys: {
    (o: object): string[];
    (o: {}): string[];
}, ObjectPreventExtensions: <T>(o: T) => T, ObjectProto: Object;
export declare const ObjectProtoToString: () => string;
export declare function isObject(value: any): boolean;
export declare function isObjectLike(value: any): boolean;
export declare const ObjectHasOwn: (object: any, key: PropertyKey) => boolean;
export declare function ObjectLookupOwnGetter(object: any, key: PropertyKey): Getter | undefined;
export declare function ObjectLookupOwnSetter(object: any, key: PropertyKey): Setter | undefined;
export declare function ObjectLookupOwnValue(object: any, key: PropertyKey): any;
//# sourceMappingURL=Object.d.ts.map