/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { ObjectLookupOwnGetter as ObjectLookupOwnGetter$LWS, ReflectGetOwnPropertyDescriptor as ReflectGetOwnPropertyDescriptor$LWS, PromiseResolve as PromiseResolve$LWS, ReflectApply as ReflectApply$LWS, PromiseProtoThen as PromiseProtoThen$LWS, PromiseProtoCatch as PromiseProtoCatch$LWS, ObjectHasOwn as ObjectHasOwn$LWS, toSafeWeakMap as toSafeWeakMap$LWS, WeakMapCtor as WeakMapCtor$LWS, ObjectLookupOwnSetter as ObjectLookupOwnSetter$LWS, RegExpCtor as RegExpCtor$LWS, escapeRegExp as escapeRegExp$LWS, SANDBOX_EVAL_CONTEXT_NAME as SANDBOX_EVAL_CONTEXT_NAME$LWS, WEBPACK_REQUIRE_NAME as WEBPACK_REQUIRE_NAME$LWS, RegExpProtoTest as RegExpProtoTest$LWS, StringProtoReplace as StringProtoReplace$LWS, ArrayProtoJoin as ArrayProtoJoin$LWS, indexOfPragma as indexOfPragma$LWS, StringProtoSlice as StringProtoSlice$LWS, UNCOMPILED_LOCATION_NAME as UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME as UNCOMPILED_TOP_NAME$LWS } from '@locker/shared';
const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
const selfDocument$LWS = document;
const {
  prototype: DocumentProto$LWS
} = Document; // Used by '@locker/near-membrane/dom'.

const {
  close: DocumentProtoClose$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'implementation');
const {
  prototype: ElementProto$LWS
} = Element; // Used by '@locker/near-membrane-dom'.

const {
  remove: ElementProtoRemove$LWS
} = ElementProto$LWS;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(ElementProto$LWS, 'namespaceURI');
const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'firstChild'); // Used by '@locker/near-membrane-dom'.

const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'ownerDocument');
const selfWindow$LWS = window;
const {
  setTimeout: WindowSetTimeout$LWS
} = selfWindow$LWS; // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  setInterval: WindowSetInterval$LWS
} = selfWindow$LWS;

const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = selfWindow$LWS; // istanbul ignore else

  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  } // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = PromiseResolve$LWS();
    promise$LWS = ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
    ReflectApply$LWS(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();

const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(selfWindow$LWS, 'document');
const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS(selfWindow$LWS, 'frameElement');
const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS(selfWindow$LWS, 'length');
const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS(selfWindow$LWS, 'location');

function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      ReflectApply$LWS(WindowLocationGetter$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
}
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class Validator$LWS {
  constructor(globalObject$LWS, document$LWS = globalObject$LWS.document) {
    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoBodyGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, this._document, []);

    const {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    } = globalObject$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template']),
      right: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template'])
    };
  }

}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;

  if (ReflectApply$LWS(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}

const selfValidator$LWS = new Validator$LWS(selfWindow$LWS, selfDocument$LWS);
const documentToValidatorMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS([[selfDocument$LWS, selfValidator$LWS]]));

function getValidator$LWS(globalObject$LWS, document$LWS = globalObject$LWS == null ? void 0 : globalObject$LWS.document) {
  // Fast path validator lookup for top level window.
  if (globalObject$LWS === undefined || globalObject$LWS === selfWindow$LWS) {
    return selfValidator$LWS;
  } // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.


  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(globalObject$LWS, document$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }

  return validator$LWS;
}

const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'type');
const {
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenList.prototype, 'value');
const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS(Event.prototype, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;
const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'protocol');
const {
  prototype: HTMLElementProto$LWS
} = HTMLElement;
const HTMLElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElementProto$LWS, 'dataset'); // Used by '@locker/near-membrane-dom'.

const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElementProto$LWS, 'style');
const {
  prototype: HTMLIFrameElementProto$LWS
} = HTMLIFrameElement; // Used by '@locker/near-membrane-dom'.

const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElementProto$LWS, 'contentWindow');
const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'src');
const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const {
  createContextualFragment: RangeProtoCreateContextualFragment$LWS
} = Range.prototype;
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS(Request.prototype, 'url');
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS(`(?:^|\\W)${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
const topReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
const topWebpackReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');
const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExpCtor$LWS(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function applyUncompiledTransformations$LWS(sourceText$LWS) {
  const isWebpack$LWS = ReflectApply$LWS(RegExpProtoTest$LWS, webpackRequireNameRegExp$LWS, [sourceText$LWS]);
  let locationRegExp$LWS, topRegExp$LWS;

  if (isWebpack$LWS) {
    locationRegExp$LWS = locationReferencesWithWebPackRegExp$LWS;
    topRegExp$LWS = topWebpackReferencesRegExp$LWS;
  } else {
    locationRegExp$LWS = locationReferencesRegExp$LWS;
    topRegExp$LWS = topReferencesRegExp$LWS;
  }

  const transforms$LWS = []; // Input `sourceText` is non-compiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  const locationReplacer$LWS = (_match$LWS, assignmentOperator$LWS) => {
    transforms$LWS[0] = UNCOMPILED_LOCATION_NAME$LWS;
    return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
  };

  sourceText$LWS = ReflectApply$LWS(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, locationReplacer$LWS]); // In non-compiled source text `window.top` is null when evaluated in a sandbox.
  // We perform a naive transformation to replace references of `window.top` to use
  // our internal sandbox helpers.

  const {
    length: length$LWS
  } = transforms$LWS;

  const topReplacer$LWS = () => {
    transforms$LWS[length$LWS] = UNCOMPILED_TOP_NAME$LWS;
    return UNCOMPILED_TOP_NAME$LWS;
  };

  sourceText$LWS = ReflectApply$LWS(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, topReplacer$LWS]);
  return {
    code: sourceText$LWS,
    transforms: transforms$LWS
  };
}

function destructureHelpers$LWS(helpers$LWS) {
  const helperNamesCommaSeparated$LWS = ReflectApply$LWS(ArrayProtoJoin$LWS, helpers$LWS, [',']);
  return `const {${helperNamesCommaSeparated$LWS}} = ${SANDBOX_EVAL_CONTEXT_NAME$LWS};`;
}

function transformUncompiledSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (ReflectApply$LWS(RegExpProtoTest$LWS, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }

  const {
    code: code$LWS,
    transforms: transforms$LWS
  } = applyUncompiledTransformations$LWS(sourceText$LWS);

  if (transforms$LWS.length === 0) {
    return sourceText$LWS;
  }

  const destructureSandboxEvalContextSnippet$LWS = destructureHelpers$LWS(transforms$LWS);
  const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, 'use strict');

  if (pragmaIndex$LWS === -1) {
    return `${destructureSandboxEvalContextSnippet$LWS}${code$LWS}`;
  } // The "use strict" pragma, including quotes, is 12 characters long.


  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12; // istanbul ignore else

  if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }

  return ReflectApply$LWS(StringProtoSlice$LWS, code$LWS, [0, afterPragmaIndex$LWS]) + destructureSandboxEvalContextSnippet$LWS + ReflectApply$LWS(StringProtoSlice$LWS, code$LWS, [afterPragmaIndex$LWS]);
}

const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement.prototype, 'dataset');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL; // This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.js containing the directive and subsequently being
// ignored.
// istanbul ignore next

const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
export { AttrProtoNameGetter$LWS as AttrProtoNameGetter, AttrProtoNamespaceURIGetter$LWS as AttrProtoNamespaceURIGetter, AttrProtoOwnerElementGetter$LWS as AttrProtoOwnerElementGetter, AttrProtoValueGetter$LWS as AttrProtoValueGetter, AttrProtoValueSetter$LWS as AttrProtoValueSetter, BlobCtor$LWS as BlobCtor, BlobProtoSizeGetter$LWS as BlobProtoSizeGetter, BlobProtoSlice$LWS as BlobProtoSlice, BlobProtoTypeGetter$LWS as BlobProtoTypeGetter, DOMImplementationProtoCreateDocument$LWS as DOMImplementationProtoCreateDocument, DOMTokenListProtoValueGetter$LWS as DOMTokenListProtoValueGetter, DocumentFragmentProtoGetElementById$LWS as DocumentFragmentProtoGetElementById, DocumentProtoBodyGetter$LWS as DocumentProtoBodyGetter, DocumentProtoClose$LWS as DocumentProtoClose, DocumentProtoCookieGetter$LWS as DocumentProtoCookieGetter, DocumentProtoCookieSetter$LWS as DocumentProtoCookieSetter, DocumentProtoCreateComment$LWS as DocumentProtoCreateComment, DocumentProtoCreateElement$LWS as DocumentProtoCreateElement, DocumentProtoCreateElementNS$LWS as DocumentProtoCreateElementNS, DocumentProtoDefaultViewGetter$LWS as DocumentProtoDefaultViewGetter, DocumentProtoDocumentElementGetter$LWS as DocumentProtoDocumentElementGetter, DocumentProtoGetElementById$LWS as DocumentProtoGetElementById, DocumentProtoHeadGetter$LWS as DocumentProtoHeadGetter, DocumentProtoImplementationGetter$LWS as DocumentProtoImplementationGetter, DocumentProtoOpen$LWS as DocumentProtoOpen, ElementProtoClosest$LWS as ElementProtoClosest, ElementProtoGetAttribute$LWS as ElementProtoGetAttribute, ElementProtoGetAttributeNode$LWS as ElementProtoGetAttributeNode, ElementProtoGetAttributeNodeNS$LWS as ElementProtoGetAttributeNodeNS, ElementProtoHasAttribute$LWS as ElementProtoHasAttribute, ElementProtoInnerHTMLGetter$LWS as ElementProtoInnerHTMLGetter, ElementProtoInnerHTMLSetter$LWS as ElementProtoInnerHTMLSetter, ElementProtoNamespaceURIGetter$LWS as ElementProtoNamespaceURIGetter, ElementProtoOuterHTMLGetter$LWS as ElementProtoOuterHTMLGetter, ElementProtoQuerySelector$LWS as ElementProtoQuerySelector, ElementProtoRemove$LWS as ElementProtoRemove, ElementProtoRemoveAttributeNode$LWS as ElementProtoRemoveAttributeNode, ElementProtoSetAttribute$LWS as ElementProtoSetAttribute, ElementProtoSetAttributeNS$LWS as ElementProtoSetAttributeNS, EventProtoCurrentTargetGetter$LWS as EventProtoCurrentTargetGetter, EventTargetProtoAddEventListener$LWS as EventTargetProtoAddEventListener, HTMLAnchorElementProtoHostnameGetter$LWS as HTMLAnchorElementProtoHostnameGetter, HTMLAnchorElementProtoHrefGetter$LWS as HTMLAnchorElementProtoHrefGetter, HTMLAnchorElementProtoHrefSetter$LWS as HTMLAnchorElementProtoHrefSetter, HTMLAnchorElementProtoPathnameGetter$LWS as HTMLAnchorElementProtoPathnameGetter, HTMLAnchorElementProtoProtocolGetter$LWS as HTMLAnchorElementProtoProtocolGetter, HTMLElementProtoDatasetGetter$LWS as HTMLElementProtoDatasetGetter, HTMLElementProtoStyleGetter$LWS as HTMLElementProtoStyleGetter, HTMLIFrameElementProtoContentWindowGetter$LWS as HTMLIFrameElementProtoContentWindowGetter, HTMLIFrameElementProtoSrcSetter$LWS as HTMLIFrameElementProtoSrcSetter, HTMLScriptElementProtoSrcGetter$LWS as HTMLScriptElementProtoSrcGetter, HTMLScriptElementProtoSrcSetter$LWS as HTMLScriptElementProtoSrcSetter, HTMLTemplateElementProtoContentGetter$LWS as HTMLTemplateElementProtoContentGetter, NAMESPACE_DEFAULT$LWS as NAMESPACE_DEFAULT, NAMESPACE_SVG$LWS as NAMESPACE_SVG, NAMESPACE_XHTML$LWS as NAMESPACE_XHTML, NAMESPACE_XLINK$LWS as NAMESPACE_XLINK, NodeProtoAppendChild$LWS as NodeProtoAppendChild, NodeProtoChildNodesGetter$LWS as NodeProtoChildNodesGetter, NodeProtoCloneNode$LWS as NodeProtoCloneNode, NodeProtoFirstChildGetter$LWS as NodeProtoFirstChildGetter, NodeProtoIsEqualNode$LWS as NodeProtoIsEqualNode, NodeProtoLastChildGetter$LWS as NodeProtoLastChildGetter, NodeProtoNodeNameGetter$LWS as NodeProtoNodeNameGetter, NodeProtoOwnerDocumentGetter$LWS as NodeProtoOwnerDocumentGetter, RangeProtoCreateContextualFragment$LWS as RangeProtoCreateContextualFragment, RequestProtoURLGetter$LWS as RequestProtoURLGetter, SVGElementProtoDatasetGetter$LWS as SVGElementProtoDatasetGetter, StorageProtoGetItem$LWS as StorageProtoGetItem, StorageProtoKey$LWS as StorageProtoKey, StorageProtoRemoveItem$LWS as StorageProtoRemoveItem, StorageProtoSetItem$LWS as StorageProtoSetItem, URLCreateObjectURL$LWS as URLCreateObjectURL, URLRevokeObjectURL$LWS as URLRevokeObjectURL, WindowClearInterval$LWS as WindowClearInterval, WindowDecodeURIComponent$LWS as WindowDecodeURIComponent, WindowDocumentGetter$LWS as WindowDocumentGetter, WindowEncodeURIComponent$LWS as WindowEncodeURIComponent, WindowFrameElementGetter$LWS as WindowFrameElementGetter, WindowLengthGetter$LWS as WindowLengthGetter, WindowLocationGetter$LWS as WindowLocationGetter, WindowQueueMicrotask$LWS as WindowQueueMicrotask, WindowSetInterval$LWS as WindowSetInterval, XhrCtor$LWS as XhrCtor, XhrProtoOpen$LWS as XhrProtoOpen, XhrProtoResponseTextGetter$LWS as XhrProtoResponseTextGetter, XhrProtoSend$LWS as XhrProtoSend, XhrProtoStatusGetter$LWS as XhrProtoStatusGetter, XhrProtoWithCredentialsSetter$LWS as XhrProtoWithCredentialsSetter, applyUncompiledTransformations$LWS as applyUncompiledTransformations, destructureHelpers$LWS as destructureHelpers, getValidator$LWS as getValidator, isWindow$LWS as isWindow, selfDocument$LWS as selfDocument, selfValidator$LWS as selfValidator, selfWindow$LWS as selfWindow, transformUncompiledSourceText$LWS as transformUncompiledSourceText };
/*! version: 0.17.9 */
