import { utility, PublicSafety, schemaUtil } from 'o11y/shared';

const defaultTraceIdLengthW3 = 32;
const defaultTraceIdLengthB3 = 16;
const defaultSpanIdLength = 16;
const headerTraceParent = 'traceparent';
const headerB3 = 'b3';
const headerTraceId = 'X-B3-TraceId';
const headerSpanId = 'X-B3-SpanId';
const headerSampled = 'X-B3-Sampled';
const headerParentSpanId = 'X-B3-ParentSpanId';
const defaultActivityNameForFetch = 'fetch';
const defaultActivityNameForXhrSend = 'xhr_send';
class Tracing {
    constructor(instr) {
        this.instr = instr;
        utility.requireArgument(instr, 'instr', 'object');
    }
    static _getB3CompactFormat(traceId, spanId, isSampled, parentSpanId) {
        let b3 = `${traceId}-${spanId}`;
        if (isSampled !== undefined || parentSpanId !== undefined) {
            b3 += isSampled ? '-1' : '-0';
            if (parentSpanId !== undefined) {
                b3 += `-${parentSpanId}`;
            }
        }
        return b3;
    }
    static _getW3CompactFormat(traceId, spanId, isSampled) {
        return `00-${traceId}-${spanId}-${isSampled ? '01' : '00'}`;
    }
    static _conformTextAsId(text, numChars) {
        text = text.toLowerCase();
        const len = text.length;
        for (let i = 0; i < len; i += 1) {
            const c = text[i];
            if (!(c >= 'a' && c <= 'f') && !(c >= '0' && c <= '9')) {
                throw new Error(`The text '${text}' has an invalid character at index #${i}`);
            }
        }
        if (len > numChars) {
            return text.substr(len - numChars);
        }
        if (len < numChars) {
            return text.padStart(numChars, '0');
        }
        return text;
    }
    static getHeaders(traceId, spanId, isSampled, options) {
        utility.requireArgument(traceId, 'traceId', 'string');
        utility.requireArgument(spanId, 'spanId', 'string');
        const useB3Headers = options && options.useB3Headers;
        traceId = this._conformTextAsId(traceId, options && options.traceIdEffectiveLength !== undefined
            ? options.traceIdEffectiveLength
            : useB3Headers
                ? defaultTraceIdLengthB3
                : defaultTraceIdLengthW3);
        spanId = this._conformTextAsId(spanId, defaultSpanIdLength);
        const parentSpanId = (options &&
            options.parentSpanId !== undefined &&
            this._conformTextAsId(options.parentSpanId, defaultSpanIdLength)) ||
            undefined;
        const headers = {};
        if (useB3Headers) {
            const isCompact = options && options.useCompactHeader;
            if (isCompact) {
                headers[headerB3] = this._getB3CompactFormat(traceId, spanId, isSampled, parentSpanId);
            }
            else {
                headers[headerTraceId] = traceId;
                headers[headerSpanId] = spanId;
                if (parentSpanId !== undefined) {
                    headers[headerParentSpanId] = parentSpanId;
                }
                if (isSampled !== undefined) {
                    headers[headerSampled] = isSampled ? '1' : '0';
                }
            }
        }
        else {
            headers[headerTraceParent] = this._getW3CompactFormat(traceId, spanId, isSampled);
        }
        return headers;
    }
    _disableNetworkInstrumentation() {
        if (Tracing._isNetworkInstrumentationEnabled) {
            if (Tracing._originalFetch) {
                Tracing._global.fetch = Tracing._originalFetch;
                Tracing._originalFetch = undefined;
            }
            if (Tracing._originalXhr) {
                Tracing._global.XMLHttpRequest = Tracing._originalXhr;
                Tracing._originalXhr = undefined;
            }
            if (Tracing._originalXhrSend) {
                Tracing._global.XMLHttpRequest.prototype.send = Tracing._originalXhrSend;
                Tracing._originalXhrSend = undefined;
            }
            Tracing._isNetworkInstrumentationEnabled = false;
        }
    }
    _enableNetworkInstrumentation(instr, logErrors, activityName, useTracing, options) {
        if (typeof Tracing._global.fetch === 'function') {
            this._overrideFetch(instr, logErrors, activityName, useTracing, options);
            Tracing._isNetworkInstrumentationEnabled = true;
        }
        if (typeof Tracing._global.XMLHttpRequest === 'function') {
            this._overrideXhr(instr, logErrors, activityName, useTracing, options);
            Tracing._isNetworkInstrumentationEnabled = true;
        }
    }
    _overrideFetch(instr, logErrors, activityName, useTracing, options) {
        Tracing._originalFetch = Tracing._global.fetch;
        const o11yFetch = async (url, reqOptions, ...restArgs) => {
            let activity;
            try {
                activity = instr.startActivity(activityName || defaultActivityNameForFetch);
                if (useTracing) {
                    reqOptions = reqOptions || {};
                    const traceHeaders = activity.getTraceHeaders(options);
                    reqOptions.headers = Object.assign(reqOptions.headers || {}, traceHeaders);
                }
                return await Tracing._originalFetch.call(Tracing._global, url, reqOptions, ...restArgs);
            }
            catch (ex) {
                if (logErrors) {
                    if (activity) {
                        activity.error(ex);
                    }
                    else {
                        instr.error(ex);
                    }
                }
                throw ex;
            }
            finally {
                if (activity) {
                    activity.stop();
                }
            }
        };
        Tracing._global.fetch = o11yFetch;
    }
    _overrideXhr(instr, logErrors, activityName, useTracing, options) {
        Tracing._originalXhr = Tracing._global.XMLHttpRequest;
        Tracing._originalXhrSend = Tracing._originalXhr.prototype.send;
        Tracing._originalXhr.prototype.send = function (...args) {
            let activity;
            const xhr = this;
            try {
                xhr._o11yActivity = activity = instr.startActivity(activityName || defaultActivityNameForXhrSend);
                if (useTracing) {
                    const headers = activity.getTraceHeaders(options);
                    Object.entries(headers).forEach((entry) => {
                        xhr.setRequestHeader(entry[0], entry[1]);
                    });
                }
                Tracing._originalXhrSend.call(this, ...args);
            }
            catch (ex) {
                if (logErrors) {
                    if (activity) {
                        activity.error(ex);
                    }
                    else {
                        instr.error(ex);
                    }
                }
                if (activity) {
                    activity.stop();
                }
                throw ex;
            }
        };
        const xhrProxy = new Proxy(Tracing._originalXhr, {
            construct(target) {
                const newXhr = new target();
                newXhr.addEventListener('load', () => {
                    const activity = newXhr._o11yActivity;
                    if (activity) {
                        activity.stop();
                    }
                });
                newXhr.addEventListener('error', (__err) => {
                    const error = new Error('XHR Network-Level Error');
                    const activity = newXhr._o11yActivity;
                    if (activity) {
                        if (logErrors) {
                            activity.error(error);
                        }
                        activity.stop();
                    }
                    else if (logErrors) {
                        instr.error(error);
                    }
                });
                newXhr.addEventListener('abort', () => {
                    const activity = newXhr._o11yActivity;
                    if (activity) {
                        activity.discard();
                    }
                });
                return newXhr;
            }
        });
        Tracing._global.XMLHttpRequest = xhrProxy;
    }
    networkInstrumentation(options) {
        utility.requireArgument(options, 'options', ['boolean', 'object']);
        if (options) {
            this._disableNetworkInstrumentation();
            const tracingOptions = typeof options === 'object' ? options : {};
            this._enableNetworkInstrumentation(utility.definedValueOrDefault(tracingOptions.instrumentation, this.instr), utility.definedValueOrDefault(tracingOptions.logErrors, true), tracingOptions.activityName, utility.definedValueOrDefault(tracingOptions.useTracing, true), tracingOptions.tracingHeadersOptions);
        }
        else {
            this._disableNetworkInstrumentation();
        }
    }
}
Tracing._global = utility.getGlobal();
Tracing._isNetworkInstrumentationEnabled = false;

var TimerOverride;
(function (TimerOverride) {
    TimerOverride[TimerOverride["none"] = 0] = "none";
    TimerOverride[TimerOverride["start"] = 1] = "start";
    TimerOverride[TimerOverride["stop"] = 2] = "stop";
    TimerOverride[TimerOverride["both"] = 3] = "both";
})(TimerOverride || (TimerOverride = {}));

const timedout = 'timedout';
const terminated = 'terminated';
const discarded = 'discarded';
const stopReason = {
    timedout,
    terminated,
    discarded
};
class ActivityImpl {
    constructor(_name, _rootId, _onStopped, _onError, timeout, id, _isSampled) {
        this._name = _name;
        this._rootId = _rootId;
        this._onStopped = _onStopped;
        this._onError = _onError;
        this._isSampled = _isSampled;
        this._errorCount = 0;
        this._timerOverridden = TimerOverride.none;
        const { tsNow, perfNow } = utility.time();
        ActivityImpl._count += 1;
        this._id = id || utility.generateUniqueId();
        this._usePerf =
            typeof performance !== 'undefined' &&
                typeof performance.mark === 'function' &&
                typeof performance.measure === 'function';
        if (this._usePerf) {
            this._perfName = `${this._name}__${ActivityImpl._count}`;
            this._perfId = `${this._name}__${this.id}`;
            try {
                performance.mark(this._perfId);
            }
            catch (_a) {
                this._usePerf = false;
            }
        }
        this._startTimestamp = tsNow;
        this._startPerfTime = perfNow;
        if (timeout > 0) {
            this._timer = setTimeout(() => {
                this._stopReason = this._stopReason || stopReason.timedout;
                this.stop();
            }, timeout);
        }
        this._safety = new PublicSafety();
    }
    get id() {
        return this._id;
    }
    getId() {
        return this.id;
    }
    getRootId() {
        return this._rootId;
    }
    get stopReason() {
        return this._stopReason;
    }
    error(error, userSchemaOrText, userData) {
        this._safety.tryCatch(() => {
            this._errorCount += 1;
            if (typeof error === 'string') {
                error = new Error(error);
            }
            this._onError(error, this._getDetail(userSchemaOrText, userData));
        });
    }
    stop(userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            utility.requireArgumentIfDefined(userSchemaOrText, 'userSchemaOrText', [
                'object',
                'string'
            ]);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            if (options) {
                const perfStart = options.perfStartOverride;
                const isStartTimeDefined = utility.requireArgumentIfDefined(perfStart, 'options.perfStartOverride', 'number');
                const perfStop = options.perfStopOverride;
                const isStopTimeDefined = utility.requireArgumentIfDefined(perfStop, 'options.perfStopOverride', 'number');
                if (isStartTimeDefined && perfStart < 0) {
                    throw new Error('perfStartOverride, if defined, must be >= 0');
                }
                if (isStopTimeDefined &&
                    (perfStop < 0 ||
                        perfStop < (isStartTimeDefined ? perfStart : this._startPerfTime))) {
                    throw new Error('perfStopOverride, if defined, must be >= 0 and >= startTime');
                }
            }
            this._stopInternal(userSchemaOrText, userData, options);
        });
    }
    _overrideTimer(perfStartTime, perfStopTime) {
        if (perfStartTime !== undefined) {
            this._startTimestamp = Math.round(this._startTimestamp - (this._startPerfTime - perfStartTime));
            this._startPerfTime = perfStartTime;
            this._setTimerOverride(TimerOverride.start);
        }
        if (perfStopTime !== undefined) {
            this._stopPerfTime = perfStopTime;
            this._setTimerOverride(TimerOverride.stop);
        }
    }
    _setTimerOverride(value) {
        if (this._timerOverridden === TimerOverride.both ||
            this._timerOverridden === value ||
            value === TimerOverride.none) {
            return;
        }
        this._timerOverridden =
            this._timerOverridden === TimerOverride.none ? value : TimerOverride.both;
    }
    _stopInternal(userSchemaOrText, userData, options) {
        const stopPerfTime = utility.perfNow();
        if (this._usePerf) {
            try {
                if (this._stopReason !== stopReason.discarded) {
                    performance.measure(this._perfName, this._perfId);
                }
                performance.clearMarks(this._perfId);
                performance.clearMeasures(this._perfName);
            }
            catch (_a) { }
        }
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        if (this.isStopped) {
            return;
        }
        if (options) {
            this._overrideTimer(options.perfStartOverride, options.perfStopOverride);
        }
        this._stopPerfTime =
            this._timerOverridden === TimerOverride.none ||
                this._timerOverridden === TimerOverride.start
                ? stopPerfTime
                : this._stopPerfTime;
        const activityDetail = this._getDetail(userSchemaOrText, userData);
        this._onStopped(activityDetail);
    }
    get isStopped() {
        return this._stopPerfTime !== undefined;
    }
    discard() {
        this._safety.tryCatch(() => {
            this._stopReason = this._stopReason || stopReason.discarded;
            this.stop();
        });
    }
    terminate() {
        this._safety.tryCatch(() => {
            this._stopReason = this._stopReason || stopReason.terminated;
            this.stop();
        });
    }
    getIsSampled() {
        return this._isSampled || false;
    }
    _getDetail(userSchemaOrText, userData) {
        return {
            id: this._id,
            rootId: this._rootId,
            name: this._name,
            userSchemaOrText: userSchemaOrText,
            userData,
            stopReason: this._stopReason,
            startTimestamp: this._startTimestamp,
            startPerfTime: this._startPerfTime,
            stopPerfTime: this._stopPerfTime,
            errorCount: this._errorCount,
            isSampled: this.getIsSampled(),
            timerOverridden: this._timerOverridden
        };
    }
    getTraceHeaders(options) {
        const spanId = this.id;
        const traceId = this._rootId || spanId;
        return Tracing.getHeaders(traceId, spanId, this.getIsSampled(), options);
    }
    getStartTimestamp() {
        return this._startTimestamp;
    }
    getStartPerfTime() {
        return this._startPerfTime;
    }
    getStopPerfTime() {
        return this._stopPerfTime;
    }
}
ActivityImpl._count = 0;

const activity={namespace:"sf.instrumentation",name:"Activity",pbjsSchema:{"nested":{"sf":{"nested":{"instrumentation":{"nested":{"Activity":{"reserved":[[5,5],[7,7]],"fields":{"duration":{"options":{},"id":3,"type":"double"},"stopReason":{"options":{},"id":6,"type":"string"},"isRoot":{"options":{},"id":8,"type":"bool"},"timerOverridden":{"options":{},"id":12,"type":"uint32"},"name":{"options":{"(meta.max_length)":25},"id":2,"type":"string"},"isSampled":{"options":{},"id":11,"type":"bool"},
"preRootId":{"options":{},"id":9,"type":"string"},"id":{"options":{},"id":1,"type":"string"},"userPayload":{"options":{},"id":4,"type":"Payload"},"errorCount":{"options":{},"id":10,"type":"uint32"},"parentId":{"options":{},"id":13,"type":"string"}}},"Payload":{"fields":{"payload":{"options":{},"id":2,"type":"bytes"},"schemaName":{"options":{},"id":1,"type":"string"}}}}}}}}}};

const error={namespace:"sf.instrumentation",name:"Error",pbjsSchema:{"nested":{"sf":{"nested":{"instrumentation":{"nested":{"Error":{"reserved":[[5,5],[7,7]],"fields":{"activityId":{"options":{},"id":6,"type":"string"},"stack":{"options":{},"id":3,"type":"string"},"name":{"options":{},"id":1,"type":"string"},"message":{"options":{"(meta.max_length)":200},"id":2,"type":"string"},"userPayload":{"options":{},"id":4,"type":"Payload"}}},"Payload":{"fields":{"payload":{"options":{},"id":2,"type":"bytes"},
"schemaName":{"options":{},"id":1,"type":"string"}}}}}}}}}};

const idle_detector_report={namespace:"sf.instrumentation",name:"IdleDetectorReport",pbjsSchema:{"nested":{"sf":{"nested":{"instrumentation":{"nested":{"IdleDetectorReport":{"options":{"(meta.msg.desc)":"This is used by the Idle Detector in o11y"},"fields":{"listenerCount":{"options":{},"id":3,"type":"uint32"},"busyTasks":{"options":{},"rule":"repeated","id":5,"type":"string"},"busyDurations":{"options":{},"rule":"repeated","id":6,"type":"double"},"pollableCount":{"options":{},"id":4,"type":"uint32"},
"pollCounts":{"options":{},"rule":"repeated","id":8,"type":"double"},"logThreshold":{"options":{},"id":2,"type":"double"},"maxDuration":{"options":{},"id":1,"type":"double"},"pollables":{"options":{},"rule":"repeated","id":7,"type":"string"}}}}}}}}}};

const instrumented_event={namespace:"sf.instrumentation",name:"InstrumentedEvent",pbjsSchema:{"nested":{"sf":{"nested":{"instrumentation":{"nested":{"MouseEvent":{"fields":{"cancelable":{"options":{},"id":5,"type":"bool"},"ctrlKey":{"options":{},"id":9,"type":"bool"},"type":{"options":{},"id":25,"type":"string"},"button":{"options":{},"id":3,"type":"uint32"},"offsetX":{"options":{},"id":17,"type":"uint32"},"eventPhase":{"options":{},"id":12,"type":"uint32"},"shiftKey":{"options":{},"id":23,
"type":"bool"},"offsetY":{"options":{},"id":18,"type":"uint32"},"composed":{"options":{},"id":8,"type":"bool"},"altKey":{"options":{},"id":1,"type":"bool"},"isTrusted":{"options":{},"id":13,"type":"bool"},"buttons":{"options":{},"id":4,"type":"uint32"},"movementY":{"options":{},"id":16,"type":"uint32"},"clientY":{"options":{},"id":7,"type":"uint32"},"clientX":{"options":{},"id":6,"type":"uint32"},"movementX":{"options":{},"id":15,"type":"uint32"},"defaultPrevented":{"options":{},"id":10,"type":"bool"},
"metaKey":{"options":{},"id":14,"type":"bool"},"timeStamp":{"options":{},"id":24,"type":"double"},"bubbles":{"options":{},"id":2,"type":"bool"},"detail":{"options":{},"id":11,"type":"int64"},"pageY":{"options":{},"id":20,"type":"uint32"},"pageX":{"options":{},"id":19,"type":"uint32"},"screenX":{"options":{},"id":21,"type":"uint32"},"screenY":{"options":{},"id":22,"type":"uint32"}}},"InstrumentedEvent":{"oneofs":{"event":{"oneof":["mouseEvent"]}},"reserved":[[4,4],"xpath",[6,6],[8,8]],"fields":{"mouseEvent":{"options":{},
"id":7,"type":"MouseEvent"},"auto":{"options":{},"id":3,"type":"bool"},"parentComponent":{"options":{},"id":2,"type":"string"},"ownerComponent":{"options":{},"id":1,"type":"string"},"userPayload":{"options":{},"id":5,"type":"Payload"},"simplePath":{"options":{},"id":9,"type":"string"}}},"Payload":{"fields":{"payload":{"options":{},"id":2,"type":"bytes"},"schemaName":{"options":{},"id":1,"type":"string"}}}}}}}}}};

const simple={namespace:"sf.instrumentation",name:"Simple",pbjsSchema:{"nested":{"sf":{"nested":{"instrumentation":{"nested":{"Simple":{"options":{"(meta.msg.desc)":"This message is used internally to allow convenient logging of simple text via the API without requiring a schema."},"fields":{"text":{"options":{"(meta.max_length)":25},"id":1,"type":"string"}}}}}}}}}};

const id = new Array(16).fill(0).join('');
class ActivityNoOp {
    getId() {
        return id;
    }
    getRootId() {
        return undefined;
    }
    error() { }
    stop() { }
    discard() { }
    terminate() { }
    getIsSampled() {
        return false;
    }
    getTraceHeaders(__options) {
        return {};
    }
    getStartTimestamp() {
        return undefined;
    }
    getStartPerfTime() {
        return undefined;
    }
    getStopPerfTime() {
        return undefined;
    }
}
const activityNoOp = Object.freeze(new ActivityNoOp());

class DomEventHelpers {
    getInstrumentedEventData(eventData, handledBy, userPayload) {
        const instrumentedEvent = {
            ownerComponent: handledBy.tagName,
            parentComponent: (handledBy.parentElement && handledBy.parentElement.tagName) || undefined,
            event: eventData,
            simplePath: utility.getXpath(handledBy)
        };
        if (userPayload) {
            instrumentedEvent.userPayload = schemaUtil.makePayload(userPayload.schema, userPayload.payload, true);
        }
        return instrumentedEvent;
    }
    getMouseEventData(e) {
        return {
            altKey: e.altKey,
            bubbles: e.bubbles,
            button: e.button,
            buttons: e.buttons,
            cancelable: e.cancelable,
            clientX: e.clientX,
            clientY: e.clientY,
            composed: e.composed,
            defaultPrevented: e.defaultPrevented,
            detail: e.detail,
            eventPhase: e.eventPhase,
            isTrusted: e.isTrusted,
            timeStamp: e.timeStamp,
            type: e.type,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            movementX: e.movementX,
            movementY: e.movementY,
            offsetX: e.offsetX,
            offsetY: e.offsetY,
            pageX: e.pageX,
            pageY: e.pageY,
            screenX: e.screenX,
            screenY: e.screenY,
            shiftKey: e.shiftKey
        };
    }
}
const singleton = new DomEventHelpers();
const domEventHelpers = singleton;

const maxStringLengthAppLimit = 10000;
const maxItemCountAppLimit = 10000;
const minUnsigned = 0;
const maxFourBytes = 2147483647;
const minFourBytes = -2147483648;
const maxFourBytesUnsigned = 4294967295;
const maxEightBytes = 9223372036854776000;
const minEightBytes = -9223372036854776001;
const maxEightBytesUnsigned = 18446744073709552000;
class ValidationEntry {
    constructor(errorCode, fields, expected, received) {
        this.errorCode = errorCode;
        this.fields = fields;
        this.expected = expected;
        this.received = received;
    }
    asMessage(schemaId) {
        const key = this.fields[0] +
            this.fields
                .slice(1)
                .reduce((prev, current) => Number(current) >= 0 ? `${prev}[${current}]` : `${prev}.${current}`, '');
        let msg;
        switch (this.errorCode) {
            case 1:
                msg = 'Repeated field must be an array';
                break;
            case 2:
                msg = `Expected type ${this.expected} but received type ${this.received}`;
                break;
            case 3:
                msg = 'Value must be finite';
                break;
            case 4:
                msg = 'Value is out of range for its type';
                break;
            case 5:
                msg = 'Bytes array is malformed';
                break;
            case 6:
                msg = 'Exceeded app limit for maximum string length';
                break;
            case 7:
                msg = 'Exceeded app limit for item count';
                break;
            default:
                msg = `Unknown error code: ${this.errorCode}`;
                break;
        }
        return `Schema ${schemaId} on field "${key}": ${msg}`;
    }
}
class LogValidator {
    validate(schema, data, noThrow = false) {
        const schemaTokens = schemaUtil.checkSchema(schema);
        utility.requireArgument(data, 'data', 'object');
        const schemaId = schemaUtil.getSchemaId(schema);
        const errorInfos = new Array();
        const nestedSchema = schemaUtil.getTypes(schema);
        this.validateFields(errorInfos, [], data, nestedSchema[schemaTokens.message], nestedSchema, schemaId);
        if (errorInfos.length && !noThrow) {
            throw new Error(errorInfos[0].asMessage(schemaId));
        }
        return errorInfos;
    }
    validateFields(errorInfos, fieldNames, data, message, descriptor, schemaId) {
        const oneofs = message.oneofs || {};
        const fields = message.fields || {};
        for (const key in data) {
            const value = data[key];
            if (!this.isNullOrUndefinedOrEmpty(value)) {
                const mft = (fieldType, rule) => this.matchFieldTypes(errorInfos, [...fieldNames, key], value, fieldType, descriptor, schemaId, key, rule);
                if (oneofs[key]) {
                    mft(fields[oneofs[key].oneof[0]].type);
                }
                else if (fields[key]) {
                    mft(fields[key].type, fields[key].rule);
                }
            }
        }
    }
    isNullOrUndefinedOrEmpty(val) {
        return val === undefined || val === null || val === '';
    }
    matchFieldTypes(errorInfos, fieldNames, fieldDataValue, protobufType, descriptor, schemaId, key, rule) {
        let errorCode;
        if (rule === 'repeated') {
            if (Array.isArray(fieldDataValue)) {
                if (fieldDataValue.length > maxItemCountAppLimit) {
                    errorCode = 7;
                }
                fieldDataValue.forEach((value, index) => {
                    this.matchFieldTypes(errorInfos, [...fieldNames, index.toString()], value, protobufType, descriptor, schemaId, key);
                });
            }
            else {
                errorCode = 1;
            }
            if (errorCode) {
                errorInfos.push(new ValidationEntry(errorCode, fieldNames));
            }
            return;
        }
        let javaScriptType;
        switch (protobufType) {
            case 'string':
                javaScriptType = 'string';
                if (fieldDataValue.length > maxStringLengthAppLimit) {
                    errorCode = 6;
                }
                break;
            case 'bytes':
                javaScriptType = 'object';
                if (!(fieldDataValue instanceof Uint8Array)) {
                    errorCode = 5;
                }
                break;
            case 'bool':
                javaScriptType = 'boolean';
                break;
            case 'uint32':
                javaScriptType = 'number';
                errorCode = this.checkNumberRange(fieldDataValue, minUnsigned, maxFourBytesUnsigned);
                break;
            case 'int32':
            case 'sint32':
            case 'fixed32':
            case 'sfixed32':
                javaScriptType = 'number';
                errorCode = this.checkNumberRange(fieldDataValue, minFourBytes, maxFourBytes);
                break;
            case 'uint64':
                javaScriptType = 'number';
                errorCode = this.checkNumberRange(fieldDataValue, minUnsigned, maxEightBytesUnsigned);
                break;
            case 'fixed64':
            case 'sfixed64':
            case 'int64':
            case 'sint64':
                javaScriptType = 'number';
                errorCode = this.checkNumberRange(fieldDataValue, minEightBytes, maxEightBytes);
                break;
            case 'double':
            case 'float':
                javaScriptType = 'number';
                if (!Number.isFinite(fieldDataValue)) {
                    errorCode = 3;
                }
                break;
            default:
                if (new Set(Object.keys(descriptor)).has(protobufType)) {
                    this.validateFields(errorInfos, fieldNames, fieldDataValue, descriptor[protobufType], descriptor, schemaId);
                    javaScriptType = 'object';
                }
                break;
        }
        if (typeof fieldDataValue !== javaScriptType) {
            errorInfos.push(new ValidationEntry(2, fieldNames, protobufType, typeof fieldDataValue));
        }
        if (errorCode) {
            errorInfos.push(new ValidationEntry(errorCode, fieldNames));
        }
    }
    checkNumberRange(value, min, max) {
        return value > max || value < min ? 4 : undefined;
    }
}
const logValidator = new LogValidator();

class BucketHistogramImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, _buckets) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._buckets = _buckets;
        this._values = new Array();
        this._createdOn = utility.time().tsNow;
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this.values;
    }
    getBuckets() {
        return this.buckets;
    }
    get buckets() {
        return this._buckets.slice(0, this._buckets.length);
    }
    get values() {
        return this._values.slice(0, this._values.length);
    }
    record(value) {
        if (typeof value === 'number') {
            this._values.push(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('BucketHistogram can only record numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._values = [];
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

class UpCounterImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._value = 0;
        this._createdOn = utility.time().tsNow;
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this._value;
    }
    increment(value = 1) {
        if (typeof value === 'number' && value > 0) {
            this._value += Math.round(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('UpCounter can only increment positive numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._value = 0;
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

class ValueRecorderImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._values = new Array();
        this._createdOn = utility.time().tsNow;
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this.values;
    }
    get values() {
        return this._values.slice(0, this._values.length);
    }
    record(value) {
        if (typeof value === 'number') {
            this._values.push(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('ValueRecorder can only record numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._values = [];
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

class SizeLimitedMap {
    constructor(maxSize) {
        this._map = new Map();
        if (typeof maxSize === 'number' && maxSize > 0) {
            this._maxSize = Math.ceil(maxSize);
            return;
        }
        throw new Error('maxSize must be a positive number');
    }
    get maxSize() {
        return this._maxSize;
    }
    get(key) {
        return this._map.get(key);
    }
    has(key) {
        return this._map.has(key);
    }
    set(key, value) {
        if (this.has(key) || this._map.size < this.maxSize) {
            this._map.set(key, value);
            return true;
        }
        return false;
    }
    getElements() {
        return Array.from(this._map.values());
    }
    clear() {
        this._map.clear();
    }
}

const maxCounters = 1000;
const maxValueRecorders = 500;
const maxBucketHistograms = 500;
var MetricType;
(function (MetricType) {
    MetricType[MetricType["Counter"] = 0] = "Counter";
    MetricType[MetricType["Percentile"] = 1] = "Percentile";
    MetricType[MetricType["BucketHistogram"] = 2] = "BucketHistogram";
})(MetricType || (MetricType = {}));
class MetricsImpl {
    constructor(_ownerName, _getOwnerAppName) {
        this._ownerName = _ownerName;
        this._getOwnerAppName = _getOwnerAppName;
        this._upCounters = new SizeLimitedMap(maxCounters);
        this._valueRecorders = new SizeLimitedMap(maxValueRecorders);
        this._bucketHistograms = new SizeLimitedMap(maxBucketHistograms);
    }
    incrementCounter(operation, increment, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._upCounter(operation, tags).increment(increment);
    }
    trackValue(operation, value, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._valueRecorder(operation, tags).record(value);
    }
    bucketValue(operation, value, buckets, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._bucketHistogram(operation, tags, buckets).record(value);
    }
    _bucketHistogram(name, tags, buckets) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.BucketHistogram);
        let instrument = this._bucketHistograms.get(key);
        if (!instrument) {
            instrument = new BucketHistogramImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags, buckets);
            if (!this._bucketHistograms.set(key, instrument)) {
                throw new Error(`Max size of ${maxBucketHistograms} exceeded for BucketHistograms`);
            }
        }
        return instrument;
    }
    _upCounter(name, tags) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Counter);
        let instrument = this._upCounters.get(key);
        if (!instrument) {
            instrument = new UpCounterImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
            if (!this._upCounters.set(key, instrument)) {
                throw new Error(`Max size of ${maxCounters} exceeded for UpCounters`);
            }
        }
        return instrument;
    }
    _valueRecorder(name, tags) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Percentile);
        let instrument = this._valueRecorders.get(key);
        if (!instrument) {
            instrument = new ValueRecorderImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
            if (!this._valueRecorders.set(key, instrument)) {
                throw new Error(`Max size of ${maxValueRecorders} exceeded for ValueRecorders`);
            }
        }
        return instrument;
    }
    getUpCounters() {
        return this._upCounters.getElements();
    }
    getValueRecorders() {
        return this._valueRecorders.getElements();
    }
    getBucketHistograms() {
        return this._bucketHistograms.getElements();
    }
    _tagError(tags, hasError) {
        tags.status = hasError === true ? 'error' : 'success';
    }
    _getKeyAndSortedTags(operation, tags, metricType) {
        const sortedTags = Object.keys(tags)
            .sort()
            .reduce((prev, curr) => {
            prev[curr] = tags[curr];
            return prev;
        }, {});
        const key = `${MetricType[metricType]}:${operation}${JSON.stringify(sortedTags)}`;
        return {
            key,
            sortedTags
        };
    }
}

class MockEvent {
    constructor(type, composed, _composedPaths) {
        this.type = type;
        this.composed = composed;
        this._composedPaths = _composedPaths;
    }
    composedPath() {
        return this._composedPaths;
    }
}

const maxActivityDurationMsecs = undefined;
const reservedMetricCharacters = ['`'];
const reservedMetricNames = {
    internalError: 'o11y-error'
};
const denyListMetricNames = Object.freeze(Array.from(Object.values(reservedMetricNames)));
class InstrumentationImpl {
    constructor(_nextGen, _name) {
        this._nextGen = _nextGen;
        this._name = _name;
        this._onActivityStoppedCallback = this._handleActivityStop.bind(this);
        this._onActivityErrorCallback = this._handleActivityError.bind(this);
        for (const reservedChar of reservedMetricCharacters) {
            if (this._name.indexOf(reservedChar) >= 0) {
                throw new Error(`Name cannot include the reserved character "${reservedChar}"`);
            }
        }
        this._safety = new PublicSafety({
            increment: (increment) => this._incrementError(increment)
        });
        this._metrics = this._initMetrics();
        const simpleTextOptions = schemaUtil.getOptions(simple, 'Simple', 'text');
        this._simpleTextMaxLength = simpleTextOptions
            ? simpleTextOptions['(meta.max_length)']
            : maxStringLengthAppLimit;
    }
    _initMetrics() {
        return new MetricsImpl(this.name, () => this._nextGen.appName || InstrumentationImpl.defaultAppName);
    }
    _incrementError(increment = 1) {
        this._metrics.incrementCounter(reservedMetricNames.internalError, increment, false);
    }
    get name() {
        return this._name;
    }
    _wrapUserPayload(userSchemaOrText, userData, onlyIfBoth = false) {
        let userSchema;
        if (typeof userSchemaOrText === 'string') {
            userSchema = simple;
            if (userSchemaOrText) {
                userData = {
                    text: userSchemaOrText.substring(0, this._simpleTextMaxLength)
                };
            }
            else {
                userData = undefined;
            }
        }
        else {
            userSchema = userSchemaOrText;
        }
        return schemaUtil.makePayload(userSchema, userData, onlyIfBoth);
    }
    getEffectiveRootId(options) {
        var _a, _b;
        return ((_b = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId) !== null && _b !== void 0 ? _b : this._nextGen.getDefaultInstrumentationContext().rootId);
    }
    log(userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            const timestamp = utility.time().tsNow;
            utility.requireArgument(userSchemaOrText, 'userSchemaOrText', ['object', 'string']);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            const userPayload = this._wrapUserPayload(userSchemaOrText, userData);
            if (userPayload === null || userPayload === void 0 ? void 0 : userPayload.payload) {
                this._logInternal(this.name, userPayload.schema, userPayload.payload, timestamp, this.getEffectiveRootId(options));
            }
        });
    }
    _logInternal(loggerName, schema, data, timestamp, rootId) {
        this._checkInputs(schema, data);
        const appPayload = this._getPayloadFromProvider(this._nextGen.appPayloadProvider);
        const pagePayload = this._getPayloadFromProvider(this._nextGen.pagePayloadProvider);
        return this._nextGen.addLog(loggerName, schema, data, timestamp, rootId, pagePayload, appPayload);
    }
    error(error, userSchemaOrText, userData, options) {
        return this._safety.tryCatch(() => {
            utility.requireArgumentIfDefined(userSchemaOrText, 'userSchemaOrText', [
                'object',
                'string'
            ]);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            const rootId = this.getEffectiveRootId(options);
            this._errorInternal(error, userSchemaOrText, userData, undefined, rootId);
        });
    }
    _errorInternal(err, userSchemaOrText, userData, activityId, rootActivityId) {
        const loggedTimestamp = utility.time().tsNow;
        let error$1;
        if (err instanceof Error) {
            error$1 = err;
        }
        else {
            let msg;
            if (err === undefined || err === null || typeof err.toString !== 'function') {
                msg = 'UNKNOWN';
            }
            else {
                msg = err.toString();
            }
            error$1 = new Error(msg);
        }
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
        const errorData = {
            name: error$1.name,
            message: error$1.message,
            stack: error$1.stack,
            userPayload,
            activityId
        };
        return this._logInternal(this.name, error, errorData, loggedTimestamp, rootActivityId);
    }
    startActivity(name, options) {
        return this._safety.tryCatchReturn(() => {
            var _a;
            utility.requireArgument(name, 'name');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            let context;
            const rootId = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId;
            if (rootId) {
                context = {
                    rootId,
                    isRootActivitySampled: options.instrumentationContext.isRootActivitySampled
                };
            }
            else {
                context = this._nextGen.getDefaultInstrumentationContext();
            }
            const activity = new ActivityImpl(name, context.rootId, this._onActivityStoppedCallback, this._onActivityErrorCallback, maxActivityDurationMsecs, undefined, context.isRootActivitySampled);
            return activity;
        }, activityNoOp);
    }
    _getActivityData(detail) {
        const userPayload = this._wrapUserPayload(detail.userSchemaOrText, detail.userData, true);
        return {
            id: detail.id,
            name: detail.name,
            duration: detail.stopPerfTime - detail.startPerfTime,
            stopReason: detail.stopReason,
            userPayload,
            errorCount: detail.errorCount,
            isSampled: detail.isSampled,
            timerOverridden: detail.timerOverridden
        };
    }
    _handleActivityStop(detail) {
        if (detail.stopReason === discarded) {
            return;
        }
        const activityData = this._getActivityData(detail);
        this._logActivity(activityData, detail.startTimestamp, detail.rootId);
    }
    _logActivity(activityData, startTimestamp, rootId) {
        this._logInternal(this.name, activity, activityData, startTimestamp, rootId);
    }
    _handleActivityError(error, detail) {
        this._errorInternal(error, detail.userSchemaOrText, detail.userData, detail.id, detail.rootId);
    }
    _getPayloadFromProvider(provider) {
        const payload = (provider === null || provider === void 0 ? void 0 : provider.getPayload()) || undefined;
        if (payload) {
            this._checkInputs(payload.schema, payload.payload);
        }
        return payload;
    }
    domEvent(event, handledBy, userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            const tsNow = utility.time().tsNow;
            utility.requireArgument(event, 'event', [Event, MockEvent]);
            utility.requireArgument(handledBy, 'handledBy', [HTMLElement, 'object']);
            let htmlElement;
            if (handledBy instanceof HTMLElement) {
                htmlElement = handledBy;
            }
            else {
                handledBy = handledBy;
                if (handledBy.template && handledBy.template.host instanceof HTMLElement) {
                    htmlElement = handledBy.template.host;
                }
                else {
                    utility.requireArgument(undefined, 'handledBy');
                }
            }
            const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
            const rootId = this.getEffectiveRootId(options);
            switch (event.type) {
                case 'click': {
                    const mouseEvent = event;
                    const acd = this._nextGen.getClickTracker();
                    if (acd) {
                        acd.markEventHandled(mouseEvent);
                    }
                    const mouseEventData = domEventHelpers.getMouseEventData(mouseEvent);
                    const instrumentedEvent = domEventHelpers.getInstrumentedEventData(mouseEventData, htmlElement, userPayload);
                    instrumentedEvent.auto = options && options._auto;
                    this._logInternal(this.name, instrumented_event, instrumentedEvent, tsNow, rootId);
                    break;
                }
                default:
                    throw new Error(utility.notImplemented);
            }
        });
    }
    incrementCounter(operation, increment = 1, hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(increment, 'increment', 'number');
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.incrementCounter(operation, increment, hasError, tags);
        });
    }
    trackValue(operation, value, hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(value, 'value', 'number');
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.trackValue(operation, value, hasError, tags);
        });
    }
    bucketValue(operation, value, buckets = [], hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(value, 'value', 'number');
            utility.requireArgument(buckets, 'buckets', Array);
            Object.entries(buckets).forEach((entry) => {
                utility.requireArgument(entry[1], `Bucket value for '${entry[0]}'`, 'number');
            });
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.bucketValue(operation, value, buckets, hasError, tags);
        });
    }
    _checkInputs(schema, data) {
        schemaUtil.checkSchema(schema);
        utility.requireArgument(data, 'data', 'object');
        let vEntries;
        let savedUserPayload;
        if (data.userPayload !== undefined && schemaUtil.isInternal(schema)) {
            savedUserPayload = data.userPayload;
            vEntries = logValidator.validate(savedUserPayload.schema, savedUserPayload.payload, true);
            this._processValidationResults(schemaUtil.getSchemaId(savedUserPayload.schema), savedUserPayload.payload, vEntries);
            data.userPayload = undefined;
        }
        vEntries = logValidator.validate(schema, data, true);
        this._processValidationResults(schemaUtil.getSchemaId(schema), data, vEntries);
        if (savedUserPayload !== undefined) {
            data.userPayload = savedUserPayload;
        }
    }
    _processValidationResults(schemaId, data, ventries) {
        for (let i = 0; i < ventries.length; i += 1) {
            const ei = ventries[i];
            if (ei.errorCode == 6 ||
                ei.errorCode == 7) {
                const lfi = ei.fields.length - 1;
                const obj = this._traverseFields(data, ei.fields.slice(0, lfi));
                const field = ei.fields[lfi];
                if (ei.errorCode == 6) {
                    obj[field] = obj[field].substring(0, maxStringLengthAppLimit);
                }
                else {
                    obj[field].splice(maxItemCountAppLimit);
                }
            }
            else {
                throw new Error(ei.asMessage(schemaId));
            }
        }
    }
    _traverseFields(data, fields) {
        if (!fields.length) {
            return data;
        }
        return this._traverseFields(data[fields[0]], fields.slice(1));
    }
    getUpCounters() {
        return this._metrics.getUpCounters().filter((m) => m.getLastUpdatedOn());
    }
    getValueRecorders() {
        return this._metrics.getValueRecorders().filter((m) => m.getLastUpdatedOn());
    }
    getBucketHistograms() {
        return this._metrics.getBucketHistograms().filter((m) => m.getLastUpdatedOn());
    }
    registerForLogPrompt(listener) {
        utility.requireArgument(listener, 'listener', 'function');
        this._nextGen.registerForLogPrompt(listener);
    }
    activity(name, execute, options) {
        var _a, _b, _c, _d;
        const act = this.startActivity(name, options);
        try {
            return execute(act);
        }
        catch (err) {
            act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
            throw err;
        }
        finally {
            act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
        }
    }
    async activityAsync(name, execute, options) {
        var _a, _b, _c, _d;
        const act = this.startActivity(name, options);
        try {
            return await execute(act);
        }
        catch (err) {
            act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
            throw err;
        }
        finally {
            act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
        }
    }
}
InstrumentationImpl.defaultAppName = 'APP_NOT_REGISTERED';

class RootActivityImpl extends ActivityImpl {
    constructor(name, onStopped, onError, rootId, _isSampled) {
        super(name, undefined, onStopped, onError, undefined, rootId || utility.generateUniqueId(32), _isSampled);
    }
    get preRootId() {
        return this._preRootId;
    }
    set preRootId(value) {
        this._preRootId = value;
    }
    _getDetail(userSchema, userData) {
        const detail = super._getDetail(userSchema, userData);
        detail.isRoot = true;
        detail.preRootId = this.preRootId;
        return detail;
    }
}

const rootId = new Array(32).fill(0).join('');
class RootActivityNoOp {
    getId() {
        return rootId;
    }
    getRootId() {
        return undefined;
    }
    error() { }
    stop() { }
    discard() { }
    terminate() { }
    getIsSampled() {
        return false;
    }
    getTraceHeaders(__options) {
        return {};
    }
    getStartTimestamp() {
        return undefined;
    }
    getStartPerfTime() {
        return undefined;
    }
    getStopPerfTime() {
        return undefined;
    }
}
const rootActivityNoOp = Object.freeze(new RootActivityNoOp());

class AppInstrumentationImpl extends InstrumentationImpl {
    constructor(_nextGen, _name, _allowMulti) {
        super(_nextGen, _name);
        this._allowMulti = _allowMulti;
        this._onRootActivityStoppedCallback = this.handleRootActivityStop.bind(this);
    }
    startRootActivity(name, rootId, isSampled) {
        return this._safety.tryCatchReturn(() => {
            utility.requireArgument(name, 'name');
            const newRootActivity = new RootActivityImpl(name, this._onRootActivityStoppedCallback, this._onActivityErrorCallback, rootId, isSampled);
            if (!this._allowMulti) {
                if (this._singleRootActivity && !this._singleRootActivity.isStopped) {
                    const preRootId = this._singleRootActivity.getId();
                    this._singleRootActivity.terminate();
                    newRootActivity.preRootId = preRootId;
                }
                this._singleRootActivity = newRootActivity;
            }
            return newRootActivity;
        }, rootActivityNoOp);
    }
    handleRootActivityStop(detail) {
        if (detail.stopReason === discarded) {
            return;
        }
        const activityData = this._getActivityData(detail);
        this._logActivity(activityData, detail.startTimestamp);
        this._singleRootActivity = undefined;
    }
    _getActivityData(detail) {
        const activityData = super._getActivityData(detail);
        activityData.isRoot = detail.isRoot;
        activityData.preRootId = detail.preRootId;
        return activityData;
    }
    getSingleRootActivityId() {
        var _a;
        return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getId();
    }
    isSingleRootActivitySampled() {
        var _a;
        return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getIsSampled();
    }
    _initMetrics() {
        return new MetricsImpl(this.name, () => this.name);
    }
}

const pathLimit = 5;
class AutomaticClickTracker {
    constructor(instrumentation, document) {
        this.isActive = false;
        this._boundClickListener = this.clickListener.bind(this);
        utility.requireArgument(instrumentation, 'instrumentation');
        utility.requireArgument(document, 'document');
        this.instr = instrumentation;
        this.document = document;
    }
    activate() {
        if (!this.isActive) {
            this.document.addEventListener('click', this._boundClickListener, true);
            this.isActive = true;
        }
    }
    deactivate() {
        if (this.isActive) {
            this.document.removeEventListener('click', this._boundClickListener, true);
            this.isActive = false;
        }
    }
    markEventHandled(event) {
        this.ignoredEvent = event;
    }
    clickListener(event) {
        let eventTargets = event.composedPath && event.composedPath();
        if (!eventTargets || !eventTargets.length) {
            eventTargets = event.path;
        }
        const handledBy = this.getClickableElement(eventTargets);
        if (handledBy) {
            setTimeout(() => {
                if (event !== this.ignoredEvent) {
                    this.instr.domEvent(event, handledBy, undefined, undefined, {
                        _auto: true
                    });
                }
            });
        }
    }
    getClickableElement(path) {
        const limit = path ? Math.min(path.length, pathLimit) : 0;
        for (let x = 0; x < limit; x += 1) {
            const currentElement = path[x];
            const tagName = currentElement.tagName && currentElement.tagName.toLowerCase();
            if (tagName === 'a' || tagName === 'button') {
                return currentElement;
            }
            if (tagName === 'input') {
                const inputElement = currentElement;
                if (inputElement.type && inputElement.type.toLowerCase() === 'button') {
                    return inputElement;
                }
            }
        }
        return undefined;
    }
}

const maxInstrumentationLength = 80;
const truncatedText = '_CUT';
const maxInstrumentationLengthBeforeTruncated = maxInstrumentationLength - truncatedText.length;
class NextgenImpl {
    constructor() {
        this._logCollectors = new Set();
        this._instruments = new Map();
        this._seqBySchema = new Map();
        this._sequence = 0;
        this._forceDisabledLogCollectors = new Set();
        this._logCollectorFailures = new Map();
        this._isBufferingEnabled = false;
        this._buffer = [];
        this._logCollectionListeners = new Set();
    }
    get pagePayloadProvider() {
        return this._pagePayloadProvider;
    }
    set pagePayloadProvider(provider) {
        this._pagePayloadProvider = provider;
    }
    get appPayloadProvider() {
        return this._appPayloadProvider;
    }
    set appPayloadProvider(provider) {
        this._appPayloadProvider = provider;
    }
    registerApp(name, options) {
        utility.requireArgument(name, 'name', 'string');
        if (this._appInstr) {
            throw new Error('An app has already been registered with instrumentation.');
        }
        const instr = this._instruments.get(name);
        if (instr) {
            throw new Error(`The instrumentation name ${name} is already taken`);
        }
        this._appInstr = new AppInstrumentationImpl(this, name, options && options.allowMultipleRootActivities);
        this._instruments.set(name, this._appInstr);
        this._isBufferingEnabled = options && options.enableBuffering;
        const tracing = new Tracing(this._appInstr);
        return {
            log: this._appInstr.log.bind(this._appInstr),
            error: this._appInstr.error.bind(this._appInstr),
            startActivity: this._appInstr.startActivity.bind(this._appInstr),
            domEvent: this._appInstr.domEvent.bind(this._appInstr),
            incrementCounter: this._appInstr.incrementCounter.bind(this._appInstr),
            trackValue: this._appInstr.trackValue.bind(this._appInstr),
            bucketValue: this._appInstr.bucketValue.bind(this._appInstr),
            networkInstrumentation: tracing.networkInstrumentation.bind(tracing),
            registerForLogPrompt: this._appInstr.registerForLogPrompt.bind(this._appInstr),
            activity: this._appInstr.activity.bind(this._appInstr),
            activityAsync: this._appInstr.activityAsync.bind(this._appInstr),
            startRootActivity: this._appInstr.startRootActivity.bind(this._appInstr),
            registerLogCollector: this.registerLogCollector.bind(this),
            registerMetricsCollector: this.registerMetricsCollector.bind(this),
            activateClickTracker: this.activateClickTracker.bind(this),
            deactivateClickTracker: this.deactivateClickTracker.bind(this),
            disableBuffering: this.disableBuffering.bind(this),
            promptLogCollection: this.promptLogCollection.bind(this)
        };
    }
    getInstrumentation(name) {
        utility.requireArgument(name, 'name', 'string');
        if (name.length > maxInstrumentationLength) {
            name = name.substr(0, maxInstrumentationLengthBeforeTruncated) + truncatedText;
        }
        let instr = this._instruments.get(name);
        if (!instr) {
            instr = new InstrumentationImpl(this, name);
            this._instruments.set(name, instr);
        }
        else if (instr === this._appInstr) {
            throw new Error(`The instrumentation name ${name} is being used by the app.`);
        }
        return instr;
    }
    get appName() {
        return this._appInstr && this._appInstr.name;
    }
    addLog(loggerName, schema, data, timestamp, rootId, pagePayload, appPayload) {
        this._sequence += 1;
        const schemaId = schemaUtil.getSchemaId(schema);
        let schemaSequence = this._seqBySchema.get(schemaId) || 0;
        schemaSequence += 1;
        this._seqBySchema.set(schemaId, schemaSequence);
        const logMeta = {
            timestamp,
            rootId,
            sequence: this._sequence,
            schemaSequence,
            loggerName,
            pagePayload: pagePayload ? utility.clone(pagePayload) : undefined,
            appPayload: appPayload ? utility.clone(appPayload) : undefined,
            loggerAppName: this.appName,
            connectionType: utility.getConnectionType()
        };
        if (this._isBufferingEnabled) {
            this._buffer.push({ schema, data: utility.clone(data), logMeta });
        }
        const eligibleCollectors = Array.from(this._logCollectors).filter((collector) => !this._forceDisabledLogCollectors.has(collector) &&
            !(collector.getIsCollectDisabled && collector.getIsCollectDisabled()));
        if (eligibleCollectors.length > 0) {
            for (const collector of eligibleCollectors) {
                const dataClone = utility.clone(data);
                let failures = this._logCollectorFailures.get(collector) || 0;
                try {
                    collector.collect(schema, dataClone, logMeta);
                    if (failures > 0) {
                        this._logCollectorFailures.set(collector, failures - 1);
                    }
                }
                catch (err) {
                    failures += 1;
                    if (failures >= NextgenImpl._collectorFailureLimit) {
                        this._forceDisabledLogCollectors.add(collector);
                        if (this._appInstr && (typeof err === 'string' || err instanceof Error)) {
                            this._appInstr.error(err);
                        }
                    }
                    else {
                        this._logCollectorFailures.set(collector, failures);
                    }
                }
            }
        }
        return this._sequence;
    }
    getBuffer() {
        return this._buffer;
    }
    disableBuffering() {
        this._isBufferingEnabled = false;
        this._buffer = [];
    }
    getClickTracker() {
        return this._autoClickTracker;
    }
    getDefaultInstrumentationContext() {
        var _a, _b;
        return {
            rootId: (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.getSingleRootActivityId(),
            isRootActivitySampled: (_b = this._appInstr) === null || _b === void 0 ? void 0 : _b.isSingleRootActivitySampled()
        };
    }
    activateClickTracker() {
        if (!this._autoClickTracker) {
            this._autoClickTracker = new AutomaticClickTracker(this._appInstr, window.document);
        }
        this._autoClickTracker.activate();
    }
    deactivateClickTracker() {
        if (this._autoClickTracker) {
            this._autoClickTracker.deactivate();
            this._autoClickTracker = undefined;
        }
    }
    registerLogCollector(collector, options) {
        utility.requireArgument(collector, 'collector');
        if (this._logCollectors.has(collector)) {
            return;
        }
        this._logCollectors.add(collector);
        this._logCollectorFailures.set(collector, 0);
        if ((!collector.getIsCollectDisabled || !collector.getIsCollectDisabled()) &&
            options &&
            options.retroactive) {
            for (const log of this._buffer) {
                collector.collect(log.schema, log.data, log.logMeta);
            }
        }
    }
    registerMetricsCollector(collector) {
        utility.requireArgument(collector, 'collector');
        if (this._metricsCollector) {
            throw new Error('A metrics Collector is already registered.');
        }
        this._metricsCollector = collector;
        this._metricsCollector.receiveMetricsExtractors({
            getAllUpCounters: this.getAllUpCounters.bind(this),
            getAllValueRecorders: this.getAllValueRecorders.bind(this),
            getAllBucketHistograms: this.getAllBucketHistograms.bind(this)
        });
    }
    getAllUpCounters() {
        const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getUpCounters());
        return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    getAllValueRecorders() {
        const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getValueRecorders());
        return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    getAllBucketHistograms() {
        const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getBucketHistograms());
        return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    registerForLogPrompt(listener) {
        this._logCollectionListeners.add(listener);
    }
    promptLogCollection(reason) {
        for (const listener of this._logCollectionListeners.keys()) {
            try {
                listener(reason);
            }
            catch (err) {
                if (!utility.isProduction) {
                    throw err;
                }
            }
        }
    }
}
NextgenImpl._collectorFailureLimit = 5;

class Index {
    get _lazyNextGen() {
        if (!this._nextgen) {
            this._nextgen = new NextgenImpl();
        }
        return this._nextgen;
    }
    registerInstrumentedApp(name, options) {
        if (!options || options.isProduction !== false) {
            utility.markProduction();
        }
        const retVal = this._lazyNextGen.registerApp(name, options);
        if (options) {
            this._nextgen.appPayloadProvider = options.appPayloadProvider;
            this._nextgen.pagePayloadProvider = options.pagePayloadProvider;
        }
        return retVal;
    }
    getInstrumentation(name) {
        return this._lazyNextGen.getInstrumentation(name);
    }
}
const index = new Index();
const registerInstrumentedApp = index.registerInstrumentedApp.bind(index);
const getInstrumentation = index.getInstrumentation.bind(index);
const time = utility.time.bind(utility);

class TaskerImpl {
    constructor(name, initialCount, _doneCallback, _overDoneCallback) {
        this.name = name;
        this._doneCallback = _doneCallback;
        this._overDoneCallback = _overDoneCallback;
        this._busyCount = 0;
        this._isOk = true;
        this._busyCount = initialCount;
    }
    get isBusy() {
        return this._isOk ? this._busyCount > 0 : undefined;
    }
    add() {
        if (this._isOk) {
            this._busyCount += 1;
        }
    }
    done() {
        if (this._isOk) {
            if (this._busyCount > 0) {
                this._busyCount -= 1;
                if (!this._busyCount) {
                    this._doneCallback();
                }
            }
            else {
                this._isOk = false;
                this._overDoneCallback();
            }
        }
    }
}

const defaultLogThreshold = 300;
class IdleDetectorImpl {
    constructor(options) {
        this._instr = getInstrumentation('IdleDetector');
        this._taskers = new Map();
        this._listeners = new Set();
        this._busyCheckers = new Map();
        this._logThreshold = defaultLogThreshold;
        this._endedTasks = new Array();
        this._pollableReport = new Array();
        this._timerCheckQueued = 0;
        if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.logThreshold, 'options.logThreshold', 'number')) {
            this._logThreshold = options.logThreshold;
        }
    }
    requestIdleDetectedCallback(callback) {
        utility.requireArgument(callback, 'callback', 'function');
        if (this._listeners.size === 0) {
            this._firstCallbackTime = utility.time().perfNow;
        }
        this._listeners.add(callback);
        this.checkIfLoaded();
    }
    reportTaskEnded(tasker) {
        if (this._listeners.size) {
            const snapshot = Object.assign({}, this._taskers.get(tasker));
            this._endedTasks.push(snapshot);
        }
    }
    declareNotifierTaskSingle(name) {
        utility.requireArgument(name, 'name', 'string');
        const tasker = this.addTasker(name, 1);
        const retVal = {
            get isBusy() {
                return tasker.isBusy;
            },
            done: () => {
                tasker.done();
                this._taskers.delete(tasker);
            }
        };
        return retVal;
    }
    declareNotifierTaskMulti(name, existingBusyCount = 0) {
        utility.requireArgument(name, 'name', 'string');
        if (existingBusyCount !== undefined) {
            utility.requireArgument(existingBusyCount, 'existingBusyCount', 'number');
            if (existingBusyCount < 0 ||
                parseInt(existingBusyCount.toString(), 10) !== existingBusyCount) {
                throw new Error('existingBusyCount accepts only non-negative integers');
            }
        }
        const tasker = this.addTasker(name, existingBusyCount);
        const retVal = {
            get isBusy() {
                return tasker.isBusy;
            },
            add: () => {
                if (!tasker.isBusy) {
                    const meta = this._taskers.get(tasker);
                    meta.start = utility.time().perfNow;
                    meta.end = undefined;
                }
                tasker.add();
            },
            done: tasker.done.bind(tasker)
        };
        return retVal;
    }
    declarePollableTaskMulti(name, isBusyChecker) {
        utility.requireArgument(name, 'name', 'string');
        utility.requireArgument(isBusyChecker, 'isBusyChecker', 'function');
        this._busyCheckers.set(isBusyChecker, name);
    }
    addTasker(name, existingBusyCount) {
        const tasker = new TaskerImpl(name, existingBusyCount, () => {
            this._taskers.get(tasker).end = utility.time().perfNow;
            this.reportTaskEnded(tasker);
            this.checkIfLoaded();
        }, () => {
            this._instr.error(`Overdone: ${tasker.name}`);
            utility.noProdThrow(`Tasker '${tasker.name}' is done too many times.`);
        });
        this._taskers.set(tasker, {
            name,
            start: existingBusyCount > 0 ? utility.time().perfNow : undefined,
            end: undefined
        });
        return tasker;
    }
    areAllNotifiersIdle() {
        return !Array.from(this._taskers.keys()).some((t) => t.isBusy);
    }
    getFirstBusyPollable() {
        const entry = Array.from(this._busyCheckers).find((entry) => {
            const isBusyChecker = entry[0];
            const name = entry[1];
            try {
                return isBusyChecker();
            }
            catch (e) {
                this._instr.error(e, `BusyChecker ${name}`);
                utility.noProdThrow(e);
                return false;
            }
        });
        return entry ? entry[1] : undefined;
    }
    checkIfLoaded() {
        if (!this._listeners.size) {
            return;
        }
        if (this._timerCheckQueued) {
            window.clearTimeout(this._timerCheckQueued);
        }
        if (this.areAllNotifiersIdle()) {
            this._timerCheckQueued = window.setTimeout(() => {
                this._timerCheckQueued = window.setTimeout(() => {
                    this.doubleCheck();
                }, 40);
            }, 0);
        }
    }
    doubleCheck() {
        this._timerCheckQueued = 0;
        if (this.areAllNotifiersIdle()) {
            const pollableName = this.getFirstBusyPollable();
            if (pollableName !== undefined) {
                this.addToPollableReport(pollableName);
                this._timerCheckQueued = window.setTimeout(() => {
                    this.doubleCheck();
                }, 15);
            }
            else {
                const maxDuration = utility.time().perfNow - this._firstCallbackTime;
                const listeners = Array.from(this._listeners.values());
                this._listeners.clear();
                this._firstCallbackTime = undefined;
                const endedTasks = this._endedTasks.splice(0);
                const pollableReport = this._pollableReport.splice(0);
                this.notify(listeners, maxDuration, endedTasks, pollableReport);
            }
        }
    }
    addToPollableReport(name) {
        const lastEntry = this._pollableReport.length
            ? this._pollableReport[this._pollableReport.length - 1]
            : undefined;
        if ((lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.name) === name) {
            lastEntry.count += 1;
        }
        else {
            this._pollableReport.push({
                name,
                count: 1
            });
        }
    }
    notify(listeners, maxDuration, taskReport, pollableReport) {
        if (maxDuration >= this._logThreshold) {
            const logData = this._getReport(maxDuration, listeners.length, taskReport, pollableReport);
            this._instr.log(idle_detector_report, logData);
        }
        const tsNow = utility.time().tsNow;
        for (const [index, listener] of listeners.entries()) {
            try {
                listener(tsNow);
            }
            catch (e) {
                this._instr.error(e, `Listener #${index}`);
                utility.noProdThrow(e);
            }
        }
    }
    getReport() {
        const perfNow = utility.time().perfNow;
        const maxDuration = this._firstCallbackTime > 0 ? perfNow - this._firstCallbackTime : undefined;
        const onGoingTasks = Array.from(this._taskers.entries())
            .filter((e) => e[0].isBusy)
            .map((e) => ({
            name: e[1].name,
            start: e[1].start,
            end: perfNow
        }));
        return this._getReport(maxDuration, this._listeners.size, this._endedTasks.concat(onGoingTasks), this._pollableReport);
    }
    _getReport(maxDuration, listenerCount, taskReport, pollableReport) {
        const sortedTaskers = taskReport
            .map((t) => ({
            name: t.name,
            duration: t.end - t.start
        }))
            .sort((a, b) => b.duration - a.duration);
        return {
            logThreshold: this._logThreshold,
            maxDuration,
            listenerCount,
            pollableCount: this._busyCheckers.size,
            busyTasks: sortedTaskers.map((t) => t.name),
            busyDurations: sortedTaskers.map((t) => t.duration),
            pollables: pollableReport.map((p) => p.name),
            pollCounts: pollableReport.map((p) => p.count)
        };
    }
}

const bgColorMap = {
    Error: 'Crimson',
    Activity: 'CadetBlue',
    InstrumentedEvent: 'DarkOliveGreen',
    O11ySample: 'BlueViolet'
};
const colorMap = {
    Error: 'white',
    Activity: 'white',
    InstrumentedEvent: 'white',
    O11ySample: 'white'
};
const defaultColor = 'black';
const defaultBgColor = 'Gainsboro';
class ConsoleCollector {
    constructor(environment) {
        if (environment) {
            this._log('ConsoleCollector', environment);
        }
    }
    collect(schema, data, logMeta) {
        let label, color, bgColor;
        if (schema.namespace === 'sf.instrumentation') {
            label = schema.name;
            color = colorMap[schema.name] || defaultColor;
            bgColor = bgColorMap[schema.name] || defaultBgColor;
        }
        else {
            label = schemaUtil.getSchemaId(schema);
        }
        this._log(label, data, logMeta, color, bgColor);
    }
    _log(label, first, second, color = defaultColor, bgColor = defaultBgColor) {
        const css = `color:${color};background-color:${bgColor}`;
        console.log(`%cO11Y%c ${label}`, 'color:white;background-color:#FF6600;font-weight:bold', css, first || '', second || '');
    }
}

const version = '242.3.3';

const idleDetector = new IdleDetectorImpl({
    logThreshold: 300
});

export { ConsoleCollector, version as _version, getInstrumentation, idleDetector, registerInstrumentedApp, time };
//# sourceMappingURL=client.js.map
