import { utility, schemaUtil } from 'o11y/shared';

const version='242.2.0';

const coreEnvelopeKey = 'o11y';
class CoreEnvelopeBuilder {
    constructor() {
        this._envelope = {
            diagnostics: {
                key: coreEnvelopeKey,
                generatedTimestamp: undefined,
                bundleCount: 0,
                bucketHistogramCount: 0,
                upCounterCount: 0,
                valueRecorderCount: 0,
                schemaVersion: version
            },
            bundles: [],
            metrics: {
                bucketHistograms: [],
                upCounters: [],
                valueRecorders: []
            },
            staticAttributes: {}
        };
    }
    withStaticAttributes(staticAttributes) {
        this._envelope.staticAttributes = staticAttributes;
        return this;
    }
    withLogs(schemaName, logs) {
        let msgBundle = this._envelope.bundles.find((bundle) => bundle.schemaName === schemaName);
        if (msgBundle) {
            for (const log of logs) {
                msgBundle.messages.push(log);
            }
        }
        else {
            msgBundle = {
                schemaName: schemaName,
                messages: logs
            };
            this._envelope.bundles.push(msgBundle);
        }
        this._envelope.diagnostics.bundleCount = this._envelope.bundles.length;
        return this;
    }
    static _getMetricTags(metric) {
        const tags = metric.getTags();
        if (tags) {
            return Object.entries(tags).map((entry) => {
                const mt = {
                    name: entry[0],
                    value: entry[1].toString()
                };
                return mt;
            });
        }
        return undefined;
    }
    static getUpCounters(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                value: metric.getData(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    static getValueRecorders(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                values: metric.getData(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    static getBucketHistograms(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                values: metric.getData(),
                buckets: metric.getBuckets(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    withUpCounters(upCounters) {
        for (const upCounter of upCounters) {
            this._envelope.metrics.upCounters.push(upCounter);
        }
        this._envelope.diagnostics.upCounterCount = this._envelope.metrics.upCounters.length;
        return this;
    }
    withValueRecorders(valueRecorders) {
        for (const valueRecorder of valueRecorders) {
            this._envelope.metrics.valueRecorders.push(valueRecorder);
        }
        this._envelope.diagnostics.valueRecorderCount =
            this._envelope.metrics.valueRecorders.length;
        return this;
    }
    withBucketHistograms(bucketHistograms) {
        for (const bucketHistogram of bucketHistograms) {
            this._envelope.metrics.bucketHistograms.push(bucketHistogram);
        }
        this._envelope.diagnostics.bucketHistogramCount =
            this._envelope.metrics.bucketHistograms.length;
        return this;
    }
    build() {
        this._envelope.diagnostics.generatedTimestamp = utility.time().tsNow;
        return this._envelope;
    }
    static buildFrom(contents) {
        const builder = new CoreEnvelopeBuilder();
        if (contents.staticAttributes) {
            builder.withStaticAttributes(contents.staticAttributes);
        }
        if (contents.messages) {
            contents.messages.forEach((logs, schema) => {
                builder.withLogs(schemaUtil.getSchemaId(schema), logs);
            });
        }
        if (contents.upCounters) {
            builder.withUpCounters(contents.upCounters);
        }
        if (contents.valueRecorders) {
            builder.withValueRecorders(contents.valueRecorders);
        }
        if (contents.bucketHistograms) {
            builder.withBucketHistograms(contents.bucketHistograms);
        }
        return builder.build();
    }
}

export { CoreEnvelopeBuilder, coreEnvelopeKey };
//# sourceMappingURL=core_envelope.js.map
