{"version":3,"file":"collectors.js","sources":["../../../../src/collectors/protobuf-util.ts","../../../../src/collectors/core-collector/CoreEnvelopeProtobufUtility.ts","../../../../src/collectors/core-collector/UploadMode.ts","../../../../src/collectors/core-collector/CoreCollector.ts","../../../../src/collectors/hybrid-collector/HybridCollector.ts"],"sourcesContent":["import { Message, Root, Type } from 'protobufjs';\nimport { SchematizedData, schemaUtil, utility } from 'o11y/shared';\n\nimport { LogMeta, Schema, SchematizedPayload } from '../interfaces';\nimport { EncodedSchematizedPayload, LogMessage, LogMessageRaw } from '../core_envelope/interfaces';\n\nclass ProtobufUtil {\n    private readonly _typeStore = new Map<string, Type>();\n\n    public getSchemaType(schema: Schema): Type {\n        utility.requireArgument(schema, 'schema');\n        const schemaPath = schemaUtil.getSchemaId(schema);\n        let type = this._typeStore.get(schemaPath);\n\n        if (!type) {\n            // Lazy add to the type store\n            const schemaInstance = Root.fromJSON(schema.pbjsSchema);\n            // this will throw if it can't find it\n            type = schemaInstance.lookupType(schemaPath);\n            this._typeStore.set(schemaPath, type);\n        }\n\n        return type;\n    }\n\n    public validate(schema: Schema, data: SchematizedData): Type {\n        utility.requireArgument(schema, 'schema');\n        utility.requireArgument(data, 'data');\n        const type: Type = this.getSchemaType(schema);\n\n        const errorText = type.verify(data);\n        if (errorText) {\n            throw new Error(`Data is invalid for ${type.fullName}: ${errorText}`);\n        }\n        return type;\n    }\n\n    // Note: In a Node environment, this actually returns an instance of Buffer.\n    public encode(schema: Schema, data: SchematizedData): Uint8Array {\n        const type: Type = this.validate(schema, data);\n        const message: Message = type.fromObject(data);\n        const encoded: Uint8Array = type.encode(message).finish();\n        return encoded;\n    }\n\n    public encodePayload(rawPayload: SchematizedPayload): EncodedSchematizedPayload {\n        if (rawPayload && rawPayload.schema && rawPayload.payload) {\n            return {\n                schemaName: schemaUtil.getSchemaId(rawPayload.schema),\n                payload: this.encode(rawPayload.schema, rawPayload.payload)\n            };\n        }\n        return undefined;\n    }\n\n    //  This method generates a LogMessage (used in the CoreEnvelope) from the provided arguments.\n    public getLogMessage(schema: Schema, data: SchematizedData, logMeta: LogMeta): LogMessage {\n        return {\n            timestamp: logMeta.timestamp,\n            data: this.encode(schema, data),\n            age: utility.getAge(logMeta.timestamp),\n            rootId: logMeta.rootId,\n            seq: logMeta.sequence,\n            sseq: logMeta.schemaSequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: this.encodePayload(logMeta.pagePayload),\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: this.encodePayload(logMeta.appPayload)\n        };\n    }\n\n    public processRawLogMessage(schema: Schema, raw: LogMessageRaw): LogMessage {\n        const dataClone = raw.data ? Object.assign({}, raw.data) : {};\n        if (schemaUtil.isInternal(schema) && dataClone.userPayload) {\n            dataClone.userPayload = this.encodePayload(dataClone.userPayload);\n        }\n\n        return Object.assign({}, raw, {\n            data: this.encode(schema, dataClone),\n            pagePayload: this.encodePayload(raw.pagePayload),\n            appPayload: this.encodePayload(raw.appPayload)\n        });\n    }\n}\n\nexport const protobufUtil = new ProtobufUtil();\n","import { Root, Type } from 'protobufjs';\nimport {\n    CoreEnvelope,\n    CoreEnvelopeContents,\n    CoreEnvelopeContentsRaw,\n    LogMessage,\n    CoreEnvelopeBuilder\n} from 'o11y/core_envelope';\nimport { coreEnvelopeSchema } from 'o11y_schema/sf_instrumentation';\nimport { Schema } from '../../interfaces';\nimport { protobufUtil } from '../protobuf-util';\n\nconst root: Root = Root.fromJSON(coreEnvelopeSchema.pbjsSchema);\nconst _coreEnvelopeType: Type = root.lookupType('CoreEnvelope');\n\nexport function processRawContents(contentsRaw: CoreEnvelopeContentsRaw): CoreEnvelopeContents {\n    const processed: CoreEnvelopeContents = Object.assign({}, contentsRaw, {\n        messages: new Map<Schema, LogMessage[]>()\n    });\n    // Encode individual messages\n    contentsRaw.messages.forEach(function (rawMessages, schema) {\n        processed.messages.set(\n            schema,\n            rawMessages.map((msg) => protobufUtil.processRawLogMessage(schema, msg))\n        );\n    });\n    return processed;\n}\n\nexport function envelopeContents(contents: CoreEnvelopeContents): CoreEnvelope {\n    return CoreEnvelopeBuilder.buildFrom(contents);\n}\n\nexport function encodeCoreEnvelope(coreEnvelope: CoreEnvelope): Uint8Array {\n    const errorMessage = _coreEnvelopeType.verify(coreEnvelope);\n    if (errorMessage) {\n        throw new Error(`Invalid CoreEnvelope: ${errorMessage}`);\n    }\n\n    const encodedCoreEnvelope = _coreEnvelopeType.encode(coreEnvelope).finish();\n    return encodedCoreEnvelope;\n}\n\nexport function encodeCoreEnvelopeContentsRaw(contentsRaw: CoreEnvelopeContentsRaw): Uint8Array {\n    const contents: CoreEnvelopeContents = processRawContents(contentsRaw);\n    const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n    const encoded: Uint8Array = encodeCoreEnvelope(coreEnvelope);\n    return encoded;\n}\n","export enum UploadMode {\n    fetchBinary, // application/octet-stream\n    fetchFile, // multipart/form-data\n    noUpload\n}\n","import {\n    Environment,\n    LogCollector,\n    LogMeta,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { LazyMapToList, SchematizedData, schemaUtil, utility } from 'o11y/shared';\nimport {\n    CoreEnvelope,\n    CoreEnvelopeBuilder,\n    CoreEnvelopeContents,\n    LogMessage,\n    StaticAttributes\n} from 'o11y/core_envelope';\n\nimport { protobufUtil } from '../protobuf-util';\n\nimport { envelopeContents, encodeCoreEnvelope } from './CoreEnvelopeProtobufUtility';\nimport { UploadResult } from './interfaces/UploadResult';\nimport { CoreCollectorOptions } from './interfaces/CoreCollectorOptions';\nimport { UploadMode } from './UploadMode';\n\nconst defaultFormDataKey = 'telemetry';\nconst defaultMaxUniqueSchemas = 10000;\nconst defaultMaxDelayBeforeUpload = 10000;\nconst defaultMessagesLimit = 10;\nconst defaultMetricsLimit = 10;\nconst defaultUploadMode = UploadMode.fetchBinary;\n\nexport type UploadOptionsCallback = () => RequestInit;\n\nexport class CoreCollector implements LogCollector, MetricsCollector {\n    private readonly _messageBuffers: LazyMapToList<Schema, LogMessage>;\n    private _intervalHandle: NodeJS.Timeout;\n    private _metricsExtractors: MetricsExtractorMethods;\n    private readonly _staticAttributes: StaticAttributes;\n    private _immediateUpload: boolean;\n    private readonly _messagesLimit: number = defaultMessagesLimit;\n    /*\n     Known limitation:\n     Unlike _messagesLimit, _metricsLimit is not a strict limit in all cases, as the CoreCollector\n     doesn't get notified every time a new metric is added. Instead, it takes metrics into account\n     when a message is logged or the upload timer is elapsed. If the _metricsLimit is exceeded \n     with no messages logged and upload time not yet elapsed, upload will not occur.\n    */\n    private readonly _metricsLimit: number = defaultMetricsLimit;\n    private readonly _formDataKey: string = defaultFormDataKey;\n    private readonly _uploadFailedListener: (ur: UploadResult) => unknown;\n    private _uploadInterval: number = defaultMaxDelayBeforeUpload;\n    private _uploadEndpoint: string;\n    private _uploadMode: UploadMode;\n    private readonly _emptySize: number;\n    private _messageSize = 0;\n    private _uploadOptionsCallback: UploadOptionsCallback;\n\n    constructor(\n        uploadEndpoint?: string,\n        uploadMode?: UploadMode,\n        environment?: Environment,\n        options?: CoreCollectorOptions\n    ) {\n        this.uploadEndpoint = uploadEndpoint;\n        this.uploadMode = uploadMode == undefined ? defaultUploadMode : uploadMode;\n\n        if (environment) {\n            this._staticAttributes = {\n                appName: environment.appName,\n                appVersion: environment.appVersion,\n                appExperience: environment.appExperience,\n                deviceId: environment.deviceId,\n                deviceModel: environment.deviceModel,\n                sdkVersion: environment.sdkVersion\n            };\n        }\n\n        let maxUniqueSchemas = defaultMaxUniqueSchemas;\n        if (options) {\n            const mus: number = options.maxUniqueSchemas;\n            if (mus !== undefined) {\n                if (typeof mus !== 'number' || !(mus > 0)) {\n                    throw new Error('options.maxUniqueSchemas, if defined, must be > 0');\n                }\n                maxUniqueSchemas = mus;\n            }\n\n            const msglim: number = options.messagesLimit;\n            if (msglim !== undefined) {\n                if (typeof msglim !== 'number' || !(msglim > 0)) {\n                    throw new Error('options.messagesLimit, if defined, must be > 0');\n                }\n                this._messagesLimit = msglim;\n            }\n\n            const metlim: number = options.metricsLimit;\n            if (metlim !== undefined) {\n                if (typeof metlim !== 'number' || !(metlim > 0)) {\n                    throw new Error('options.metricsLimit, if defined, must be > 0');\n                }\n                this._metricsLimit = metlim;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.formDataKeyName,\n                    'options.formDataKeyName',\n                    'string'\n                )\n            ) {\n                this._formDataKey = options.formDataKeyName;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.uploadFailedListener,\n                    'options.uploadFailedListener',\n                    'function'\n                )\n            ) {\n                this._uploadFailedListener = options.uploadFailedListener;\n            }\n        }\n        this._messageBuffers = new LazyMapToList<Schema, LogMessage>(maxUniqueSchemas);\n\n        this._emptySize = this.getByteSize(1);\n        this._restartTimer();\n    }\n\n    get uploadInterval(): number {\n        return this._uploadInterval;\n    }\n    set uploadInterval(uploadInterval: number) {\n        if (uploadInterval === undefined) {\n            uploadInterval = defaultMaxDelayBeforeUpload;\n        }\n        if (typeof uploadInterval !== 'number' || !(uploadInterval > 0)) {\n            throw new Error('uploadInterval, if defined, must be > 0');\n        }\n        if (uploadInterval !== this._uploadInterval) {\n            this._uploadInterval = uploadInterval;\n            // Now that the interval has changed, restart the timer\n            this._restartTimer();\n        }\n    }\n\n    get uploadEndpoint(): string {\n        return this._uploadEndpoint;\n    }\n    set uploadEndpoint(uploadEndpoint: string) {\n        utility.requireArgumentIfDefined(uploadEndpoint, 'uploadEndpoint', 'string');\n        this._uploadEndpoint = uploadEndpoint;\n    }\n\n    get uploadOptionsCallback(): UploadOptionsCallback {\n        return this._uploadOptionsCallback;\n    }\n    set uploadOptionsCallback(uploadOptionsCallback: UploadOptionsCallback) {\n        utility.requireArgumentIfDefined(\n            uploadOptionsCallback,\n            'uploadOptionsCallback',\n            'function'\n        );\n\n        this._uploadOptionsCallback = uploadOptionsCallback;\n    }\n\n    get uploadMode(): UploadMode {\n        return this._uploadMode;\n    }\n    set uploadMode(uploadMode: UploadMode) {\n        utility.requireArgumentIfDefined(uploadMode, 'uploadMode', 'number');\n        if (uploadMode === undefined) {\n            uploadMode = defaultUploadMode;\n        }\n        if (!(uploadMode in UploadMode)) {\n            throw new Error(`Unsupported upload mode: ${uploadMode}`);\n        }\n        this._uploadMode = uploadMode;\n    }\n\n    // Note: If making changes to this method, please locally test using SizeEstimation.test.js\n    getByteSize(accuracy?: number): number {\n        // This method provides an estimate.\n        // Accuracy is specified as 1 = most accurate\n        return accuracy >= 1\n            ? this._buildProtoEncodedCoreEnvelope(false).byteLength\n            : accuracy >= 0.5\n            ? this._emptySize + this._messageSize + this.metricsCount * 8\n            : this._emptySize + this._messageSize;\n    }\n\n    private _stopTimer(): void {\n        if (this._intervalHandle !== undefined) {\n            clearInterval(this._intervalHandle);\n            this._intervalHandle = undefined;\n        }\n    }\n\n    private _restartTimer(): void {\n        this._stopTimer();\n        this._intervalHandle = setInterval(() => {\n            if (this.hasData) {\n                this._upload();\n            }\n        }, this._uploadInterval);\n    }\n\n    // This method is implementing the LogCollector interface, but needs to return (not swallow)\n    // the async result in order for direct call to it from test to handle failure cases properly.\n    async collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): Promise<UploadResult> {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const msg: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n\n        if (!this._messageBuffers.push(schema, msg)) {\n            throw new Error(`Buffer is full. Refusing schemaId ${schemaUtil.getSchemaId(schema)}`);\n        }\n        // Get an estimate\n        this._messageSize += utility.estimateObjectSize(msg);\n        if (this._shouldUpload()) {\n            return this._upload();\n        }\n        return undefined;\n    }\n\n    private _shouldUpload(): boolean {\n        return (\n            (this._immediateUpload && this.hasData) ||\n            this.messagesCount >= this._messagesLimit ||\n            this.metricsCount >= this._metricsLimit\n        );\n    }\n\n    private async _upload(userInitiated?: boolean): Promise<UploadResult> {\n        this._restartTimer();\n        if (!this._uploadEndpoint || this._uploadMode === UploadMode.noUpload) {\n            return undefined;\n        }\n\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(true);\n        return this._uploadContents(contents, userInitiated);\n    }\n\n    private async _uploadContents(\n        contents: CoreEnvelopeContents,\n        userInitiated: boolean\n    ): Promise<UploadResult> {\n        let requestInit: RequestInit = this._getRequestInit(contents);\n        const ur: UploadResult = {\n            envelopeContents: contents\n        };\n        try {\n            if (this._uploadOptionsCallback) {\n                const options: RequestInit = this._uploadOptionsCallback() || {};\n                if (options) {\n                    if (options.headers && requestInit.headers) {\n                        // According to lib.dom.d.ts:\n                        // type HeadersInit = [string, string][] | Record<string, string> | Headers;\n                        if (options.headers instanceof Headers) {\n                            for (const key in requestInit.headers) {\n                                if (\n                                    Object.prototype.hasOwnProperty.call(requestInit.headers, key)\n                                ) {\n                                    options.headers.set(\n                                        key,\n                                        (requestInit.headers as Record<string, string>)[key]\n                                    );\n                                }\n                            }\n                        } else if (Array.isArray(options.headers)) {\n                            // This doesn't seem valid according to https://developer.mozilla.org/en-US/docs/Web/API/fetch\n                            throw new Error('Headers as array is not supported.');\n                        } else {\n                            Object.assign(options.headers, requestInit.headers);\n                        }\n                    }\n                    options.method = requestInit.method;\n                    options.body = requestInit.body;\n                    requestInit = options;\n                }\n            }\n\n            ur.response = await fetch(this._uploadEndpoint, requestInit);\n            // fetch only throws on network errors, not HTTP errors, so handle that here\n            if (!ur.response.ok) {\n                throw new Error('HTTP Not OK');\n            }\n            return ur;\n        } catch (err) {\n            ur.error = err;\n            if (!userInitiated && this._uploadFailedListener) {\n                try {\n                    this._uploadFailedListener(ur);\n                } catch {}\n            }\n            throw ur;\n        }\n    }\n\n    private _getRequestInit(contents: CoreEnvelopeContents): RequestInit {\n        const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n        const coreEnvelopeEncoded: Uint8Array = encodeCoreEnvelope(coreEnvelope);\n\n        let requestInit: RequestInit;\n        switch (this._uploadMode) {\n            case UploadMode.fetchBinary:\n                requestInit = {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/octet-stream'\n                    },\n                    body: coreEnvelopeEncoded\n                };\n                break;\n            case undefined:\n            case UploadMode.fetchFile:\n                const formData = new FormData();\n                formData.append(\n                    this._formDataKey || defaultFormDataKey,\n                    new Blob([coreEnvelopeEncoded])\n                );\n                // Per [this article](https://muffinman.io/uploading-files-using-fetch-multipart-form-data/)\n                // make sure not to set the Content-Type header.\n                // The browser will set it for you, including the boundary parameter.\n                requestInit = {\n                    method: 'POST',\n                    body: formData\n                };\n                break;\n            case UploadMode.noUpload:\n            default:\n                throw new Error('Invalid uploadMode');\n        }\n        return requestInit;\n    }\n\n    private _checkUploadState(): void {\n        if (this._uploadEndpoint === undefined) {\n            throw new Error('Upload endpoint is unset');\n        }\n        if (this._uploadMode === UploadMode.noUpload) {\n            throw new Error('Upload mode is unset');\n        }\n    }\n\n    // User initiated method\n    public async upload(contents?: CoreEnvelopeContents): Promise<UploadResult> {\n        this._checkUploadState();\n        if (utility.requireArgumentIfDefined(contents, 'contents', 'object')) {\n            return this._uploadContents(contents, true);\n        }\n\n        return this.hasData ? this._upload(true) : undefined;\n    }\n\n    get hasData(): boolean {\n        return this.messagesCount > 0 || this.metricsCount > 0;\n    }\n\n    get messagesCount(): number {\n        return this._messageBuffers.totalItemCount;\n    }\n\n    get metricsCount(): number {\n        let count = 0;\n\n        if (this._metricsExtractors) {\n            count += this._metricsExtractors.getAllUpCounters()?.length || 0;\n            count += this._metricsExtractors.getAllValueRecorders()?.length || 0;\n            count += this._metricsExtractors.getAllBucketHistograms()?.length || 0;\n        }\n\n        return count;\n    }\n\n    getProtoEncodedCoreEnvelope(): Uint8Array {\n        return this._buildProtoEncodedCoreEnvelope(true);\n    }\n\n    getContentsOfCoreEnvelope(): CoreEnvelopeContents {\n        return this._getContentsOfCoreEnvelope(true);\n    }\n\n    private _getContentsOfCoreEnvelope(extract: boolean): CoreEnvelopeContents {\n        // 1. extract=true is for most use cases.\n        // 2. extract=false is for peeking into the contents without affecting them\n        //    (i.e. messages are kept in the buffers and metrics are not reset.)\n        //    Message arrays are references to the originals and should be handled carefully.\n\n        const contents: CoreEnvelopeContents = {\n            staticAttributes: this._staticAttributes,\n            messages: this._messageBuffers.getAllMessages(extract)\n        };\n\n        if (this._metricsExtractors) {\n            contents.upCounters = CoreEnvelopeBuilder.getUpCounters(\n                this._metricsExtractors.getAllUpCounters(),\n                extract\n            );\n            contents.valueRecorders = CoreEnvelopeBuilder.getValueRecorders(\n                this._metricsExtractors.getAllValueRecorders(),\n                extract\n            );\n            contents.bucketHistograms = CoreEnvelopeBuilder.getBucketHistograms(\n                this._metricsExtractors.getAllBucketHistograms(),\n                extract\n            );\n        }\n\n        if (extract) {\n            this._messageSize = 0;\n        }\n        return contents;\n    }\n\n    private _buildProtoEncodedCoreEnvelope(extract: boolean): Uint8Array {\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(extract);\n        const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n        return encodeCoreEnvelope(coreEnvelope);\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n}\n","import {\n    BucketMetric,\n    LogCollector,\n    LogMeta,\n    Metric,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { SchematizedData, MetricsTags, schemaUtil, utility } from 'o11y/shared';\nimport { protobufUtil } from '../protobuf-util';\nimport {\n    BucketHistogram,\n    EncodedSchematizedPayload,\n    LogMessage,\n    Metrics,\n    MetricTag,\n    UpCounter,\n    ValueRecorder\n} from 'o11y/core_envelope';\n\nconst metricsCollectionMilliseconds = 30000;\n\n// The observability plugin expects encoded payloads, so can't use LogMeta as-is.\ninterface LogMetaObservability {\n    timestamp: number;\n    rootId: string;\n    sequence: number;\n    loggerName: string;\n    pagePayload: EncodedSchematizedPayload;\n    loggerAppName: string;\n    connectionType: string;\n    appPayload: EncodedSchematizedPayload;\n}\n\n// The following interface is expected to be fulfilled by the\n// observability plugin in Lightning SDK.\ndeclare type NimbusObservabilityPlugin = {\n    // Called to send a collected message to native for handling\n    log: (schema: string, encodedMessage: Uint8Array, logMeta: LogMetaObservability) => void;\n\n    // Called to send metrics to native for handling\n    logMetrics: (metrics: Metrics) => void;\n\n    // Called to listen for root activity changes in native.\n    //\n    // The startListener is called with the id of the root activity when an activity is started\n    // The stopListener is called when a root activity is stopped\n    addRootActivityListeners: (\n        startListener: (activityInfo: { id: string }) => void,\n        stopListener: () => void\n    ) => void;\n\n    // Called to inform native that the web view has detected an idle state.\n    idleDetected: (timestamp: number) => void;\n};\n\n// The `HybridCollector` uses nimbus to send log data immediately across\n// to be handled by the native observability library.\nexport class HybridCollector implements LogCollector, MetricsCollector {\n    private readonly _observability: NimbusObservabilityPlugin;\n    private _metricsExtractors: MetricsExtractorMethods;\n\n    constructor() {\n        if (typeof __nimbus === 'undefined') {\n            throw new Error('Nimbus is unavailable');\n        }\n        if (!__nimbus.plugins || !__nimbus.plugins.observability) {\n            throw new Error('Observability plugin not found in Nimbus plugins');\n        }\n        this._observability = __nimbus.plugins.observability as NimbusObservabilityPlugin;\n        setInterval(() => {\n            this._collectMetrics();\n        }, metricsCollectionMilliseconds);\n    }\n\n    collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): void {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const logMessage: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n        const logMetaObs: LogMetaObservability = {\n            timestamp: logMeta.timestamp,\n            rootId: logMeta.rootId,\n            sequence: logMeta.sequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: logMessage.pagePayload,\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: logMessage.appPayload\n        };\n        this._observability.log(schemaUtil.getSchemaId(schema), logMessage.data, logMetaObs);\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n\n    // An app can call this method to listen for root activities that start and stop\n    // on the native side, in order to associate web activities with the same root id.\n    addRootActivityListeners(\n        activityStarted: (info: { id: string }) => void,\n        activityEnded: () => void\n    ): void {\n        utility.requireArgument(activityStarted, 'activityStarted', 'function');\n        utility.requireArgument(activityEnded, 'activityEnded', 'function');\n\n        this._observability.addRootActivityListeners(activityStarted, activityEnded);\n    }\n\n    // An app should call this method when it detects idle in the web view in order\n    // to inform the native app of the idle state.\n    notifyIdleDetected(timestamp: number): void {\n        this._observability.idleDetected(timestamp);\n    }\n\n    private _collectMetrics(): void {\n        if (this._metricsExtractors) {\n            const upCounters: Metric<number>[] = this._metricsExtractors.getAllUpCounters();\n            const valueRecorders: Metric<number[]>[] =\n                this._metricsExtractors.getAllValueRecorders();\n            const bucketHistograms: BucketMetric<number[]>[] =\n                this._metricsExtractors.getAllBucketHistograms();\n            const recorders: ValueRecorder[] = [];\n            const counters: UpCounter[] = [];\n            const histograms: BucketHistogram[] = [];\n\n            for (const valueRecorder of valueRecorders) {\n                const vr: ValueRecorder = {\n                    name: valueRecorder.getName(),\n                    createdTimestamp: valueRecorder.getCreatedOn(),\n                    lastUpdatedTimestamp: valueRecorder.getLastUpdatedOn(),\n                    values: valueRecorder.getData(),\n                    ownerName: valueRecorder.getOwnerName(),\n                    ownerAppName: valueRecorder.getOwnerAppName(),\n                    tags: this._getMetricTags(valueRecorder)\n                };\n                recorders.push(vr);\n                valueRecorder.reset();\n            }\n\n            for (const upCounter of upCounters) {\n                const uc: UpCounter = {\n                    name: upCounter.getName(),\n                    createdTimestamp: upCounter.getCreatedOn(),\n                    lastUpdatedTimestamp: upCounter.getLastUpdatedOn(),\n                    value: upCounter.getData(),\n                    ownerName: upCounter.getOwnerName(),\n                    ownerAppName: upCounter.getOwnerAppName(),\n                    tags: this._getMetricTags(upCounter)\n                };\n                counters.push(uc);\n                upCounter.reset();\n            }\n\n            for (const bucketHistogram of bucketHistograms) {\n                const bh: BucketHistogram = {\n                    name: bucketHistogram.getName(),\n                    createdTimestamp: bucketHistogram.getCreatedOn(),\n                    lastUpdatedTimestamp: bucketHistogram.getLastUpdatedOn(),\n                    values: bucketHistogram.getData(),\n                    buckets: bucketHistogram.getBuckets(),\n                    ownerName: bucketHistogram.getOwnerName(),\n                    ownerAppName: bucketHistogram.getOwnerAppName(),\n                    tags: this._getMetricTags(bucketHistogram)\n                };\n                histograms.push(bh);\n                bucketHistogram.reset();\n            }\n\n            if (recorders.length > 0 || counters.length > 0) {\n                const metrics: Metrics = {\n                    upCounters: counters,\n                    valueRecorders: recorders,\n                    bucketHistograms: histograms\n                };\n                this._observability.logMetrics(metrics);\n            }\n        }\n    }\n\n    private _getMetricTags<T>(metric: Metric<T>): MetricTag[] {\n        const metricsTags: MetricsTags = metric.getTags();\n\n        if (metricsTags) {\n            return Object.entries(metricsTags).map((entry) => {\n                const mt: MetricTag = {\n                    name: entry[0],\n                    value: entry[1].toString()\n                };\n                return mt;\n            });\n        }\n        return [];\n    }\n}\n"],"names":[],"mappings":"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"}