class LazyMapToList {
    constructor(maxSize) {
        this._lazyMap = new Map();
        if (maxSize !== undefined) {
            if (typeof maxSize === 'number' && maxSize > 0) {
                this._maxSize = Math.ceil(maxSize);
                return;
            }
            throw new Error('maxSize must be a positive number');
        }
    }
    get maxSize() {
        return this._maxSize;
    }
    get size() {
        return this._lazyMap.size;
    }
    push(key, value) {
        let buffer = this._lazyMap.get(key);
        if (!buffer) {
            if (this.maxSize !== undefined && this.size === this.maxSize) {
                return false;
            }
            buffer = new Array();
            this._lazyMap.set(key, buffer);
        }
        buffer.push(value);
        return true;
    }
    getMessages(key, extract) {
        const msgs = this._lazyMap.get(key);
        if (extract && this._lazyMap.has(key)) {
            this._lazyMap.set(key, []);
        }
        return msgs || [];
    }
    getAllMessages(extract) {
        const map = new Map();
        for (const [key, value] of this._lazyMap.entries()) {
            if (value.length) {
                map.set(key, this.getMessages(key, extract));
            }
        }
        return map;
    }
    extractMessages(key) {
        return this.getMessages(key, true);
    }
    extractAllMessages() {
        return this.getAllMessages(true);
    }
    get totalItemCount() {
        let count = 0;
        for (const array of this._lazyMap.values()) {
            count += array.length;
        }
        return count;
    }
}

class Utility {
    constructor() {
        this.notImplemented = 'Method not implemented.';
        const performanceExists = typeof performance !== 'undefined';
        if (performanceExists) {
            if (performance.timeOrigin) {
                this._timeOrigin = performance.timeOrigin;
            }
            else if (performance.timing && performance.timing.navigationStart) {
                this._timeOrigin = performance.timing.navigationStart;
            }
            else {
                this._timeOrigin = Date.now();
            }
        }
        else {
            this._timeOrigin = Date.now();
        }
        const timeOrigin = this._timeOrigin;
        if (performanceExists && typeof performance.now === 'function') {
            this.perfNow = performance.now.bind(performance);
            this.time = () => {
                const perfNow = this.perfNow();
                return { tsNow: timeOrigin + perfNow, perfNow };
            };
        }
        else {
            this.perfNow = () => {
                return Date.now() - timeOrigin;
            };
            this.time = () => {
                const perfNow = this.perfNow();
                return { tsNow: Date.now(), perfNow };
            };
        }
    }
    get isProduction() {
        return Utility._isProduction;
    }
    markProduction() {
        Utility._isProduction = true;
    }
    checkArgument(argument, argKind) {
        if (typeof argKind === 'string') {
            return typeof argument === argKind;
        }
        if (typeof argKind === 'function') {
            return argument instanceof argKind;
        }
        if (Array.isArray(argKind)) {
            return argKind.some((arg) => this.checkArgument(argument, arg));
        }
        throw new Error(`Invalid argKind ${argKind}`);
    }
    requireArgument(argument, argumentName, argKind) {
        let disallowed = argument === undefined || argument === null || argument === '';
        const kindSpecified = argKind !== undefined;
        if (!disallowed && kindSpecified) {
            disallowed = !this.checkArgument(argument, argKind);
        }
        if (disallowed) {
            throw new Error(`${argumentName} argument is required${kindSpecified ? ' and must be of a supported type.' : '.'}`);
        }
    }
    requireArgumentIfDefined(argument, argumentName, argKind) {
        if (argument === undefined) {
            return false;
        }
        const disallowed = argument === null ||
            argument === '' ||
            !this.checkArgument(argument, argKind);
        if (disallowed) {
            throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);
        }
        return true;
    }
    checkForDenyListedValues(argument, argumentName, denyList) {
        if (denyList.some((x) => argument === x)) {
            throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);
        }
    }
    checkForReservedCharacters(argument, argumentName, reservedChars) {
        if (argument && reservedChars.some((c) => argument.indexOf(c) >= 0)) {
            throw new Error(`The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(', ')}']. Received: ${argument}.`);
        }
    }
    generateUniqueId(length = 16) {
        const chars = [];
        const digits = '0123456789abcdef';
        if (!(length === undefined || length > 0)) {
            throw new Error('If specified, the argument "length" must be a positive integer');
        }
        for (let i = 0; i < length; i++) {
            const rand = Math.floor(Math.random() * 16);
            chars.push(digits[rand]);
        }
        return chars.join('');
    }
    getXpath(_element) {
        function hasSameSibs(elm) {
            const name = elm.localName;
            while (elm.nextElementSibling) {
                elm = elm.nextElementSibling;
                if (elm.localName === name) {
                    return true;
                }
            }
            return false;
        }
        function idx(sib, name) {
            if (sib) {
                return (idx(sib.previousElementSibling, name || sib.localName) +
                    (sib.localName === name ? 1 : 0));
            }
            return 1;
        }
        function segs(elm) {
            if (!elm || elm.nodeType !== 1) {
                return [''];
            }
            const nodeValue = idx(elm) > 1 || hasSameSibs(elm)
                ? `${elm.localName.toLowerCase()}[${idx(elm)}]`
                : elm.localName.toLowerCase();
            return [...segs(elm.parentNode), nodeValue];
        }
        return segs(_element).join('/');
    }
    getAge(timestamp) {
        return timestamp - this._timeOrigin;
    }
    getConnectionType() {
        var _a;
        let connectionType;
        if (typeof navigator !== 'undefined') {
            const expNav = navigator;
            connectionType = (_a = expNav === null || expNav === void 0 ? void 0 : expNav.connection) === null || _a === void 0 ? void 0 : _a.effectiveType;
        }
        return connectionType;
    }
    clone(value) {
        return JSON.parse(JSON.stringify(value));
    }
    definedValueOrDefault(value, defaultValue) {
        return value !== undefined ? value : defaultValue;
    }
    getGlobal() {
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        if (typeof self === 'object') {
            return self;
        }
        throw new Error('Unable to locate globalThis or self');
    }
    getIsBeaconSupported() {
        const a = typeof navigator !== undefined &&
            typeof navigator.sendBeacon === 'function' &&
            typeof Blob !== undefined;
        return a;
    }
    estimateObjectSize(object) {
        const objectSet = new Set();
        const stack = [object];
        let bytes = 0;
        while (stack.length) {
            const value = stack.pop();
            if (typeof value === 'boolean') {
                bytes += 4;
            }
            else if (typeof value === 'string') {
                bytes += value.length * 2;
            }
            else if (typeof value === 'number') {
                bytes += 8;
            }
            else if (value instanceof Uint8Array ||
                value instanceof Uint8ClampedArray ||
                value instanceof Uint16Array ||
                value instanceof Uint32Array ||
                value instanceof Int8Array ||
                value instanceof Int16Array ||
                value instanceof Int32Array ||
                value instanceof Float32Array ||
                value instanceof Float64Array) {
                bytes += value.byteLength;
            }
            else if (typeof value === 'object') {
                const obj = value;
                if (!objectSet.has(obj)) {
                    objectSet.add(obj);
                    for (const key in obj) {
                        stack.push(obj[key]);
                    }
                }
            }
        }
        return bytes;
    }
    noProdThrow(e) {
        if (utility.isProduction) {
            return;
        }
        throw e;
    }
}
Utility._isProduction = false;
const utility = Object.freeze(new Utility());

class PublicSafety {
    constructor(_errorCounter) {
        this._errorCounter = _errorCounter;
        this._safeCatchMode = false;
    }
    tryCatch(fn) {
        try {
            fn();
        }
        catch (err) {
            this._prodSafeCatch(err);
        }
    }
    tryCatchReturn(fn, noopValue) {
        try {
            utility.requireArgument(noopValue, 'noopValue');
            return fn();
        }
        catch (err) {
            this._prodSafeCatch(err);
            return noopValue;
        }
    }
    _prodSafeCatch(error) {
        let allowThrow;
        try {
            allowThrow = !utility.isProduction;
            if (allowThrow) {
                throw error;
            }
            if (this._safeCatchMode) {
                this._safeCatchMode = false;
                throw new Error('Internal error in prodSafeCatch.');
            }
            this._safeCatchMode = true;
            if (this._errorCounter) {
                this._errorCounter.increment();
            }
            if (!(error instanceof Error)) {
                const errorText = (error && error.message) ||
                    (typeof error.toString === 'function' ? error.toString() : '');
                error = new Error(errorText);
            }
            this._safeCatchMode = false;
        }
        catch (internalError) {
            if (allowThrow) {
                throw internalError;
            }
            if (internalError && console && typeof console.error === 'function') {
                try {
                    console.error(internalError);
                }
                catch (_a) {
                }
            }
            this._safeCatchMode = false;
        }
    }
}

class SchemaUtil {
    getSchemaId(schema) {
        return `${schema.namespace}.${schema.name}`;
    }
    isInternal(schema) {
        return schema && schema.namespace === 'sf.instrumentation';
    }
    makePayload(schema, data, onlyIfBoth = true) {
        if (!onlyIfBoth || (schema !== undefined && data !== undefined)) {
            return {
                schema,
                payload: data
            };
        }
        return undefined;
    }
    checkSchema(schema) {
        utility.requireArgument(schema, 'schema', 'object');
        utility.requireArgument(schema.namespace, 'schema.namespace', 'string');
        utility.requireArgument(schema.name, 'schema.name', 'string');
        utility.requireArgument(schema.pbjsSchema, 'schema.pbjsSchema', 'object');
        const parts = schema.namespace.split('.');
        if (parts.length !== 2) {
            throw new Error(`Schema "${this.getSchemaId(schema)}" must have a namespace of the form "domain.feature".`);
        }
        return {
            domain: parts[0],
            feature: parts[1],
            message: schema.name
        };
    }
    getAnyNestedObject(schema, scopes) {
        return scopes.reduce((prev, currentScope) => {
            const descriptor = prev.nested;
            if (descriptor) {
                const ano = descriptor[currentScope];
                if (ano) {
                    return ano;
                }
            }
            throw new Error(`Cannot locate ${scopes.join('.')} in schema with ID ${this.getSchemaId(schema)}`);
        }, schema.pbjsSchema);
    }
    getTypes(schema) {
        const schemaTokens = this.checkSchema(schema);
        const namespace = this.getAnyNestedObject(schema, [
            schemaTokens.domain,
            schemaTokens.feature
        ]);
        const descriptor = namespace.nested;
        if (!descriptor) {
            throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);
        }
        return descriptor;
    }
    getType(schema, messageName) {
        utility.requireArgument(messageName, 'messageName', 'string');
        const descriptor = this.getTypes(schema);
        const message = descriptor[messageName];
        if (!message) {
            throw new Error(`Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`);
        }
        return message;
    }
    getOptions(schema, messageName, fieldName) {
        if (fieldName) {
            utility.requireArgument(messageName, 'messageName', 'string');
        }
        const schemaTokens = this.checkSchema(schema);
        if (!messageName) {
            const namespace = this.getAnyNestedObject(schema, [
                schemaTokens.domain,
                schemaTokens.feature
            ]);
            return namespace.options;
        }
        const type = this.getType(schema, messageName);
        if (!fieldName) {
            return type.options;
        }
        const field = type.fields[fieldName];
        if (!field) {
            const schemaId = this.getSchemaId(schema);
            throw new Error(`Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`);
        }
        return field.options;
    }
}
const schemaUtil = new SchemaUtil();

export { LazyMapToList, PublicSafety, schemaUtil, utility };
//# sourceMappingURL=shared.js.map
