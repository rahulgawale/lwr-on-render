{"version":3,"file":"shared.js","sources":["../../../../src/shared/LazyMapToList.ts","../../../../src/shared/Utility.ts","../../../../src/shared/PublicSafety.ts","../../../../src/shared/SchemaUtil.ts"],"sourcesContent":["export class LazyMapToList<Key, ElementType> {\n    private readonly _lazyMap = new Map<Key, Array<ElementType>>();\n\n    private _maxSize: number;\n    constructor(maxSize?: number) {\n        if (maxSize !== undefined) {\n            if (typeof maxSize === 'number' && maxSize > 0) {\n                this._maxSize = Math.ceil(maxSize);\n                return;\n            }\n            throw new Error('maxSize must be a positive number');\n        }\n    }\n\n    get maxSize(): number {\n        return this._maxSize;\n    }\n\n    get size(): number {\n        return this._lazyMap.size;\n    }\n\n    /**\n     * Adds the value to the list specific to the key. If the list doesn't exist,\n     * it will be lazily created as long as there are fewer keys than the max, if specified.\n     *\n     * @param key The key for the map\n     * @param value The value to be added to the list\n     */\n    push(key: Key, value: ElementType): boolean {\n        let buffer = this._lazyMap.get(key);\n        if (!buffer) {\n            if (this.maxSize !== undefined && this.size === this.maxSize) {\n                return false;\n            }\n            buffer = new Array<ElementType>();\n            this._lazyMap.set(key, buffer);\n        }\n        buffer.push(value);\n        return true;\n    }\n\n    getMessages(key: Key, extract?: boolean): Array<ElementType> {\n        const msgs = this._lazyMap.get(key);\n        if (extract && this._lazyMap.has(key)) {\n            this._lazyMap.set(key, []);\n        }\n        return msgs || [];\n    }\n\n    getAllMessages(extract?: boolean): Map<Key, Array<ElementType>> {\n        const map = new Map<Key, Array<ElementType>>();\n        for (const [key, value] of this._lazyMap.entries()) {\n            if (value.length) {\n                map.set(key, this.getMessages(key, extract));\n            }\n        }\n        return map;\n    }\n\n    // Convenience functions for backwards compatibility\n    extractMessages(key: Key): Array<ElementType> {\n        return this.getMessages(key, true);\n    }\n    extractAllMessages(): Map<Key, Array<ElementType>> {\n        return this.getAllMessages(true);\n    }\n\n    get totalItemCount(): number {\n        let count = 0;\n        for (const array of this._lazyMap.values()) {\n            count += array.length;\n        }\n        return count;\n    }\n}\n","import { ObjectType } from './TypeDefinitions';\n\nclass Utility {\n    private static _isProduction = false;\n    public readonly notImplemented = 'Method not implemented.';\n    public readonly perfNow: () => number;\n    public readonly time: () => { tsNow: number; perfNow: number };\n    private readonly _timeOrigin: number;\n\n    constructor() {\n        const performanceExists = typeof performance !== 'undefined';\n        if (performanceExists) {\n            if (performance.timeOrigin) {\n                this._timeOrigin = performance.timeOrigin;\n            } else if (performance.timing && performance.timing.navigationStart) {\n                this._timeOrigin = performance.timing.navigationStart;\n            } else {\n                // if we don't have any start time, we consider our init to be the time origin\n                this._timeOrigin = Date.now();\n            }\n        } else {\n            this._timeOrigin = Date.now();\n        }\n\n        const timeOrigin = this._timeOrigin;\n        if (performanceExists && typeof performance.now === 'function') {\n            this.perfNow = performance.now.bind(performance);\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: timeOrigin + perfNow, perfNow };\n            };\n        } else {\n            this.perfNow = () => {\n                return Date.now() - timeOrigin;\n            };\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: Date.now(), perfNow };\n            };\n        }\n    }\n\n    public get isProduction(): boolean {\n        return Utility._isProduction;\n    }\n\n    public markProduction(): void {\n        // Don't allow production to be set to false once set\n        Utility._isProduction = true;\n    }\n\n    // Returns false if check fails\n    // if argKind is a string, uses typeof.\n    // if argKind is a function, such as String, Number, HTMLElement, uses instanceof.\n    // if argKind is an array, expects at least one of the element types to match.\n    private checkArgument<T>(argument: T, argKind: unknown): boolean {\n        if (typeof argKind === 'string') {\n            return typeof argument === argKind;\n        }\n        if (typeof argKind === 'function') {\n            return argument instanceof argKind;\n        }\n        if (Array.isArray(argKind)) {\n            return argKind.some((arg) => this.checkArgument(argument, arg));\n        }\n        throw new Error(`Invalid argKind ${argKind}`);\n    }\n\n    public requireArgument<T>(argument: T, argumentName: string, argKind?: unknown): void {\n        let disallowed =\n            argument === undefined || argument === null || (argument as unknown) === '';\n        const kindSpecified = argKind !== undefined;\n\n        if (!disallowed && kindSpecified) {\n            disallowed = !this.checkArgument(argument, argKind);\n        }\n\n        if (disallowed) {\n            throw new Error(\n                `${argumentName} argument is required${\n                    kindSpecified ? ' and must be of a supported type.' : '.'\n                }`\n            );\n        }\n    }\n\n    public requireArgumentIfDefined<T>(\n        argument: T,\n        argumentName: string,\n        argKind: unknown\n    ): boolean {\n        if (argument === undefined) {\n            return false;\n        }\n        const disallowed =\n            argument === null ||\n            (argument as unknown) === '' ||\n            !this.checkArgument(argument, argKind);\n\n        if (disallowed) {\n            throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);\n        }\n\n        return true;\n    }\n\n    public checkForDenyListedValues<T>(\n        argument: T,\n        argumentName: string,\n        denyList: ReadonlyArray<T>\n    ): void {\n        if (denyList.some((x) => argument === x)) {\n            throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);\n        }\n    }\n\n    public checkForReservedCharacters(\n        argument: string,\n        argumentName: string,\n        reservedChars: ReadonlyArray<string>\n    ): void {\n        if (argument && reservedChars.some((c) => argument.indexOf(c) >= 0)) {\n            throw new Error(\n                `The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(\n                    ', '\n                )}']. Received: ${argument}.`\n            );\n        }\n    }\n\n    public generateUniqueId(length = 16): string {\n        const chars: string[] = [];\n        const digits = '0123456789abcdef';\n        if (!(length === undefined || length > 0)) {\n            throw new Error('If specified, the argument \"length\" must be a positive integer');\n        }\n        for (let i = 0; i < length; i++) {\n            const rand = Math.floor(Math.random() * 16);\n            chars.push(digits[rand]);\n        }\n        return chars.join('');\n    }\n\n    public getXpath(_element: HTMLElement): string {\n        //if the element has siblings with the same type we should return 1, otherwise not\n        function hasSameSibs(elm: Element): boolean {\n            const name = elm.localName;\n            while (elm.nextElementSibling) {\n                elm = elm.nextElementSibling;\n                if (elm.localName === name) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function idx(sib: Element, name?: string): number {\n            //we want to count the siblings of the same type for the xpath, otherwise it is just 1\n            if (sib) {\n                return (\n                    idx(sib.previousElementSibling, name || sib.localName) +\n                    (sib.localName === name ? 1 : 0)\n                );\n            }\n            return 1;\n        }\n        function segs(elm: HTMLElement): string[] {\n            // only run for element nodes\n            if (!elm || elm.nodeType !== 1) {\n                return [''];\n            }\n            //only add the number if it is over 1, or if it the first of siblings\n            const nodeValue =\n                idx(elm) > 1 || hasSameSibs(elm)\n                    ? `${elm.localName.toLowerCase()}[${idx(elm)}]`\n                    : elm.localName.toLowerCase();\n            //go up and add the element at the end of the path\n            return [...segs(elm.parentNode as HTMLElement), nodeValue];\n        }\n        //concat at the end\n        return segs(_element).join('/');\n    }\n\n    public getAge(timestamp: number): number {\n        return timestamp - this._timeOrigin;\n    }\n\n    public getConnectionType(): string {\n        let connectionType;\n        if (typeof navigator !== 'undefined') {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection\n            type NavigatorExperimental = {\n                connection: {\n                    effectiveType: string;\n                };\n            };\n            const expNav = navigator as unknown as NavigatorExperimental;\n            connectionType = expNav?.connection?.effectiveType;\n        }\n        return connectionType;\n    }\n\n    public clone<T>(value: T): T {\n        return JSON.parse(JSON.stringify(value));\n    }\n\n    public definedValueOrDefault<T>(value: T, defaultValue: T): T {\n        return value !== undefined ? value : defaultValue;\n    }\n\n    public getGlobal(): typeof globalThis {\n        if (typeof globalThis === 'object') {\n            return globalThis;\n        }\n        if (typeof self === 'object') {\n            return self;\n        }\n        throw new Error('Unable to locate globalThis or self');\n    }\n\n    public getIsBeaconSupported(): boolean {\n        const a =\n            typeof navigator !== undefined &&\n            typeof navigator.sendBeacon === 'function' &&\n            typeof Blob !== undefined;\n        return a;\n    }\n\n    public estimateObjectSize(object: unknown): number {\n        const objectSet = new Set<ObjectType>();\n        const stack: Array<unknown> = [object];\n        let bytes = 0;\n\n        while (stack.length) {\n            const value: unknown = stack.pop();\n            if (typeof value === 'boolean') {\n                bytes += 4;\n            } else if (typeof value === 'string') {\n                bytes += value.length * 2;\n            } else if (typeof value === 'number') {\n                bytes += 8;\n            } else if (\n                value instanceof Uint8Array ||\n                value instanceof Uint8ClampedArray ||\n                value instanceof Uint16Array ||\n                value instanceof Uint32Array ||\n                value instanceof Int8Array ||\n                value instanceof Int16Array ||\n                value instanceof Int32Array ||\n                value instanceof Float32Array ||\n                value instanceof Float64Array\n            ) {\n                bytes += value.byteLength;\n            } else if (typeof value === 'object') {\n                const obj: ObjectType = value as ObjectType;\n                if (!objectSet.has(obj)) {\n                    objectSet.add(obj);\n                    for (const key in obj) {\n                        stack.push(obj[key]);\n                    }\n                }\n            }\n        }\n        return bytes;\n    }\n\n    // swallows exceptions on production.\n    // Ensure that code that follows this call is a proper no-op.\n    noProdThrow(e: unknown): void | never {\n        if (utility.isProduction) {\n            return;\n        }\n        throw e;\n    }\n}\n\nexport const utility = Object.freeze(new Utility());\n","import { UpCounter } from '../interfaces';\nimport { utility } from './Utility';\n\nexport class PublicSafety {\n    private _safeCatchMode = false;\n\n    constructor(private readonly _errorCounter?: UpCounter) {}\n\n    /**\n     * Instrumentation should never throw in production. Therefore, we need to include in\n     * all our public methods a top-most try/catch wrapper. Simply use this function\n     * as your first and only top-level call in the function block and sleep well at night.\n     *\n     * @param fn The body of the unsafe function that doesn't return a value but can throw\n     */\n    tryCatch(fn: () => void): void {\n        try {\n            fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n        }\n    }\n\n    /**\n     *\n     * @param fn The body of the unsafe function that returns a value and that can throw\n     * @param noopValue A static, noop instance of V (like a mock) that will be returned in case\n     * the function could not be called.\n     */\n    tryCatchReturn<V>(fn: () => V, noopValue: V): V {\n        try {\n            utility.requireArgument(noopValue, 'noopValue');\n            return fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n            return noopValue;\n        }\n    }\n\n    /**\n     * Safely handles exceptions. Suppresses throws in a production environment.\n     * This method is intended to be called inside a catch block.\n     *\n     * @param error The error that was caught\n     */\n    private _prodSafeCatch(error: unknown): void {\n        let allowThrow;\n        try {\n            allowThrow = !utility.isProduction;\n            if (allowThrow) {\n                // Just throw the error in development\n                throw error;\n            }\n\n            if (this._safeCatchMode) {\n                // If we're here, that means code in the try block of prodSafeCatch itself is throwing an error\n                // (i.e. prodSafeCatch is already on the stack). Break out now to prevent infinite loop.\n                this._safeCatchMode = false;\n\n                throw new Error('Internal error in prodSafeCatch.');\n            }\n\n            this._safeCatchMode = true;\n            if (this._errorCounter) {\n                this._errorCounter.increment();\n            }\n\n            if (!(error instanceof Error)) {\n                const errorText =\n                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n                    (error && (error as any).message) ||\n                    (typeof error.toString === 'function' ? error.toString() : '');\n                error = new Error(errorText);\n            }\n\n            // If not allowed to throw the error, at least try to log it\n            // TODO: This error should be attributed to the global Instrumentation (not to \"this\")\n            // this.error(error);\n            this._safeCatchMode = false;\n        } catch (internalError) {\n            // Do not call any methods in this catch block except for console.error\n\n            if (allowThrow) {\n                // pass it along\n                throw internalError;\n            }\n\n            // eslint-disable-next-line no-console\n            if (internalError && console && typeof console.error === 'function') {\n                try {\n                    // eslint-disable-next-line no-console\n                    console.error(internalError);\n                } catch {\n                    // Nothing we can do at this point\n                }\n            }\n            this._safeCatchMode = false;\n        }\n    }\n}\n","import { IField, INamespace, IType, Schema, SchematizedPayload, SchemaTokens } from '../interfaces';\nimport {\n    AnyNestedObject,\n    PbjsNestedObjectDescriptor,\n    ProtoOptions,\n    SchematizedData\n} from './TypeDefinitions';\nimport { utility } from './Utility';\n\nclass SchemaUtil {\n    public getSchemaId(schema: Schema): string {\n        return `${schema.namespace}.${schema.name}`;\n    }\n    public isInternal(schema: Schema): boolean {\n        return schema && schema.namespace === 'sf.instrumentation';\n    }\n\n    public makePayload(\n        schema: Schema,\n        data: SchematizedData,\n        onlyIfBoth = true\n    ): SchematizedPayload {\n        if (!onlyIfBoth || (schema !== undefined && data !== undefined)) {\n            return {\n                schema,\n                payload: data\n            };\n        }\n        return undefined;\n    }\n\n    public checkSchema(schema: Schema): SchemaTokens {\n        utility.requireArgument(schema, 'schema', 'object');\n        utility.requireArgument(schema.namespace, 'schema.namespace', 'string');\n        utility.requireArgument(schema.name, 'schema.name', 'string');\n        utility.requireArgument(schema.pbjsSchema, 'schema.pbjsSchema', 'object');\n        const parts: string[] = schema.namespace.split('.');\n        if (parts.length !== 2) {\n            throw new Error(\n                `Schema \"${this.getSchemaId(\n                    schema\n                )}\" must have a namespace of the form \"domain.feature\".`\n            );\n        }\n        return {\n            domain: parts[0],\n            feature: parts[1],\n            message: schema.name\n        };\n    }\n\n    private getAnyNestedObject(schema: Schema, scopes: string[]): AnyNestedObject {\n        return scopes.reduce((prev: INamespace, currentScope: string) => {\n            const descriptor: PbjsNestedObjectDescriptor = prev.nested;\n            if (descriptor) {\n                const ano: AnyNestedObject = descriptor[currentScope];\n                if (ano) {\n                    return ano;\n                }\n            }\n            throw new Error(\n                `Cannot locate ${scopes.join('.')} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }, schema.pbjsSchema);\n    }\n\n    public getTypes(schema: Schema): PbjsNestedObjectDescriptor {\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n        const namespace: INamespace = this.getAnyNestedObject(schema, [\n            schemaTokens.domain,\n            schemaTokens.feature\n        ]);\n        const descriptor: PbjsNestedObjectDescriptor = namespace.nested;\n        if (!descriptor) {\n            throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);\n        }\n        return descriptor;\n    }\n\n    public getType(schema: Schema, messageName: string): IType {\n        utility.requireArgument(messageName, 'messageName', 'string');\n        const descriptor: PbjsNestedObjectDescriptor = this.getTypes(schema);\n\n        const message = descriptor[messageName] as IType;\n        if (!message) {\n            throw new Error(\n                `Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }\n        return message;\n    }\n\n    public getOptions(schema: Schema, messageName?: string, fieldName?: string): ProtoOptions {\n        if (fieldName) {\n            utility.requireArgument(messageName, 'messageName', 'string');\n        }\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n\n        if (!messageName) {\n            const namespace: INamespace = this.getAnyNestedObject(schema, [\n                schemaTokens.domain,\n                schemaTokens.feature\n            ]);\n            return namespace.options;\n        }\n\n        const type: IType = this.getType(schema, messageName);\n        if (!fieldName) {\n            return type.options;\n        }\n\n        const field: IField = type.fields[fieldName];\n        if (!field) {\n            const schemaId = this.getSchemaId(schema);\n            throw new Error(\n                `Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`\n            );\n        }\n        return field.options;\n    }\n}\n\nexport const schemaUtil = new SchemaUtil();\n"],"names":[],"mappings":"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"}