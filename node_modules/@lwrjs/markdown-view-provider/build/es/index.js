import { getViewSourceFromFile, canResolveView, setupWatcher } from '@lwrjs/shared-utils';
import path from 'path';
import grayMatter from 'gray-matter';
import createMarkdownParser from './markdown-parser/markdown-parser.js';
import vfile from 'vfile';
function canResolve(route) {
    return !route.rootComponent && !!route.contentTemplate && canResolveView(route.contentTemplate, 'md');
}
export default class MarkdownViewProvider {
    constructor(pluginConfig = {}, providerConfig) {
        this.cachedViews = new Map();
        this.pluginConfig = pluginConfig;
        this.routes = providerConfig.config.routes;
        this.name = 'lwr-markdown-view-provider';
        this.emitter = providerConfig.appEmitter;
        // Setup watcher
        const { runtimeEnvironment: { watchFiles }, } = providerConfig;
        if (watchFiles) {
            this.watcher = setupWatcher(this.onModuleChange.bind(this));
        }
    }
    async onModuleChange(fileChanged) {
        const cachedView = this.cachedViews.get(fileChanged);
        if (!cachedView) {
            throw new Error('We are observing a file we have not yet processed, this shouldnt happen...');
        }
        const compiledView = await this.getView(cachedView.viewId);
        if (!compiledView) {
            throw new Error('Unable to get compiledView');
        }
        this.emitter.notifyViewSourceChanged(compiledView);
    }
    // -- Public API --------------------------------------------------------------------
    async initialize() {
        // create/initialize the markdown render to render .md content templates.
        this.markdown = await createMarkdownParser(this.pluginConfig.parserOptions);
        return;
    }
    async getView(viewId) {
        // This View Provider can't handle SPAs
        if (!viewId.contentTemplate || !canResolve(viewId)) {
            return;
        }
        if (!this.markdown) {
            throw new Error('Markdown View Provider must be initialized');
        }
        // Retrieve the file contents and create the Compiled View
        const viewSource = getViewSourceFromFile(viewId.contentTemplate);
        const { content, data: viewMetadata } = grayMatter(viewSource.originalSource);
        // Keeping this information in vfile which will be passed to plugins.
        const vFile = vfile({ path: viewId.contentTemplate, contents: content });
        const { html, metadata: markdownMetadata } = await this.markdown.render(vFile);
        const { layoutTemplate, ...nonLwrManagedMetadata } = viewMetadata;
        const compiledView = {
            ...viewSource,
            layoutTemplate,
            properties: {
                ...nonLwrManagedMetadata,
                ...markdownMetadata,
            },
            viewId,
            render: async () => {
                return {
                    renderedView: html,
                };
            },
        };
        // Watch for changes
        const fullPath = path.resolve(viewId.contentTemplate);
        if (this.watcher && !this.cachedViews.has(fullPath)) {
            this.cachedViews.set(fullPath, { compiledView, viewId });
            this.watcher.add(fullPath);
        }
        return compiledView;
    }
}
//# sourceMappingURL=index.js.map