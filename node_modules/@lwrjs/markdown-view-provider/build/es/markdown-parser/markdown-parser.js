import unified from 'unified';
import markdown from 'remark-parse';
import remark2rehype from 'remark-rehype';
import gfm from 'remark-gfm';
import html from 'rehype-stringify';
import { getHtmlHighlighter } from './plugins/highlighter.js';
import rawHtml from 'rehype-raw';
import { mdMetadataCollector } from './plugins/md-metadata-collector.js';
import { slug } from './plugins/html-slug.js';
import { htmlMetadataCollector } from './plugins/html-meta-collector.js';
export default async function markdownParser(options = {}) {
    const { markdownPlugins = [], htmlPlugins = [], codeHighlightTheme = 'light-plus' } = options;
    // get the appropriate highlighter for parser/renderer.
    // This is an potentially expensive call (due to Shiki) and should remain shared across renderering invocations.
    const highlighter = await getHtmlHighlighter({ theme: codeHighlightTheme });
    return {
        async render(vFile) {
            const collector = {};
            const processor = unified()
                .use(markdown)
                .use(gfm)
                // Custom Markdown plugins
                .use(markdownPlugins)
                .use(mdMetadataCollector, { collector })
                // Note that the following two plugins go hand in hand
                // to parse correctly embedded HTML (uses parse5 underneath)
                // This opens the door of XSS is we don't own and control the author of the markdown
                // https://github.com/syntax-tree/hast-util-raw#security
                .use(remark2rehype, { allowDangerousHtml: true })
                .use(rawHtml) // this reifies html content
                // Custom HTML plugins
                .use(slug)
                .use(htmlPlugins)
                .use(htmlMetadataCollector, { collector })
                .use(highlighter)
                .use(html);
            const result = await processor.process(vFile);
            const { customElements = [], headings = [], images = [] } = collector;
            return {
                html: result.contents.toString(),
                metadata: {
                    customElements,
                    images,
                    headings,
                },
            };
        },
    };
}
//# sourceMappingURL=markdown-parser.js.map