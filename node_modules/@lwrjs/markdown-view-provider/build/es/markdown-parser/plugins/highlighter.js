import hastUtilToString from 'hast-util-to-string';
import isElement from 'hast-util-is-element';
import visit from 'unist-util-visit';
import * as Shiki from 'shiki';
/**
 * Generates an configured unified.Plugin for highlighting `code` snippets.
 * @param options Allow the configuration of the HTML Highlighter (e.g. the `theme` used).
 * @returns An unified Plugin with the HTML Transformer.
 */
export async function getHtmlHighlighter({ theme }) {
    // By default the Shiki highlighter loads all the languages upfront, which can take up to 500 ms.
    //
    // It's currently impossible to create a `Highlighter` without preloading only language
    // (https://github.com/shikijs/shiki/issues/326). In the mean time, we forcing the highlighter
    // to only load JavaScript.
    const highlighter = await Shiki.getHighlighter({
        theme,
        langs: ['javascript'],
    });
    const languageRegistry = {
        loaded: new Set(highlighter.getLoadedLanguages()),
        unknown: new Set(),
    };
    async function loadMissingLanguages(langs) {
        const promises = [];
        for (const lang of langs) {
            if (!languageRegistry.loaded.has(lang) && !languageRegistry.unknown.has(lang)) {
                promises.push(highlighter.loadLanguage(lang).then(() => languageRegistry.loaded.add(lang), () => languageRegistry.unknown.add(lang)));
            }
        }
        await Promise.all(promises);
    }
    return function htmlHighlighter() {
        return async function (tree) {
            const highlightCandidates = [];
            visit(tree, 'element', (node, index, parent) => {
                // Ignore non-code elements: pre > code.
                if (!isElement(node) ||
                    node.tagName !== 'code' ||
                    !isElement(parent) ||
                    parent.tagName !== 'pre') {
                    return;
                }
                // Ignore node if no language is specified.
                const lang = getLanguage(node);
                if (lang) {
                    highlightCandidates.push({ parent, node, lang });
                }
            });
            const langs = new Set(highlightCandidates.map(({ lang }) => lang));
            await loadMissingLanguages(langs);
            for (const { parent, node, lang } of highlightCandidates) {
                if (languageRegistry.loaded.has(lang)) {
                    const tokens = highlighter.codeToThemedTokens(hastUtilToString(node), lang, theme);
                    // Add background color and class name to the <pre> element.
                    addClassToHastElement(parent, 'shiki');
                    const backgroundColor = highlighter.getBackgroundColor(theme);
                    addStyleToHastElement(parent, `background-color: ${backgroundColor}`);
                    // Replace the <code> element with highlighted nodes.
                    node.children = tokensToHast(tokens);
                }
            }
        };
    };
}
function getLanguage(node) {
    const className = node.properties?.className;
    if (className) {
        for (const part of className) {
            const match = part.match(/language-(\w+)/);
            if (match) {
                return match[1];
            }
        }
    }
    return undefined;
}
function addClassToHastElement(elm, klass) {
    const properties = elm.properties || {};
    const className = properties.className || [];
    className.push(klass);
    properties.className = className;
    elm.properties = properties;
}
function addStyleToHastElement(elm, style) {
    const properties = elm.properties || {};
    const styles = properties.style || [];
    styles.push(style);
    properties.style = styles;
    elm.properties = properties;
}
function tokensToHast(lines) {
    const tree = [];
    for (const line of lines) {
        if (line.length === 0) {
            tree.push({
                type: 'text',
                value: '\n',
            });
        }
        else {
            for (const token of line) {
                tree.push({
                    type: 'element',
                    tagName: 'span',
                    properties: {
                        style: tokenToStyle(token),
                    },
                    children: [
                        {
                            type: 'text',
                            value: token.content,
                        },
                    ],
                });
            }
            tree.push({
                type: 'text',
                value: '\n',
            });
        }
    }
    // Remove trailing newline at the end of the code block.
    tree.pop();
    return tree;
}
function tokenToStyle(token) {
    const styles = [];
    if (token.color) {
        styles.push(`color: ${token.color}`);
    }
    if (token.fontStyle) {
        if (token.fontStyle & Shiki.FontStyle.Bold) {
            styles.push('font-weight: bold');
        }
        if (token.fontStyle & Shiki.FontStyle.Italic) {
            styles.push('font-style: italic');
        }
        if (token.fontStyle & Shiki.FontStyle.Underline) {
            styles.push('text-decoration: underline');
        }
    }
    return styles;
}
//# sourceMappingURL=highlighter.js.map