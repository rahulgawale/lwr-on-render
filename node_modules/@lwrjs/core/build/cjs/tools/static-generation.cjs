var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/tools/static-generation.ts
__markAsModule(exports);
__export(exports, {
  ViewImportMetadataImpl: () => ViewImportMetadataImpl,
  default: () => static_generation_default
});
var import_perf_hooks = __toModule(require("perf_hooks"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_path = __toModule(require("path"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_stream = __toModule(require("./utils/stream.cjs"));
var import_dir = __toModule(require("./utils/dir.cjs"));
var import_config = __toModule(require("@lwrjs/config"));
var SiteGenerator = class {
  async buildStaticApplication(config, dispatcher) {
    const startTime = import_perf_hooks.performance.now();
    import_shared_utils.logger.info("[Static Generation] starting");
    if (!import_shared_utils.logger.currentLevel || import_shared_utils.logger.currentLevel == import_shared_utils.WARN || import_shared_utils.logger.currentLevel == import_shared_utils.INFO) {
      import_shared_utils.logger.setOptions({dedupe: new Set([import_shared_utils.WARN])});
    }
    const {routes, staticSiteGenerator, rootDir, assets} = config;
    if (!staticSiteGenerator.outputDir) {
      staticSiteGenerator.outputDir = "__generated_site__";
    }
    const outputDir = (0, import_path.join)(rootDir, staticSiteGenerator.outputDir);
    import_shared_utils.logger.info(`Clear Output Location: ${outputDir}`);
    import_fs_extra.default.rmSync(outputDir, {recursive: true, force: true});
    const urlRewriteMap = new Map();
    const {apiVersion, basePath, lwrVersion, serverMode} = config;
    const runtimeEnvironment = {
      ...(0, import_config.explodeMode)(serverMode),
      apiVersion,
      basePath,
      lwrVersion,
      debug: false,
      serverMode
    };
    await this.generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, dispatcher, outputDir, urlRewriteMap);
    this.writeNetlifyRedirectConfig(outputDir, urlRewriteMap);
    this.copyAssets(assets, outputDir);
    const endTime = import_perf_hooks.performance.now();
    const timeDiff = (endTime - startTime) / 1e3;
    import_shared_utils.logger.info(`[Static Generation] complete in ${Math.round(timeDiff)} seconds`);
  }
  async generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, dispatcher, outputDir, urlRewriteMap = new Map()) {
    if (!staticSiteGenerator.locales) {
      staticSiteGenerator.locales = ["en-US"];
    }
    const generateUrl = this.createGenerateURLFunction(dispatcher);
    for (const locale of staticSiteGenerator.locales) {
      for (const route of routes) {
        const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
        await generateUrl(route.path, siteConfig);
      }
      if (staticSiteGenerator._additionalRoutePaths) {
        for (const uri of staticSiteGenerator._additionalRoutePaths) {
          const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
          await generateUrl(uri, siteConfig);
        }
      }
      const {_additionalModules} = staticSiteGenerator;
      if (_additionalModules) {
        for (const specifier of _additionalModules) {
          const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
          await this.dispatchJSResourceRecursive(specifier, dispatcher, siteConfig, true);
        }
      }
    }
  }
  createGenerateURLFunction(dispatcher) {
    const generateRoute = async (uri, siteConfig) => {
      const locale = siteConfig.locale;
      import_shared_utils.logger.info(`Start Generate: ${locale} ${uri}`);
      await this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "route"}, siteConfig);
      this.addAdditionalImportMetadataToViewConfig(siteConfig);
      import_shared_utils.logger.info(`End Generate ${locale} ${uri}`);
    };
    return generateRoute.bind(this);
  }
  async dispatchResourceRecursive(url, dispatcher, resourceOpts, siteConfig) {
    const {visitedUrls} = siteConfig;
    if (!visitedUrls.has(url)) {
      visitedUrls.add(url);
      if (url.indexOf("/:") !== -1 || url.indexOf("*") !== -1) {
        import_shared_utils.logger.warn("Skipped generation of url with variable path segment: " + url);
        return;
      }
      let context;
      context = await dispatcher.dispatchUrl(url, "GET", siteConfig.locale);
      if (context?.fs?.headers?.Location) {
        const redirectUrl = context?.fs?.headers?.Location;
        url = redirectUrl;
        const redirectContext = await dispatcher.dispatchUrl(url, "GET", siteConfig.locale);
        context = redirectContext;
      }
      const {resourceType} = resourceOpts;
      if (resourceType === "route") {
        await this.handleHtmlResource(url, context, siteConfig, dispatcher);
      } else if (resourceType === "asset" || resourceType === "resource") {
        await this.handleAssetOrResource(url, context, siteConfig, dispatcher);
      } else if (resourceType == "mapping") {
        await this.handleMappingResource(url, context, siteConfig, dispatcher);
      } else if (resourceType === "js") {
        await this.handleJavascriptResource(url, context, siteConfig, dispatcher);
      }
    }
  }
  async handleJavascriptResource(url, context, siteConfig, dispatcher) {
    const {outputDir} = siteConfig;
    const normalizedUrl = decodeURIComponent(url);
    (0, import_dir.createResourceDir)((0, import_path.dirname)(normalizedUrl), outputDir);
    const ext = (0, import_path.extname)(normalizedUrl);
    const fullPath = (0, import_path.join)(outputDir, `${normalizedUrl}${ext ? "" : ".js"}`);
    await (0, import_stream.writeResponse)(context, fullPath);
    const dispatchRequests = [];
    if (normalizedUrl.indexOf("/s/") !== -1) {
      siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf("/s/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf("/s/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf("/v/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf("%2Fv%2F")), normalizedUrl);
    }
    const moduleDefinition = context.fs?.metadata?.moduleDefinition;
    if (moduleDefinition) {
      const imports = moduleDefinition.linkedModuleRecord?.imports || moduleDefinition.bundleRecord?.imports || [];
      for (const importModule of imports) {
        const jsUri = importModule.specifier.startsWith("/") ? importModule.specifier : (0, import_shared_utils.getSpecifier)(importModule);
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
      const dynamicImports = moduleDefinition.linkedModuleRecord?.dynamicImports || moduleDefinition.bundleRecord?.dynamicImports || [];
      for (const importModule of dynamicImports) {
        const jsUri = importModule.specifier.startsWith("/") ? importModule.specifier : (0, import_shared_utils.getSpecifier)(importModule);
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
    }
    const uris = context.fs?.metadata?.resolvedUris || [];
    for (const jsUri of uris) {
      dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
    }
    await Promise.all(dispatchRequests);
  }
  async handleMappingResource(url, context, siteConfig, dispatcher) {
    const {importMetadata: importMetatdata} = siteConfig;
    const statusCode = context.response?.status;
    if (statusCode === 200) {
      const newImportMetadata = context.fs?.body;
      let filteredImportMetadata;
      if (!importMetatdata) {
        filteredImportMetadata = newImportMetadata;
      } else {
        filteredImportMetadata = importMetatdata.addAdditionalMetadata(newImportMetadata);
      }
      const dispatchRequests = [];
      for (const uri of Object.keys(filteredImportMetadata.imports)) {
        dispatchRequests.push(this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "js"}, siteConfig));
      }
      await Promise.all(dispatchRequests);
    } else {
      const body = context.fs?.body;
      import_shared_utils.logger.warn(`Failed to fetch ${url}: (${statusCode}) ${body}`);
    }
  }
  async handleHtmlResource(url, context, siteConfig, dispatcher) {
    const {outputDir} = siteConfig;
    let fileName = "index.html";
    let directoryPath = url;
    if (url.endsWith(".html") || url.endsWith(".xml")) {
      const lastPathIndex = url.lastIndexOf("/") + 1;
      fileName = url.substring(lastPathIndex, url.length);
      directoryPath = url.substring(0, lastPathIndex);
    }
    const dir = (0, import_dir.createResourceDir)(directoryPath, outputDir);
    const localeDir = (0, import_dir.createResourceDir)(directoryPath, (0, import_path.join)(outputDir, siteConfig.locale));
    const filePath = (0, import_path.join)(dir, fileName);
    const fileLocalePath = (0, import_path.join)(localeDir, fileName);
    if (siteConfig.locale.toLowerCase().startsWith("en")) {
      siteConfig.viewPaths.add(filePath);
      await (0, import_stream.writeResponse)(context, filePath);
    }
    (0, import_dir.createDir)(localeDir);
    siteConfig.viewPaths.add(fileLocalePath);
    await (0, import_stream.writeResponse)(context, fileLocalePath);
    const viewDefinition = context.fs?.metadata?.viewDefinition;
    if (viewDefinition) {
      await this.handleViewDefinition(viewDefinition, siteConfig, dispatcher);
    }
  }
  async handleViewDefinition(viewDefinition, siteConfig, dispatcher) {
    if (viewDefinition.viewRecord.importMetadata) {
      siteConfig.importMetadata = new ViewImportMetadataImpl(viewDefinition.viewRecord.importMetadata);
    }
    const dispatchRequests = [];
    const assets = viewDefinition.viewRecord.assetReferences || [];
    for (const asset of assets) {
      const assetUrl = asset.override?.uri || asset.url;
      if (assetUrl && !(0, import_shared_utils.isSelfUrl)(assetUrl)) {
        dispatchRequests.push(this.dispatchResourceRecursive(assetUrl, dispatcher, {resourceType: "asset", asset}, siteConfig));
      }
    }
    const customElements = viewDefinition.viewRecord.customElements || [];
    for (const customElement of customElements) {
      const jsUris = Object.values(customElement.flatGraph.uriMap);
      for (const jsUri of jsUris) {
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
    }
    if (viewDefinition.viewRecord.bootstrapModule) {
      const boot = viewDefinition.viewRecord.bootstrapModule;
      const jsUris = Object.values(boot.flatGraph.uriMap);
      for (const jsUri of jsUris) {
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
    }
    const bootstrapResources = viewDefinition.viewRecord.bootstrapModule?.resources || [];
    for (const resource of bootstrapResources) {
      if (!resource.inline) {
        const resourceUri = resource.src || resource.specifier;
        if (resourceUri) {
          dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, {resourceType: "resource"}, siteConfig));
          if (resourceUri.match(/\/application\/.*\/ai\/.*\/configuration/)) {
            siteConfig.viewConfigPath = this.getResourcePathFromUrl(siteConfig, resourceUri);
          }
        } else {
          import_shared_utils.logger.warn("Skipped inline bootstrap resource: %j", resource);
        }
      }
    }
    const resources = viewDefinition.viewRecord.resources || [];
    for (const resource of resources) {
      const resourceUri = resource.src || resource.specifier || "";
      if (resourceUri.startsWith("/")) {
        dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, {resourceType: "resource"}, siteConfig));
      } else {
        import_shared_utils.logger.warn("Skipped resource: %j", resource);
      }
    }
    await Promise.all(dispatchRequests);
  }
  async dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig, isAdditionalModulesRequest) {
    if (jsUri.startsWith("/")) {
      await this.dispatchResourceRecursive(jsUri, dispatcher, {resourceType: "js"}, siteConfig);
    } else {
      const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
      if (supportsFingerprints) {
        const mappingEndpoint = siteConfig.endpoints?.uris?.mapping;
        if (mappingEndpoint) {
          const mappingURL = siteConfig.endpoints?.uris?.mapping + encodeURIComponent(jsUri);
          await this.dispatchResourceRecursive(mappingURL, dispatcher, {resourceType: "mapping"}, siteConfig);
        } else {
          import_shared_utils.logger.warn('Unable to fetch mapping for bare specifier or variable dynamic import: "' + jsUri + '"');
        }
      } else if (isAdditionalModulesRequest) {
        const uri = `${siteConfig.endpoints?.uris.legacyDefault}${encodeURIComponent(jsUri)}`;
        await this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "js"}, siteConfig);
      }
    }
  }
  async handleAssetOrResource(url, context, siteConfig, dispatcher) {
    const metadata = context.fs?.metadata;
    const fullPath = this.getResourcePathFromUrl(siteConfig, url);
    await (0, import_stream.writeResponse)(context, fullPath);
    const assetReferences = metadata?.asset?.metadata?.assetReferences || [];
    const dispatchRequests = [];
    for (const ref of assetReferences) {
      const refUrl = ref.override?.uri || ref.url;
      dispatchRequests.push(this.dispatchResourceRecursive(refUrl, dispatcher, {resourceType: "asset", asset: metadata?.asset}, siteConfig).catch((err) => {
        import_shared_utils.logger.warn(`Failed to fetch asset reference => ${refUrl} from ${url}`, err);
      }));
    }
    return Promise.all(dispatchRequests);
  }
  getResourcePathFromUrl(siteConfig, url) {
    const {outputDir} = siteConfig;
    const normalizedUrl = decodeURIComponent(url);
    (0, import_dir.createResourceDir)((0, import_path.dirname)(normalizedUrl), outputDir);
    const fullPath = (0, import_path.join)(outputDir, normalizedUrl);
    return fullPath;
  }
  writeNetlifyRedirectConfig(outputDir, urlRewriteMap) {
    const serveJsonPath = (0, import_path.join)(outputDir, "serve.json");
    const _redirectsPath = (0, import_path.join)(outputDir, "_redirects");
    if (import_fs_extra.default.existsSync(_redirectsPath)) {
      import_fs_extra.default.unlinkSync(_redirectsPath);
    }
    import_fs_extra.default.createFileSync(_redirectsPath);
    const rewrites = [];
    urlRewriteMap.forEach((destination, source) => {
      rewrites.push({
        source,
        destination
      });
      import_fs_extra.default.appendFileSync(_redirectsPath, source + " " + destination + " 302!\n");
    });
    import_fs_extra.default.writeFileSync(serveJsonPath, JSON.stringify({rewrites, directoryListing: false, renderSingle: true}, null, 1));
  }
  copyAssets(assets, outputDir) {
    for (const asset of assets) {
      try {
        const assetSrcDir = asset.dir || asset.file;
        const assetOutputDir = (0, import_path.join)(outputDir, asset.urlPath);
        if (assetSrcDir && import_fs_extra.default.existsSync(assetSrcDir)) {
          import_fs_extra.default.copySync(assetSrcDir, assetOutputDir);
        } else {
          import_shared_utils.logger.warn("Could not find assets to copy at path: " + assetSrcDir);
        }
      } catch (e) {
        import_shared_utils.logger.error("Error occurred processing asset config: " + JSON.stringify(asset), e);
      }
    }
  }
  createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment) {
    const featureFlags = this.filterFeatureFlags();
    const endpoints = {
      uris: {
        legacyDefault: (0, import_shared_utils.getModuleUriPrefix)(runtimeEnvironment, {locale}),
        mapping: (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, {locale})
      }
    };
    return {
      outputDir,
      viewPaths: new Set(),
      visitedUrls: new Set(),
      locale,
      urlRewriteMap,
      endpoints,
      ...featureFlags
    };
  }
  filterFeatureFlags() {
    if ((0, import_shared_utils.getFeatureFlags)().LEGACY_LOADER) {
      return {featureFlags: {LEGACY_LOADER: true}};
    } else {
      return void 0;
    }
  }
  addAdditionalImportMetadataToViewConfig(siteConfig) {
    const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
    const additionalImportMetadata = siteConfig?.importMetadata?.getAdditionalImportMetadata();
    if (supportsFingerprints && siteConfig.viewConfigPath && additionalImportMetadata?.imports && Object.keys(additionalImportMetadata.imports).length > 0) {
      const imports = additionalImportMetadata.imports ? JSON.stringify(additionalImportMetadata.imports) : "{}";
      const initImports = `if (!globalThis.LWR.imports) { globalThis.LWR.imports = {}; }`;
      const mergeImports = `Object.assign(globalThis.LWR.imports, ${imports})`;
      const index = additionalImportMetadata.index ? JSON.stringify(additionalImportMetadata.index) : "{}";
      const initIndex = `if (!globalThis.LWR.index) { globalThis.LWR.index = {}; }`;
      const mergeIndex = `Object.assign(globalThis.LWR.index, ${index})`;
      const oldConfig = import_fs_extra.default.readFileSync(siteConfig.viewConfigPath, "utf-8");
      const newConfig = `${oldConfig}
// Appended by Static Site Generator
${initImports}
${mergeImports}
${initIndex}
${mergeIndex}
`;
      const configHash = (0, import_shared_utils.hashContent)(newConfig);
      const sigRegex = /\/s\/[a-z0-9]+\/config\.js/i;
      const configSuffix = `/s/${configHash}/config.js`;
      const newConfigPath = siteConfig.viewConfigPath.replace(sigRegex, configSuffix);
      import_fs_extra.default.mkdirSync((0, import_path.dirname)(newConfigPath), {recursive: true});
      import_fs_extra.default.writeFileSync(newConfigPath, newConfig, "utf-8");
      import_fs_extra.default.rmSync(siteConfig.viewConfigPath);
      siteConfig.viewPaths.forEach((path) => {
        const oldDoc = import_fs_extra.default.readFileSync(path, "utf-8");
        const newDoc = oldDoc.toString().replace(sigRegex, configSuffix);
        import_fs_extra.default.writeFileSync(path, newDoc, "utf-8");
      });
    }
  }
};
var static_generation_default = SiteGenerator;
var ViewImportMetadataImpl = class {
  constructor(existingImportMetadata, additionalImportMetadata) {
    this.existing = existingImportMetadata;
    this.additional = additionalImportMetadata || {imports: {}, index: {}};
  }
  getAdditionalImportMetadata() {
    return this.additional;
  }
  addAdditionalMetadata(newMetadata) {
    const filteredImports = this.filterMetadata(newMetadata);
    this.mergeImportMetadata(this.additional, filteredImports);
    return filteredImports;
  }
  filterMetadata(newMetadata) {
    const importsArray = Object.entries(newMetadata.imports);
    const filteredImports = importsArray.filter(([key]) => !this.existing.imports[key]);
    const imports = Object.fromEntries(filteredImports);
    const indexArray = Object.entries(newMetadata.index || {});
    const filteredIndex = indexArray.filter(([key]) => !this.existing.index || !this.existing.index[key]);
    const index = Object.fromEntries(filteredIndex);
    return {
      imports,
      index
    };
  }
  mergeImportMetadata(targetImportMetdadata, newImportMetadata) {
    Object.assign(targetImportMetdadata.imports, newImportMetadata.imports);
    if (targetImportMetdadata.index) {
      Object.assign(targetImportMetdadata.index, newImportMetadata.index || {});
    }
  }
};
