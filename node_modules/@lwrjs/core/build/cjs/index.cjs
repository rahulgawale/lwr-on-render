var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrApp: () => LwrApp,
  createServer: () => createServer,
  generateStaticSite: () => generateStaticSite
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_compiler = __toModule(require("@lwrjs/compiler"));
var import_module_bundler = __toModule(require("@lwrjs/module-bundler"));
var import_module_registry = __toModule(require("@lwrjs/module-registry"));
var import_resource_registry = __toModule(require("@lwrjs/resource-registry"));
var import_asset_registry = __toModule(require("@lwrjs/asset-registry"));
var import_view_registry = __toModule(require("@lwrjs/view-registry"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_config = __toModule(require("@lwrjs/config"));
var import_shared_utils2 = __toModule(require("@lwrjs/shared-utils"));
var import_locale_middleware = __toModule(require("./middlewares/locale-middleware.cjs"));
var import_api_middleware = __toModule(require("./middlewares/api-middleware.cjs"));
var import_ui_middleware = __toModule(require("./middlewares/ui-middleware.cjs"));
var import_hmr_middleware = __toModule(require("./middlewares/hmr-middleware.cjs"));
var import_global_data = __toModule(require("./context/global-data.cjs"));
var import_hooks = __toModule(require("./context/hooks.cjs"));
var import_base_middleware = __toModule(require("./middlewares/base-middleware.cjs"));
var import_server = __toModule(require("@lwrjs/server"));
var import_services = __toModule(require("./context/services.cjs"));
var import_static_generation = __toModule(require("./tools/static-generation.cjs"));
var import_server_warmup = __toModule(require("./tools/server-warmup.cjs"));
async function getServices(services, providerContext, lwrConfig) {
  return Promise.all(services.map(async (serviceEntry) => {
    const [serviceName, serviceConfig = {}] = Array.isArray(serviceEntry) ? serviceEntry : [serviceEntry];
    const ServiceCtor = await (0, import_services.getServiceModule)(serviceName, lwrConfig);
    return new ServiceCtor(serviceConfig, providerContext);
  }));
}
function initMiddlewares(app, server, serverContext) {
  (0, import_base_middleware.default)(app, serverContext);
  (0, import_locale_middleware.default)(app, serverContext);
  (0, import_api_middleware.default)(app, serverContext);
  (0, import_ui_middleware.default)(app, serverContext);
  if (serverContext.runtimeEnvironment.hmrEnabled) {
    (0, import_hmr_middleware.default)(server, serverContext);
  }
}
async function initContext(app, server, rawLwrConfig) {
  const {apiVersion, basePath, lwrVersion, serverMode, globalDataDir, globalData} = rawLwrConfig;
  const rawDataConfig = (0, import_global_data.getGlobalData)(globalDataDir, globalData);
  const rawRuntimeEnvConfig = {
    ...(0, import_config.explodeMode)(serverMode),
    apiVersion,
    basePath,
    lwrVersion,
    debug: false,
    serverMode,
    featureFlags: (0, import_shared_utils.getFeatureFlags)()
  };
  const hookProviders = await getServices(rawLwrConfig.hooks, void 0, rawLwrConfig);
  const {lwrConfig, dataConfig, runtimeConfig} = await (0, import_hooks.runConfigurationsHook)(hookProviders, rawLwrConfig, rawDataConfig, rawRuntimeEnvConfig);
  const assetTransformers = await getServices(rawLwrConfig.assetTransformers, void 0, rawLwrConfig);
  const appObserver = new import_shared_utils2.LwrApplicationObserver();
  const appEmitter = appObserver.createLwrEmitter();
  const compiler = new import_compiler.LwrCompiler();
  const assetRegistry = new import_asset_registry.LwrAssetRegistry({
    assetTransformers,
    appObserver,
    appEmitter,
    runtimeEnvironment: runtimeConfig
  }, lwrConfig);
  const moduleRegistry = new import_module_registry.LwrModuleRegistry({
    compiler,
    appObserver,
    appEmitter,
    runtimeEnvironment: runtimeConfig
  }, lwrConfig);
  const moduleBundler = new import_module_bundler.LwrModuleBundler({compiler, moduleRegistry, appObserver}, lwrConfig);
  const resourceRegistry = new import_resource_registry.LwrResourceRegistry();
  const viewRegistry = new import_view_registry.LwrViewRegistry({
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    assetRegistry,
    appObserver,
    appEmitter,
    globalData: dataConfig,
    runtimeEnvironment: runtimeConfig
  }, lwrConfig);
  const serverContext = {
    compiler,
    server,
    appObserver,
    appEmitter,
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    assetRegistry,
    viewRegistry,
    appConfig: lwrConfig,
    runtimeEnvironment: runtimeConfig
  };
  const {
    cacheDir,
    lwc: {modules = []},
    routes,
    errorRoutes,
    rootDir,
    contentDir,
    layoutsDir,
    locker,
    amdLoader,
    esmLoader,
    environment
  } = lwrConfig;
  const {onModuleDefinitionChange, onModuleSourceChange} = appObserver;
  const {
    notifyModuleDefinitionChanged,
    notifyModuleSourceChanged,
    notifyViewSourceChanged,
    notifyAssetSourceChanged
  } = appEmitter;
  const providerContext = {
    compiler,
    appObserver: (0, import_shared_utils.deepFreeze)({onModuleDefinitionChange, onModuleSourceChange}),
    appEmitter: {
      notifyModuleDefinitionChanged: (payload) => notifyModuleDefinitionChanged.call(appEmitter, payload),
      notifyModuleSourceChanged: (payload) => notifyModuleSourceChanged.call(appEmitter, payload),
      notifyViewSourceChanged: (payload) => notifyViewSourceChanged.call(appEmitter, payload),
      notifyAssetSourceChanged: (payload) => notifyAssetSourceChanged.call(appEmitter, payload)
    },
    moduleRegistry: moduleRegistry.getPublicApi(),
    moduleBundler,
    resourceRegistry: resourceRegistry.getPublicApi(),
    viewRegistry: viewRegistry.getPublicApi(),
    assetRegistry: assetRegistry.getPublicApi(),
    config: (0, import_shared_utils.deepFreeze)({
      cacheDir,
      modules,
      routes,
      errorRoutes,
      rootDir,
      basePath,
      contentDir,
      layoutsDir,
      locker,
      amdLoader,
      esmLoader,
      environment
    }),
    runtimeEnvironment: (0, import_shared_utils.deepFreeze)(runtimeConfig)
  };
  const moduleProviders = await getServices(lwrConfig.moduleProviders, providerContext, lwrConfig);
  moduleRegistry.addModuleProviders(moduleProviders);
  const resourceProviders = await getServices(lwrConfig.resourceProviders, providerContext, lwrConfig);
  resourceRegistry.addResourceProviders(resourceProviders);
  const viewProviders = await getServices(lwrConfig.viewProviders, providerContext, lwrConfig);
  const viewTransformers = await getServices(rawLwrConfig.viewTransformers, providerContext, rawLwrConfig);
  viewRegistry.addViewProviders(viewProviders);
  viewRegistry.addViewTransformers(viewTransformers);
  await viewRegistry.initializeViewProviders();
  const assetProviders = await getServices(lwrConfig.assetProviders, providerContext, lwrConfig);
  assetRegistry.addAssetProviders(assetProviders);
  return serverContext;
}
var LwrApp = class {
  constructor(config) {
    this.initialized = false;
    this.config = (0, import_config.normalizeConfig)(config);
    const {basePath} = this.config;
    this.app = (0, import_server.createInternalServer)(this.config.serverType, {basePath});
    this.server = this.app.createHttpServer();
  }
  setConfig(config) {
    this.config = (0, import_config.normalizeConfig)(config);
  }
  getConfig() {
    return this.config;
  }
  async init() {
    if (!this.initialized) {
      this.initialized = true;
      try {
        const context = await initContext(this.app, this.server, this.config);
        initMiddlewares(this.app, this.server, context);
      } catch (e) {
        this.initialized = false;
        throw e;
      }
    }
  }
  async listen(callback) {
    await this.init();
    const {server, config, app} = this;
    const {serverMode, port} = config;
    return new Promise((resolve, reject) => {
      const handleError = (err) => {
        server.off("error", handleError);
        if (err.code === "EADDRINUSE") {
          err = new Error(`Port ${port} is already in use.`);
        }
        reject(err);
      };
      server.on("error", handleError);
      server.listen(port, async () => {
        server.off("error", handleError);
        if (process.env.WARMUP?.toLowerCase() === "true") {
          try {
            await (0, import_server_warmup.warmupServer)(config, app.getInternalRequestKey());
          } catch (err) {
            const diagnostic = (0, import_diagnostics.createSingleDiagnosticError)({
              description: import_diagnostics.descriptions.SERVER.WARMUP_ERROR(err.message)
            }, import_diagnostics.LwrServerError);
            return reject(diagnostic);
          }
        }
        const opts = {serverMode, port};
        callback?.(opts);
        resolve(opts);
      });
    });
  }
  async close() {
    this.server?.close && await this.server.close();
  }
  getInternalServer() {
    return this.app.getImpl();
  }
  getServer() {
    return {
      use: this.app.use.bind(this.app),
      all: this.app.all.bind(this.app),
      get: this.app.get.bind(this.app),
      post: this.app.post.bind(this.app),
      getRegexWildcard: this.app.getRegexWildcard.bind(this.app)
    };
  }
};
function createServer(config) {
  return new LwrApp(config);
}
async function generateStaticSite(config) {
  config = config || {};
  config.serverType = "fs";
  const {serverMode} = config;
  if (serverMode === "dev" || serverMode === "compat") {
    import_shared_utils.logger.warn("static generation in `dev` or `compat` mode is currently not fully supported");
  }
  const lwrApp = createServer(config);
  overrideConfigAsSrc(lwrApp);
  await lwrApp.init();
  const dispatcher = lwrApp.getInternalServer();
  await new import_static_generation.default().buildStaticApplication(lwrApp.getConfig(), dispatcher);
}
function overrideConfigAsSrc(lwrApp) {
  if (!(0, import_shared_utils.getFeatureFlags)().LEGACY_LOADER) {
    const normalizedConfig = lwrApp.getConfig();
    const routes = normalizedConfig.routes || [];
    for (const route of routes) {
      route.bootstrap = {
        ...import_shared_utils.DEFAULT_LWR_BOOTSTRAP_CONFIG,
        ...route.bootstrap,
        configAsSrc: true
      };
    }
  }
}
