var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/middlewares/ui-middleware.ts
__markAsModule(exports);
__export(exports, {
  default: () => uiMiddleware
});
var import_ms = __toModule(require("ms"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_view_registry = __toModule(require("@lwrjs/view-registry"));
var import_utils = __toModule(require("./utils.cjs"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_router = __toModule(require("@lwrjs/router"));
function uiMiddleware(app, context) {
  const {viewRegistry, moduleRegistry, runtimeEnvironment: defaultRuntimeEnvironment} = context;
  const {environment: environmentConfig, routes, errorRoutes} = context.appConfig;
  const route404 = errorRoutes.find((r) => r.status === 404);
  const route500 = errorRoutes.find((r) => r.status === 500);
  const viewHandler = new import_view_registry.LwrViewHandler({viewRegistry, moduleRegistry}, context.appConfig);
  async function sendViewResponse(req, res, route, defaultStatus = 200) {
    if (!req.validateJsonRequest()) {
      res.status(400).send({error: "Accept header and json query parameter are incompatible"});
      return;
    }
    req.params.bundleSpecifier = defaultRuntimeEnvironment.bundle ? "0" : void 0;
    const {runtimeEnvironment, runtimeParams} = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    if (!targetEnvironment && environmentConfig?.default) {
      runtimeParams.environment = environmentConfig.default;
    }
    try {
      const viewRequest = {
        url: req.originalUrl,
        params: req.params,
        query: req.query,
        requestPath: req.path
      };
      const response = req.isJsonRequest() ? await viewHandler.getViewJson(viewRequest, route, runtimeEnvironment, runtimeParams) : await viewHandler.getViewContent(viewRequest, route, runtimeEnvironment, runtimeParams);
      const cacheTtl = response.cache?.ttl || route.cache?.ttl;
      let ttl;
      if (cacheTtl) {
        ttl = typeof cacheTtl === "string" ? (0, import_ms.default)(cacheTtl) / 1e3 : cacheTtl;
        res.setHeader("Cache-control", `public, max-age=${ttl}`);
      }
      const headers = response.headers || {
        "Content-Type": "text/html",
        ...cacheTtl && {"Cache-control": `public, max-age=${ttl}`}
      };
      res.set(headers);
      res.setMetadata(response.metadata);
      const status = response.status ? response.status : defaultStatus;
      res.status(status).send(response.body);
    } catch (error) {
      if (error instanceof import_diagnostics.DiagnosticsError) {
        console.error("LWR Diagnostic Error: " + error.message);
        console.error(error.diagnostics);
        console.error(error.stack);
      } else {
        console.error(error);
      }
      if (route500 && defaultStatus !== 500) {
        await sendViewResponse(req, res, route500, 500);
      } else {
        res.status(500).send(`500 - Error retrieving view for route "${route.id}"`);
      }
    }
  }
  async function sendConfigurationResponse(req, res, defaultStatus = 200) {
    req.params.bundleSpecifier = defaultRuntimeEnvironment.bundle ? "0" : void 0;
    const {runtimeEnvironment, runtimeParams} = req.getRuntimeContext(defaultRuntimeEnvironment);
    const {appId, encodedViewPath} = req.params;
    const route = routes.find((route2) => route2.id === appId);
    if (!route) {
      res.status(404).send({error: `LWR configuration for appId "${appId}" is not available`});
      return;
    }
    try {
      const url = (0, import_shared_utils.decodeViewPath)(encodedViewPath);
      const requestPath = route.path;
      const params = (0, import_shared_utils.extractRequestParams)(requestPath, url, req.params);
      const viewRequest = {
        url,
        params,
        query: req.query,
        requestPath
      };
      const response = await viewHandler.getViewConfiguration(viewRequest, route, runtimeEnvironment, runtimeParams);
      if (!response) {
        res.status(404).send({error: `LWR configuration for viewPath "${url}" is not available`});
        return;
      }
      const cacheTtl = response.cache?.ttl || route.cache?.ttl;
      let ttl;
      if (cacheTtl) {
        ttl = typeof cacheTtl === "string" ? (0, import_ms.default)(cacheTtl) / 1e3 : cacheTtl;
      }
      res.set({
        "Content-Type": "application/javascript",
        ...cacheTtl && {"Cache-control": `public, max-age=${ttl}`}
      });
      const status = response.status ? response.status : defaultStatus;
      res.status(status).send(response.body);
    } catch (error) {
      if (error instanceof import_diagnostics.DiagnosticsError) {
        console.error("LWR Diagnostic Error: " + error.message);
        console.error(error.diagnostics);
        console.error(error.stack);
      } else {
        console.error(error);
      }
      if (route500 && defaultStatus !== 500) {
        await sendViewResponse(req, res, route500, 500);
      } else {
        res.status(500).send(`500 - Error retrieving route "${route.id}"`);
      }
    }
  }
  routes.forEach((route) => {
    if (route.method === "post") {
      app.post(route.path, async (req, res) => {
        await sendViewResponse(req, res, route);
      });
    } else {
      const serverPath = route.path;
      const paths = [serverPath];
      const subRoutes = route.subRoutes ? (0, import_router.getClientRoutes)(route.subRoutes) : void 0;
      if (subRoutes) {
        const prefix = serverPath === "/" ? "" : serverPath;
        subRoutes.routes.forEach((r) => paths.push(`${prefix}${r.uri}`));
      }
      paths.forEach((path) => {
        app.get(path, async (req, res) => {
          await sendViewResponse(req, res, route);
        });
        app.get([
          `/:apiVersion/application/:format/l/:locale/ai/:appId${path}`,
          `/:apiVersion/application/:format/l/:locale/e/:environment/ai/:appId${path}`,
          `/:apiVersion/application/:format/ai/:appId${path}`,
          `/:apiVersion/application/:format/e/:environment/ai/:appId${path}`
        ], async (req, res) => {
          await sendViewResponse(req, res, route);
        });
      });
    }
  });
  const clientBootstrapConfigurationRoutes = (0, import_shared_utils.getClientBootstrapConfigurationRoutes)();
  app.get(clientBootstrapConfigurationRoutes, async (req, res) => {
    await sendConfigurationResponse(req, res);
  });
  app.initRoutes();
  app.use(async (req, res) => {
    if (route404) {
      await sendViewResponse(req, res, route404, 404);
    } else {
      res.status(404).send("404 - This page does not exist");
    }
  });
}
