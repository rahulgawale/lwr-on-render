var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/middlewares/api-middleware.ts
__markAsModule(exports);
__export(exports, {
  default: () => apiMiddleware
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
function apiMiddleware(app, context) {
  const {
    appConfig: {environment: environmentConfig},
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    runtimeEnvironment: defaultRuntimeEnvironment
  } = context;
  const errors = import_diagnostics.descriptions.UNRESOLVABLE;
  app.get([
    `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`
  ], async (req, res) => {
    const runtimeContext = req.getRuntimeContext(defaultRuntimeEnvironment);
    const {runtimeEnvironment, runtimeParams} = runtimeContext;
    const targetEnvironment = runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleId, signature;
    try {
      ({moduleId, signature} = (0, import_shared_utils.getModuleIdentity)(req));
      const sourceMapUrl = req.path.replace("/bundle/", "/sourcemaps/bundle/");
      const sourceMapRuntimeContext = {...runtimeEnvironment, sourceMapUrl};
      const importerSpecifier = req.query.importer;
      if (importerSpecifier) {
        const importerModuleId = (0, import_shared_utils.explodeSpecifier)(importerSpecifier);
        const {entry} = await moduleRegistry.getModuleEntry(importerModuleId);
        const versionedModuleEntry = await moduleRegistry.getModuleEntry({
          ...moduleId,
          importer: entry
        });
        const uri = await moduleRegistry.resolveModuleUri({...moduleId, version: versionedModuleEntry.version}, runtimeEnvironment, runtimeParams);
        res.set({
          Location: uri
        });
        res.sendStatus(302);
        return;
      }
      const bundleDef = await moduleBundler.getModuleBundle(moduleId, sourceMapRuntimeContext, runtimeParams);
      if (signature !== import_shared_utils.LATEST_SIGNATURE) {
        res.setHeader("Cache-control", "public, max-age=31536000, immutable");
      }
      const resolvedUris = [];
      if (req.isSiteGeneration()) {
        if (bundleDef.bundleRecord.imports) {
          for (const theImport of bundleDef.bundleRecord.imports) {
            const childSpecifier = theImport.specifier;
            const id = await (0, import_shared_utils.getVersionedModuleId)(childSpecifier, moduleRegistry);
            const uri = await moduleRegistry.resolveModuleUri(id, runtimeEnvironment, runtimeParams);
            resolvedUris.push(uri);
          }
        }
        if (bundleDef.bundleRecord.dynamicImports) {
          for (const theImport of bundleDef.bundleRecord.dynamicImports) {
            const childSpecifier = theImport.specifier;
            const id = await (0, import_shared_utils.getVersionedModuleId)(childSpecifier, moduleRegistry);
            const uri = await moduleRegistry.resolveModuleUri(id, runtimeEnvironment, runtimeParams);
            resolvedUris.push(uri);
          }
        }
      }
      res.setMetadata({moduleDefinition: bundleDef, resolvedUris});
      res.type("application/javascript").send(bundleDef.code);
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`bundle for "${moduleId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  app.get([
    `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier`,
    `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier`,
    `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier`,
    `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier`
  ], async (req, res) => {
    const ctx = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = ctx.runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleId;
    try {
      ({moduleId} = (0, import_shared_utils.getModuleIdentity)(req));
      const importerSpecifier = req.query.importer;
      if (importerSpecifier) {
        const importerModuleId = (0, import_shared_utils.explodeSpecifier)(importerSpecifier);
        const {entry} = await moduleRegistry.getModuleEntry(importerModuleId);
        moduleId = {...moduleId, importer: entry};
      }
      const {ownHash, moduleEntry} = await moduleRegistry.getModule(moduleId, ctx.runtimeParams);
      if (ownHash) {
        const jsonQuery = req.isJsonRequest() ? `${ctx.runtimeEnvironment.debug ? "&" : "?"}json` : "";
        const uri = await moduleRegistry.resolveModuleUri({...moduleId, version: moduleEntry.version}, ctx.runtimeEnvironment, ctx.runtimeParams, ownHash);
        res.set({
          Location: `${uri}${jsonQuery}`
        });
        res.sendStatus(302);
      }
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`bundle for "${moduleId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  app.get([
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/sourcemaps/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`
  ], async (req, res) => {
    const runtimeContext = req.getRuntimeContext(defaultRuntimeEnvironment);
    const {runtimeParams, runtimeEnvironment} = runtimeContext;
    const targetEnvironment = runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleId, signature;
    try {
      ({moduleId, signature} = (0, import_shared_utils.getModuleIdentity)(req));
      const bundleDef = await moduleBundler.getModuleBundle(moduleId, runtimeEnvironment);
      if (signature !== import_shared_utils.LATEST_SIGNATURE) {
        res.setHeader("Cache-control", "public, max-age=31536000, immutable");
      }
      res.type("application/json").send(bundleDef.map);
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`bundle sourcemap for "${moduleId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  app.get([
    `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier/s/:signature/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/mi/:specifier/latest/:prettyUrl?`,
    `/:apiVersion/module/:format/:compat/mi/:specifier/s/:signature/:prettyUrl?`
  ], async (req, res) => {
    const {runtimeEnvironment, runtimeParams} = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleId, signature;
    try {
      ({moduleId, signature} = (0, import_shared_utils.getModuleIdentity)(req));
      if (!req.validateJsonRequest()) {
        throw (0, import_diagnostics.createSingleDiagnosticError)({description: errors.INVALID_JSON()}, import_diagnostics.LwrUnresolvableError);
      }
      const theModule = await moduleRegistry.getLinkedModule(moduleId, runtimeEnvironment, runtimeParams);
      const {ownHash, linkedSource} = theModule;
      if (signature === import_shared_utils.LATEST_SIGNATURE || ownHash === signature) {
        const code = linkedSource;
        res.setMetadata({moduleDefinition: theModule});
        if (req.isJsonRequest()) {
          const json = await (0, import_shared_utils.serializeModuleToJson)(code, theModule, moduleRegistry, runtimeParams);
          res.type("application/json").send(json);
        } else {
          res.type("application/javascript").send(code);
        }
      } else {
        throw (0, import_diagnostics.createSingleDiagnosticError)({description: errors.SIGNED_MODULE(moduleId.specifier, signature)}, import_diagnostics.LwrUnresolvableError);
      }
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`module "${moduleId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  app.get([
    `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier`,
    `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier`,
    `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier`,
    `/:apiVersion/module/:format/:compat/mi/:specifier`
  ], async (req, res) => {
    const ctx = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = ctx.runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleId;
    try {
      ({moduleId} = (0, import_shared_utils.getModuleIdentity)(req));
      const importerSpecifier = req.query.importer;
      if (importerSpecifier) {
        const importerModuleId = (0, import_shared_utils.explodeSpecifier)(importerSpecifier);
        const {entry} = await moduleRegistry.getModuleEntry(importerModuleId);
        moduleId = {...moduleId, importer: entry};
      }
      const {ownHash, moduleEntry} = await moduleRegistry.getModule(moduleId, ctx.runtimeParams);
      if (ownHash) {
        const jsonQuery = req.isJsonRequest() ? `${ctx.runtimeEnvironment.debug ? "&" : "?"}json` : "";
        const uri = await moduleRegistry.resolveModuleUri({...moduleId, version: moduleEntry.version}, ctx.runtimeEnvironment, ctx.runtimeParams, ownHash);
        res.set({
          Location: `${uri}${jsonQuery}`
        });
        res.sendStatus(302);
      }
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`module "${moduleId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  app.get([
    `/:apiVersion/mapping/:format/:compat/l/:locale/e/:environment/bi/:bundleSpecifier/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/l/:locale/e/:environment/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/l/:locale/bi/:bundleSpecifier/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/e/:environment/bi/:bundleSpecifier/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/l/:locale/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/e/:environment/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/bi/:bundleSpecifier/mp/:specifiers`,
    `/:apiVersion/mapping/:format/:compat/mp/:specifiers`
  ], async (req, res) => {
    const requestContext = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = requestContext.runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let moduleIds;
    try {
      ({moduleIds} = (0, import_shared_utils.getMappingIdentity)(req));
      const {runtimeEnvironment, runtimeParams} = requestContext;
      const importMetadata = await (0, import_shared_utils.getImportMetadataMappings)(moduleIds, runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler);
      res.setMetadata({importMetadata});
      res.status(200).type("application/json").send(importMetadata);
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`mappings for "${JSON.stringify(moduleIds || req.params?.specifiers)}"`, e);
      res.status(error.status).send(error.message);
    }
  });
  app.get([
    `/:apiVersion/resource/:format/l/:locale/e/:environment/:specifier`,
    `/:apiVersion/resource/:format/l/:locale/:specifier`,
    `/:apiVersion/resource/:format/e/:environment/:specifier`,
    `/:apiVersion/resource/:format/:specifier`
  ], async (req, res) => {
    const {runtimeEnvironment, runtimeParams} = req.getRuntimeContext(defaultRuntimeEnvironment);
    const targetEnvironment = runtimeParams.environment;
    if (!(0, import_utils.isSupportedEnvironment)(environmentConfig, targetEnvironment)) {
      res.status(400).send({error: `Environment "${targetEnvironment}" is not supported`});
      return;
    }
    let resourceId;
    try {
      ({resourceId} = (0, import_shared_utils.getResourceIdentity)(req));
      const resource = await resourceRegistry.getResource(resourceId, runtimeEnvironment, runtimeParams);
      if (resource && resource.content) {
        const type = resource.type === "text/css" ? resource.type : "application/javascript";
        res.type(type).send(resource.content);
      } else if (resource && resource.stream) {
        res.type(resource.type).stream(resource.stream);
      } else {
        throw (0, import_diagnostics.createSingleDiagnosticError)({description: errors.RESOURCE(resourceId.specifier)}, import_diagnostics.LwrUnresolvableError);
      }
      res.setMetadata({resource});
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`resource "${resourceId?.specifier || req.params?.specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
  const paths = context.appConfig.assets.map((a) => a.urlPath);
  for (let i = 0; i < paths.length; i++) {
    paths[i] = paths[i] + app.getRegexWildcard();
  }
  app.all(paths, async (req, res) => {
    const {runtimeEnvironment} = req.getRuntimeContext(defaultRuntimeEnvironment);
    try {
      const {
        assetId: {specifier, type},
        signature
      } = (0, import_shared_utils.getAssetIdentity)(req);
      const assetObj = await context.assetRegistry.getAsset({specifier, signature, type}, runtimeEnvironment);
      if (assetObj.mime) {
        res.type(assetObj.mime);
      }
      res.setMetadata({asset: assetObj});
      res.stream(assetObj.stream());
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`asset at "${req.originalUrl}"`, e);
      res.status(error.status).send(error.message);
    }
  });
  app.all("/:apiVersion/:assetType/:immutable?/s/:signature/" + app.getRegexWildcard(), async (req, res) => {
    const {runtimeEnvironment} = req.getRuntimeContext(defaultRuntimeEnvironment);
    const {basePath} = runtimeEnvironment;
    const {signature} = req.params;
    const {immutable, assetType: type} = req.params;
    const specifier = req.params[0] ? `/${req.params[0]}` : req.originalUrl;
    const basePathSpecifier = `${basePath}${specifier}`;
    try {
      const assetObj = await context.assetRegistry.getAsset({specifier: basePathSpecifier, signature, type}, runtimeEnvironment, req.isSiteGeneration());
      if (immutable) {
      }
      if (assetObj.mime) {
        res.type(assetObj.mime);
      }
      res.setMetadata({asset: assetObj});
      res.stream(assetObj.stream());
    } catch (e) {
      console.log(e);
      const error = (0, import_diagnostics.createReturnStatus)(`asset at "${specifier}"`, e);
      res.status(error.status).type("text/plain").send(error.message);
    }
  });
}
