var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/middlewares/hmr-middleware.ts
__markAsModule(exports);
__export(exports, {
  default: () => hmrMiddleware
});
var import_ws = __toModule(require("ws"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var hmr;
var Hmr = class {
  constructor(server, context) {
    this.server = server;
    this.context = context;
    this.moduleRegistry = context.moduleRegistry;
    const observer = context.appObserver;
    observer.onModuleDefinitionChange(({payload}) => this.updateModuleDefOnClients(payload));
    observer.onViewSourceChange(({payload}) => this.updateTemplateOnClients(payload));
    observer.onAssetSourceChange(({payload}) => this.updateAssetOnClients(payload));
  }
  setupHotModuleReload() {
    const {server} = this;
    const wss = new import_ws.WebSocketServer({server});
    const connectedClients = new Map();
    this.connectedClients = connectedClients;
    wss.on("connection", function connection(ws, req) {
      const request = (0, import_utils.getRequestProperties)("/:apiVersion/hmr/:format/:compat", req);
      if (request) {
        const {params, query} = request;
        const {format, compat} = params;
        const debug = query.debug !== void 0;
        const cacheId = (0, import_shared_utils.getCacheKeyFromJson)({format, compat, debug});
        connectedClients.set(ws, cacheId);
        ws.send(JSON.stringify({eventType: "connected"}));
        ws.on("close", () => connectedClients.delete(ws));
        ws.on("error", () => connectedClients.delete(ws));
      }
    });
    wss.on("error", (error) => {
      if (error.code === "EADDRINUSE") {
        console.error(`HMR Socket Server: Port ${this.context.appConfig.port} already in use.`);
      } else {
        console.error(error);
      }
    });
  }
  updateModuleDefOnClients(moduleDefinition) {
    const {moduleRegistry} = this;
    const {
      specifier,
      namespace,
      name,
      version,
      ownHash: signature,
      runtimeEnvironment,
      runtimeParams
    } = moduleDefinition;
    const {format, debug, compat} = runtimeEnvironment;
    console.log("Recompiled module:", specifier, signature);
    const moduleId = {
      specifier,
      namespace,
      name,
      version
    };
    const modulesCacheId = (0, import_shared_utils.getCacheKeyFromJson)({format, compat, debug});
    const newUri = moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature);
    const oldUri = moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, "latest");
    if (this.connectedClients) {
      for (const [ws, cacheId] of this.connectedClients) {
        if (cacheId === modulesCacheId) {
          ws.send(JSON.stringify({
            eventType: "moduleUpdate",
            payload: {
              module: moduleId,
              newHash: signature,
              oldHash: "latest",
              newUri,
              oldUri
            }
          }));
        }
      }
    }
  }
  updateTemplateOnClients(compiledView) {
    console.log("Recompiled view source:", compiledView.viewId);
    const {contentTemplate} = compiledView.viewId;
    if (this.connectedClients && contentTemplate) {
      for (const ws of this.connectedClients.keys()) {
        ws.send(JSON.stringify({
          eventType: "viewUpdate",
          payload: {
            viewId: contentTemplate
          }
        }));
      }
    }
  }
  updateAssetOnClients(asset) {
    const assetId = asset.entry;
    console.log("Updated asset:", assetId);
    if (this.connectedClients) {
      for (const ws of this.connectedClients.keys()) {
        ws.send(JSON.stringify({
          eventType: "viewUpdate",
          payload: {
            assetId
          }
        }));
      }
    }
  }
};
function hmrMiddleware(server, context) {
  hmr = new Hmr(server, context);
  hmr.setupHotModuleReload();
}
