import ms from 'ms';
import { DiagnosticsError } from '@lwrjs/diagnostics';
import { LwrViewHandler } from '@lwrjs/view-registry';
import { isSupportedEnvironment } from './utils.js';
import { decodeViewPath, getClientBootstrapConfigurationRoutes, extractRequestParams, } from '@lwrjs/shared-utils';
import { getClientRoutes } from '@lwrjs/router';
export default function uiMiddleware(app, context) {
    const { viewRegistry, moduleRegistry, runtimeEnvironment: defaultRuntimeEnvironment } = context;
    const { environment: environmentConfig, routes, errorRoutes } = context.appConfig;
    const route404 = errorRoutes.find((r) => r.status === 404);
    const route500 = errorRoutes.find((r) => r.status === 500);
    const viewHandler = new LwrViewHandler({ viewRegistry, moduleRegistry }, context.appConfig);
    async function sendViewResponse(req, res, route, defaultStatus = 200) {
        if (!req.validateJsonRequest()) {
            res.status(400).send({ error: 'Accept header and json query parameter are incompatible' });
            return;
        }
        // UI URIs do not contain bundle IDs, so always use the environment default
        req.params.bundleSpecifier = defaultRuntimeEnvironment.bundle ? '0' : undefined;
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        if (!targetEnvironment && environmentConfig?.default) {
            runtimeParams.environment = environmentConfig.default;
        }
        try {
            // HTML document
            const viewRequest = {
                url: req.originalUrl,
                params: req.params,
                query: req.query,
                requestPath: req.path, // Runtime resolved version vs. the original route path
            };
            const response = req.isJsonRequest()
                ? await viewHandler.getViewJson(viewRequest, route, runtimeEnvironment, runtimeParams)
                : await viewHandler.getViewContent(viewRequest, route, runtimeEnvironment, runtimeParams);
            const cacheTtl = response.cache?.ttl || route.cache?.ttl;
            let ttl;
            if (cacheTtl) {
                ttl = typeof cacheTtl === 'string' ? ms(cacheTtl) / 1000 : cacheTtl;
                res.setHeader('Cache-control', `public, max-age=${ttl}`);
            }
            const headers = response.headers || {
                'Content-Type': 'text/html',
                ...(cacheTtl && { 'Cache-control': `public, max-age=${ttl}` }),
            };
            res.set(headers);
            res.setMetadata(response.metadata);
            const status = response.status ? response.status : defaultStatus;
            res.status(status).send(response.body);
        }
        catch (error) {
            if (error instanceof DiagnosticsError) {
                console.error('LWR Diagnostic Error: ' + error.message);
                console.error(error.diagnostics);
                console.error(error.stack);
            }
            else {
                console.error(error);
            }
            if (route500 && defaultStatus !== 500) {
                await sendViewResponse(req, res, route500, 500);
            }
            else {
                res.status(500).send(`500 - Error retrieving view for route "${route.id}"`);
            }
        }
    }
    async function sendConfigurationResponse(req, res, defaultStatus = 200) {
        // UI URIs do not contain bundle IDs, so always use the environment default
        req.params.bundleSpecifier = defaultRuntimeEnvironment.bundle ? '0' : undefined;
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(defaultRuntimeEnvironment);
        const { appId, encodedViewPath } = req.params;
        // Match the route id
        const route = routes.find((route) => route.id === appId);
        if (!route) {
            res.status(404).send({ error: `LWR configuration for appId "${appId}" is not available` });
            return;
        }
        try {
            // decode the resolved view path and extract any params.
            const url = decodeViewPath(encodedViewPath);
            const requestPath = route.path;
            const params = extractRequestParams(requestPath, url, req.params);
            // HTML document
            const viewRequest = {
                url,
                params,
                query: req.query,
                requestPath, // Runtime resolved version vs. the original route path
            };
            const response = await viewHandler.getViewConfiguration(viewRequest, route, runtimeEnvironment, runtimeParams);
            if (!response) {
                res.status(404).send({ error: `LWR configuration for viewPath "${url}" is not available` });
                return;
            }
            // Same cache ttl as the Content response
            const cacheTtl = response.cache?.ttl || route.cache?.ttl;
            let ttl;
            if (cacheTtl) {
                ttl = typeof cacheTtl === 'string' ? ms(cacheTtl) / 1000 : cacheTtl;
            }
            res.set({
                'Content-Type': 'application/javascript',
                ...(cacheTtl && { 'Cache-control': `public, max-age=${ttl}` }),
            });
            const status = response.status ? response.status : defaultStatus;
            res.status(status).send(response.body);
        }
        catch (error) {
            if (error instanceof DiagnosticsError) {
                console.error('LWR Diagnostic Error: ' + error.message);
                console.error(error.diagnostics);
                console.error(error.stack);
            }
            else {
                console.error(error);
            }
            if (route500 && defaultStatus !== 500) {
                await sendViewResponse(req, res, route500, 500);
            }
            else {
                res.status(500).send(`500 - Error retrieving route "${route.id}"`);
            }
        }
    }
    // -- Register each view ------------------------------------------------------------
    routes.forEach((route) => {
        // Seems like we only support get or post
        if (route.method === 'post') {
            app.post(route.path, async (req, res) => {
                await sendViewResponse(req, res, route);
            });
        }
        else {
            // Get the client-side routes
            const serverPath = route.path;
            const paths = [serverPath];
            const subRoutes = route.subRoutes ? getClientRoutes(route.subRoutes) : undefined;
            if (subRoutes) {
                // Concatenate each client uri to the server route.path, creating the full list of composite paths
                const prefix = serverPath === '/' ? '' : serverPath;
                subRoutes.routes.forEach((r) => paths.push(`${prefix}${r.uri}`));
            }
            // Register the server route.path and each composite client path, to enable full page refreshes of client pages
            paths.forEach((path) => {
                // vanity urls
                app.get(path, async (req, res) => {
                    await sendViewResponse(req, res, route);
                });
                // canonical URL
                app.get([
                    `/:apiVersion/application/:format/l/:locale/ai/:appId${path}`,
                    `/:apiVersion/application/:format/l/:locale/e/:environment/ai/:appId${path}`,
                    `/:apiVersion/application/:format/ai/:appId${path}`,
                    `/:apiVersion/application/:format/e/:environment/ai/:appId${path}`,
                ], async (req, res) => {
                    await sendViewResponse(req, res, route);
                });
            });
        }
    });
    const clientBootstrapConfigurationRoutes = getClientBootstrapConfigurationRoutes();
    app.get(clientBootstrapConfigurationRoutes, async (req, res) => {
        await sendConfigurationResponse(req, res);
    });
    // TODO nrkruk - This needs to be more generalized and visible at the top level of our middleware code.
    // This is the only time we call initRoutes() - which adds all the routing middleware that has been declared previously
    // to the app (get()/post()/all()). Any routing middleware declared after this point will not be initialized
    // (for KOA and other server types where routing is not included in the base package).
    // NOTE: THIS MUST BE ALWAYS CALLED BEFORE THE DEFAULT 404 ROUTE BELOW
    app.initRoutes();
    // -- Default 404 route -------------------------------------------------------------
    app.use(async (req, res) => {
        if (route404) {
            await sendViewResponse(req, res, route404, 404);
        }
        else {
            res.status(404).send('404 - This page does not exist');
        }
    });
}
//# sourceMappingURL=ui-middleware.js.map