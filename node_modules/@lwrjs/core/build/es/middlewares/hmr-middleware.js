import { WebSocketServer } from 'ws';
import { getCacheKeyFromJson } from '@lwrjs/shared-utils';
import { getRequestProperties } from './utils.js';
let hmr;
class Hmr {
    constructor(server, context) {
        this.server = server;
        this.context = context;
        this.moduleRegistry = context.moduleRegistry;
        const observer = context.appObserver;
        observer.onModuleDefinitionChange(({ payload }) => this.updateModuleDefOnClients(payload));
        observer.onViewSourceChange(({ payload }) => this.updateTemplateOnClients(payload));
        observer.onAssetSourceChange(({ payload }) => this.updateAssetOnClients(payload));
    }
    setupHotModuleReload() {
        const { server } = this;
        const wss = new WebSocketServer({ server });
        const connectedClients = new Map();
        this.connectedClients = connectedClients;
        wss.on('connection', function connection(ws, req) {
            const request = getRequestProperties('/:apiVersion/hmr/:format/:compat', req);
            // only accept connections on the /:apiVersion/hmr/:format/:compat endpoint
            if (request) {
                const { params, query } = request;
                const { format, compat } = params;
                const debug = query.debug !== undefined;
                const cacheId = getCacheKeyFromJson({ format, compat, debug });
                connectedClients.set(ws, cacheId);
                ws.send(JSON.stringify({ eventType: 'connected' }));
                ws.on('close', () => connectedClients.delete(ws));
                ws.on('error', () => connectedClients.delete(ws));
            }
        });
        wss.on('error', (error) => {
            if (error.code === 'EADDRINUSE') {
                console.error(`HMR Socket Server: Port ${this.context.appConfig.port} already in use.`);
            }
            else {
                console.error(error);
            }
        });
    }
    updateModuleDefOnClients(moduleDefinition) {
        const { moduleRegistry } = this;
        const { specifier, namespace, name, version, ownHash: signature, runtimeEnvironment, runtimeParams, } = moduleDefinition;
        const { format, debug, compat } = runtimeEnvironment;
        console.log('Recompiled module:', specifier, signature);
        const moduleId = {
            specifier,
            namespace,
            name,
            version,
        };
        const modulesCacheId = getCacheKeyFromJson({ format, compat, debug });
        const newUri = moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature);
        const oldUri = moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, 'latest');
        if (this.connectedClients) {
            for (const [ws, cacheId] of this.connectedClients) {
                if (cacheId === modulesCacheId) {
                    ws.send(JSON.stringify({
                        eventType: 'moduleUpdate',
                        payload: {
                            module: moduleId,
                            newHash: signature,
                            oldHash: 'latest',
                            newUri,
                            oldUri,
                        },
                    }));
                }
            }
        }
    }
    updateTemplateOnClients(compiledView) {
        console.log('Recompiled view source:', compiledView.viewId);
        const { contentTemplate } = compiledView.viewId;
        if (this.connectedClients && contentTemplate) {
            for (const ws of this.connectedClients.keys()) {
                ws.send(JSON.stringify({
                    eventType: 'viewUpdate',
                    payload: {
                        viewId: contentTemplate,
                    },
                }));
            }
        }
    }
    updateAssetOnClients(asset) {
        const assetId = asset.entry;
        console.log('Updated asset:', assetId);
        if (this.connectedClients) {
            for (const ws of this.connectedClients.keys()) {
                ws.send(JSON.stringify({
                    eventType: 'viewUpdate',
                    payload: {
                        assetId,
                    },
                }));
            }
        }
    }
}
export default function hmrMiddleware(server, context) {
    hmr = new Hmr(server, context);
    hmr.setupHotModuleReload();
}
//# sourceMappingURL=hmr-middleware.js.map