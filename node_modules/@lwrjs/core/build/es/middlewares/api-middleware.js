import { createReturnStatus, LwrUnresolvableError, createSingleDiagnosticError as createDiagnostic, descriptions, } from '@lwrjs/diagnostics';
import { LATEST_SIGNATURE, explodeSpecifier, getImportMetadataMappings, serializeModuleToJson, getModuleIdentity, getResourceIdentity, getAssetIdentity, getMappingIdentity, getVersionedModuleId, } from '@lwrjs/shared-utils';
import { isSupportedEnvironment } from './utils.js';
export default function apiMiddleware(app, context) {
    const { appConfig: { environment: environmentConfig }, moduleRegistry, moduleBundler, resourceRegistry, runtimeEnvironment: defaultRuntimeEnvironment, } = context;
    const errors = descriptions.UNRESOLVABLE;
    // Bundle APIs
    // {apiversion}/bundle/{format}/{compat}/bi/{bundlingId}-{bundlingSet}/module/mi/{specifier}/s/{signature}?{modifiers}
    app.get([
        // Full URL
        `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Environment
        `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Locale
        `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Optional Segments
        `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    ], async (req, res) => {
        const runtimeContext = req.getRuntimeContext(defaultRuntimeEnvironment);
        const { runtimeEnvironment, runtimeParams } = runtimeContext;
        const targetEnvironment = runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleId, signature;
        try {
            ({ moduleId, signature } = getModuleIdentity(req));
            const sourceMapUrl = req.path.replace('/bundle/', '/sourcemaps/bundle/');
            const sourceMapRuntimeContext = { ...runtimeEnvironment, sourceMapUrl };
            // Redirect module requests to the concrete URL when requested with an importer
            const importerSpecifier = req.query.importer;
            if (importerSpecifier) {
                // Get the importer's file path entry
                const importerModuleId = explodeSpecifier(importerSpecifier);
                const { entry } = await moduleRegistry.getModuleEntry(importerModuleId);
                const versionedModuleEntry = await moduleRegistry.getModuleEntry({
                    ...moduleId,
                    importer: entry,
                });
                const uri = await moduleRegistry.resolveModuleUri({ ...moduleId, version: versionedModuleEntry.version }, runtimeEnvironment, runtimeParams);
                res.set({
                    // This redirects to a signed URI
                    // A prettifier is added to the end so resources have a meaningful name in browser devtools
                    Location: uri,
                });
                res.sendStatus(302);
                return;
            }
            const bundleDef = await moduleBundler.getModuleBundle(moduleId, sourceMapRuntimeContext, runtimeParams);
            if (signature !== LATEST_SIGNATURE) {
                res.setHeader('Cache-control', 'public, max-age=31536000, immutable');
            }
            // URIs for generate site
            const resolvedUris = [];
            if (req.isSiteGeneration()) {
                // TODO might be able to remove this in the future but not sure how to properly send
                // back bundleRecord imports with absolute uris (lwc is the main one)
                if (bundleDef.bundleRecord.imports) {
                    for (const theImport of bundleDef.bundleRecord.imports) {
                        const childSpecifier = theImport.specifier;
                        // eslint-disable-next-line no-await-in-loop
                        const id = await getVersionedModuleId(childSpecifier, moduleRegistry);
                        // eslint-disable-next-line no-await-in-loop
                        const uri = await moduleRegistry.resolveModuleUri(id, runtimeEnvironment, runtimeParams);
                        resolvedUris.push(uri);
                    }
                }
                if (bundleDef.bundleRecord.dynamicImports) {
                    for (const theImport of bundleDef.bundleRecord.dynamicImports) {
                        const childSpecifier = theImport.specifier;
                        // eslint-disable-next-line no-await-in-loop
                        const id = await getVersionedModuleId(childSpecifier, moduleRegistry);
                        // eslint-disable-next-line no-await-in-loop
                        const uri = await moduleRegistry.resolveModuleUri(id, runtimeEnvironment, runtimeParams);
                        resolvedUris.push(uri);
                    }
                }
            }
            res.setMetadata({ moduleDefinition: bundleDef, resolvedUris });
            res.type('application/javascript').send(bundleDef.code);
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`bundle for "${moduleId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // Unsigned Bundles => 302
    app.get([
        // Full URL
        `/:apiVersion/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier`,
        // Without Environment
        `/:apiVersion/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier`,
        // Without Locale
        `/:apiVersion/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier`,
        // Without Optional Segments
        `/:apiVersion/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier`,
    ], async (req, res) => {
        const ctx = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = ctx.runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleId;
        try {
            ({ moduleId } = getModuleIdentity(req));
            // Get the importer's specifier via the "importer" query param
            const importerSpecifier = req.query.importer;
            if (importerSpecifier) {
                // Get the importer's file path entry
                const importerModuleId = explodeSpecifier(importerSpecifier);
                const { entry } = await moduleRegistry.getModuleEntry(importerModuleId);
                moduleId = { ...moduleId, importer: entry };
            }
            const { ownHash, moduleEntry } = await moduleRegistry.getModule(moduleId, ctx.runtimeParams);
            if (ownHash) {
                const jsonQuery = req.isJsonRequest()
                    ? `${ctx.runtimeEnvironment.debug ? '&' : '?'}json`
                    : '';
                const uri = await moduleRegistry.resolveModuleUri({ ...moduleId, version: moduleEntry.version }, ctx.runtimeEnvironment, ctx.runtimeParams, ownHash);
                res.set({
                    // This redirects to a signed URI
                    Location: `${uri}${jsonQuery}`,
                });
                res.sendStatus(302);
            }
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`bundle for "${moduleId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // Bundle sourcemaps
    app.get([
        // Full URL
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Environment
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/l/:locale/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Locale
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/e/:environment/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Optional Segments
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/sourcemaps/bundle/:format/:compat?/bi/:bundleSpecifier/module/mi/:specifier/s/:signature/:prettyUrl?`,
    ], async (req, res) => {
        const runtimeContext = req.getRuntimeContext(defaultRuntimeEnvironment);
        const { runtimeParams, runtimeEnvironment } = runtimeContext;
        const targetEnvironment = runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleId, signature;
        try {
            ({ moduleId, signature } = getModuleIdentity(req));
            const bundleDef = await moduleBundler.getModuleBundle(moduleId, runtimeEnvironment);
            if (signature !== LATEST_SIGNATURE) {
                res.setHeader('Cache-control', 'public, max-age=31536000, immutable');
            }
            res.type('application/json').send(bundleDef.map);
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`bundle sourcemap for "${moduleId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // Signed Modules
    // /{apiversion}/module/{format}/{compat}/l/{language}/mi/{specifier}/s/{signature}
    app.get([
        // Full URL
        `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Environment
        `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Locale
        `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier/s/:signature/:prettyUrl?`,
        // Without Optional Segments
        `/:apiVersion/module/:format/:compat/mi/:specifier/latest/:prettyUrl?`,
        `/:apiVersion/module/:format/:compat/mi/:specifier/s/:signature/:prettyUrl?`,
    ], async (req, res) => {
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleId, signature;
        try {
            ({ moduleId, signature } = getModuleIdentity(req));
            if (!req.validateJsonRequest()) {
                throw createDiagnostic({ description: errors.INVALID_JSON() }, LwrUnresolvableError);
            }
            // retrieve the latest module
            const theModule = await moduleRegistry.getLinkedModule(moduleId, runtimeEnvironment, runtimeParams);
            const { ownHash, linkedSource } = theModule;
            // validate the requested instances exists
            if (signature === LATEST_SIGNATURE || ownHash === signature) {
                const code = linkedSource;
                res.setMetadata({ moduleDefinition: theModule });
                if (req.isJsonRequest()) {
                    const json = await serializeModuleToJson(code, theModule, moduleRegistry, runtimeParams);
                    res.type('application/json').send(json);
                }
                else {
                    res.type('application/javascript').send(code);
                }
            }
            else {
                throw createDiagnostic({ description: errors.SIGNED_MODULE(moduleId.specifier, signature) }, LwrUnresolvableError);
            }
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`module "${moduleId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // Unsigned Modules => 302
    app.get([
        // Full URL
        `/:apiVersion/module/:format/:compat/l/:locale/e/:environment/mi/:specifier`,
        // Without Environment
        `/:apiVersion/module/:format/:compat/l/:locale/mi/:specifier`,
        // Without Locale
        `/:apiVersion/module/:format/:compat/e/:environment/mi/:specifier`,
        // Without Optional Segments
        `/:apiVersion/module/:format/:compat/mi/:specifier`,
    ], async (req, res) => {
        const ctx = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = ctx.runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleId;
        try {
            ({ moduleId } = getModuleIdentity(req));
            // Get the importer's specifier via the "importer" query param
            const importerSpecifier = req.query.importer;
            if (importerSpecifier) {
                // Get the importer's file path entry
                const importerModuleId = explodeSpecifier(importerSpecifier);
                const { entry } = await moduleRegistry.getModuleEntry(importerModuleId);
                moduleId = { ...moduleId, importer: entry };
            }
            // Get the module's signature from the registry
            const { ownHash, moduleEntry } = await moduleRegistry.getModule(moduleId, ctx.runtimeParams);
            if (ownHash) {
                const jsonQuery = req.isJsonRequest()
                    ? `${ctx.runtimeEnvironment.debug ? '&' : '?'}json`
                    : '';
                const uri = await moduleRegistry.resolveModuleUri({ ...moduleId, version: moduleEntry.version }, ctx.runtimeEnvironment, ctx.runtimeParams, ownHash);
                res.set({
                    // This redirects to a signed URI
                    Location: `${uri}${jsonQuery}`,
                });
                res.sendStatus(302);
            }
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`module "${moduleId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // Mapping Services
    // /{apiversion}/mapping/{format}/{compat}(/l/{language})?(/e/{environment})?(/bi/{bundleStrategyId})?/mp/{specifiers}
    app.get([
        // Full URL (3 optional segments)
        `/:apiVersion/mapping/:format/:compat/l/:locale/e/:environment/bi/:bundleSpecifier/mp/:specifiers`,
        // With 2 optional segments: l & e, l & bi, e & bi
        `/:apiVersion/mapping/:format/:compat/l/:locale/e/:environment/mp/:specifiers`,
        `/:apiVersion/mapping/:format/:compat/l/:locale/bi/:bundleSpecifier/mp/:specifiers`,
        `/:apiVersion/mapping/:format/:compat/e/:environment/bi/:bundleSpecifier/mp/:specifiers`,
        // With 1 optional segment
        `/:apiVersion/mapping/:format/:compat/l/:locale/mp/:specifiers`,
        `/:apiVersion/mapping/:format/:compat/e/:environment/mp/:specifiers`,
        `/:apiVersion/mapping/:format/:compat/bi/:bundleSpecifier/mp/:specifiers`,
        // With 0 optional segments
        `/:apiVersion/mapping/:format/:compat/mp/:specifiers`,
    ], async (req, res) => {
        const requestContext = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = requestContext.runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let moduleIds;
        try {
            ({ moduleIds } = getMappingIdentity(req));
            const { runtimeEnvironment, runtimeParams } = requestContext;
            const importMetadata = await getImportMetadataMappings(moduleIds, runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler);
            // Include import metadata as an object for use with the static site generator
            res.setMetadata({ importMetadata });
            // Respond to request
            res.status(200).type('application/json').send(importMetadata);
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`mappings for "${JSON.stringify(moduleIds || req.params?.specifiers)}"`, e);
            res.status(error.status).send(error.message);
        }
    });
    // Resources
    app.get([
        // Full URL
        `/:apiVersion/resource/:format/l/:locale/e/:environment/:specifier`,
        // Without Environment
        `/:apiVersion/resource/:format/l/:locale/:specifier`,
        // Without Locale
        `/:apiVersion/resource/:format/e/:environment/:specifier`,
        // Without Optional Segments
        `/:apiVersion/resource/:format/:specifier`,
    ], async (req, res) => {
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(defaultRuntimeEnvironment);
        const targetEnvironment = runtimeParams.environment;
        if (!isSupportedEnvironment(environmentConfig, targetEnvironment)) {
            res.status(400).send({ error: `Environment "${targetEnvironment}" is not supported` });
            return;
        }
        let resourceId;
        try {
            ({ resourceId } = getResourceIdentity(req));
            const resource = await resourceRegistry.getResource(resourceId, runtimeEnvironment, runtimeParams);
            if (resource && resource.content) {
                // Static resource
                const type = resource.type === 'text/css' ? resource.type : 'application/javascript';
                res.type(type).send(resource.content);
            }
            else if (resource && resource.stream) {
                // Stream-able resource
                res.type(resource.type).stream(resource.stream);
            }
            else {
                throw createDiagnostic({ description: errors.RESOURCE(resourceId.specifier) }, LwrUnresolvableError);
            }
            res.setMetadata({ resource });
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`resource "${resourceId?.specifier || req.params?.specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
    // -- Asset configuration -----------------------------------------------------------
    // Custom defined assets
    const paths = context.appConfig.assets.map((a) => a.urlPath);
    // Workaround: https://github.com/pillarjs/path-to-regexp#compatibility-with-express--4x
    // Koa routing (Path-To-RegExp) breaks compatibility with Express routing & asterisk wildcards
    for (let i = 0; i < paths.length; i++) {
        paths[i] = paths[i] + app.getRegexWildcard();
    }
    app.all(paths, async (req, res) => {
        const { runtimeEnvironment } = req.getRuntimeContext(defaultRuntimeEnvironment);
        try {
            const { assetId: { specifier, type }, signature, } = getAssetIdentity(req);
            const assetObj = await context.assetRegistry.getAsset({ specifier, signature, type }, runtimeEnvironment);
            if (assetObj.mime) {
                res.type(assetObj.mime);
            }
            res.setMetadata({ asset: assetObj });
            res.stream(assetObj.stream());
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`asset at "${req.originalUrl}"`, e);
            res.status(error.status).send(error.message);
        }
    });
    // LWR specific assets
    // Workaround: https://github.com/pillarjs/path-to-regexp#compatibility-with-express--4x
    // Koa routing (Path-To-RegExp) breaks compatibility with Express routing & asterisk wildcards
    app.all('/:apiVersion/:assetType/:immutable?/s/:signature/' + app.getRegexWildcard(), async (req, res) => {
        const { runtimeEnvironment } = req.getRuntimeContext(defaultRuntimeEnvironment);
        const { basePath } = runtimeEnvironment;
        const { signature } = req.params;
        const { immutable, assetType: type } = req.params;
        const specifier = req.params[0] ? `/${req.params[0]}` : req.originalUrl;
        const basePathSpecifier = `${basePath}${specifier}`;
        try {
            const assetObj = await context.assetRegistry.getAsset({ specifier: basePathSpecifier, signature, type: type }, runtimeEnvironment, req.isSiteGeneration());
            if (immutable) {
                // WIP: ?
            }
            if (assetObj.mime) {
                res.type(assetObj.mime);
            }
            res.setMetadata({ asset: assetObj });
            res.stream(assetObj.stream());
        }
        catch (e) {
            console.log(e);
            const error = createReturnStatus(`asset at "${specifier}"`, e);
            res.status(error.status).type('text/plain').send(error.message);
        }
    });
}
//# sourceMappingURL=api-middleware.js.map