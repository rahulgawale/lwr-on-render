import { performance } from 'perf_hooks';
import { getSpecifier, getFeatureFlags, hashContent, isSelfUrl, getModuleUriPrefix, getMappingUriPrefix, logger, WARN, INFO, } from '@lwrjs/shared-utils';
import { join, dirname, extname } from 'path';
import fs from 'fs-extra';
import { writeResponse } from './utils/stream.js';
import { createDir, createResourceDir } from './utils/dir.js';
import { explodeMode } from '@lwrjs/config';
export default class SiteGenerator {
    /**
     * Build a static site in the configured directory
     *  - Generate all routes / modules
     *  - copy assets / resources
     *
     * @param config - LWR config for the site
     * @param dispatcher - Facilitate server requests
     */
    async buildStaticApplication(config, dispatcher) {
        const startTime = performance.now();
        logger.info('[Static Generation] starting');
        // De-duplicate warming messages if log level is warn or info
        if (!logger.currentLevel || logger.currentLevel == WARN || logger.currentLevel == INFO) {
            logger.setOptions({ dedupe: new Set([WARN]) });
        }
        const { routes, staticSiteGenerator, rootDir, assets } = config;
        if (!staticSiteGenerator.outputDir) {
            staticSiteGenerator.outputDir = '__generated_site__';
        }
        const outputDir = join(rootDir, staticSiteGenerator.outputDir);
        logger.info(`Clear Output Location: ${outputDir}`);
        fs.rmSync(outputDir, { recursive: true, force: true });
        const urlRewriteMap = new Map();
        const { apiVersion, basePath, lwrVersion, serverMode } = config;
        const runtimeEnvironment = {
            ...explodeMode(serverMode),
            apiVersion,
            basePath,
            lwrVersion,
            debug: false,
            serverMode,
        };
        // For each locale, generate all the modules
        await this.generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, dispatcher, outputDir, urlRewriteMap);
        // Write redirect files
        this.writeNetlifyRedirectConfig(outputDir, urlRewriteMap);
        // Copy over assets
        this.copyAssets(assets, outputDir);
        const endTime = performance.now();
        const timeDiff = (endTime - startTime) / 1000;
        logger.info(`[Static Generation] complete in ${Math.round(timeDiff)} seconds`);
    }
    /**
     * Crawl all view routes for a site
     */
    async generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, dispatcher, outputDir, urlRewriteMap = new Map()) {
        if (!staticSiteGenerator.locales) {
            staticSiteGenerator.locales = ['en-US'];
        }
        const generateUrl = this.createGenerateURLFunction(dispatcher);
        // Note: generateUrl can consume a lot of memory so we need to do this sequentially
        for (const locale of staticSiteGenerator.locales) {
            // Generate all the routes
            for (const route of routes) {
                const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
                // eslint-disable-next-line no-await-in-loop
                await generateUrl(route.path, siteConfig);
            }
            // Generate any additional urls
            if (staticSiteGenerator._additionalRoutePaths) {
                for (const uri of staticSiteGenerator._additionalRoutePaths) {
                    const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
                    // eslint-disable-next-line no-await-in-loop
                    await generateUrl(uri, siteConfig);
                }
            }
            // Handle _additionalModules specifiers
            const { _additionalModules } = staticSiteGenerator;
            if (_additionalModules) {
                for (const specifier of _additionalModules) {
                    const siteConfig = this.createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment);
                    // eslint-disable-next-line no-await-in-loop
                    await this.dispatchJSResourceRecursive(specifier, dispatcher, siteConfig, true);
                }
            }
        }
    }
    /**
     * Creates a function to dispatch the root requests for a given view url
     */
    createGenerateURLFunction(dispatcher) {
        const generateRoute = async (uri, siteConfig) => {
            const locale = siteConfig.locale;
            logger.info(`Start Generate: ${locale} ${uri}`);
            // Kick off site generation for the current route
            await this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'route' }, siteConfig);
            // If there is a view config add any extra collected import metadata to the config
            this.addAdditionalImportMetadataToViewConfig(siteConfig);
            logger.info(`End Generate ${locale} ${uri}`);
        };
        return generateRoute.bind(this);
    }
    /**
     * Primary recursive dispatch function.  Executes a URL and crawls its dependents.
     *
     * @param url - URL to execute
     * @param dispatcher - Facilitates GET requests
     * @param resourceOpts - Data about the URL to execute
     * @param siteConfig - Running config for the current view
     */
    async dispatchResourceRecursive(url, dispatcher, resourceOpts, siteConfig) {
        const { visitedUrls } = siteConfig;
        if (!visitedUrls.has(url)) {
            visitedUrls.add(url); // Maintain a list of visited urls here to avoid potential infinite loops
            // Skip urls with path segment variables (i.e. '/custom/:bar')
            // Users can specify specific urls via the '_additionalRoutePaths' config property
            if (url.indexOf('/:') !== -1 || url.indexOf('*') !== -1) {
                logger.warn('Skipped generation of url with variable path segment: ' + url);
                return;
            }
            // Generate resource
            let context;
            context = await dispatcher.dispatchUrl(url, 'GET', siteConfig.locale);
            // Handle 302 redirect if applicable
            if (context?.fs?.headers?.Location) {
                const redirectUrl = context?.fs?.headers?.Location;
                url = redirectUrl;
                const redirectContext = await dispatcher.dispatchUrl(url, 'GET', siteConfig.locale);
                context = redirectContext;
            }
            const { resourceType } = resourceOpts;
            // -- Routes (root resources) -------
            if (resourceType === 'route') {
                await this.handleHtmlResource(url, context, siteConfig, dispatcher);
                // -- Process Assets (css, images, ...) && Resources (lwr-loader-shim ...)
            }
            else if (resourceType === 'asset' || resourceType === 'resource') {
                await this.handleAssetOrResource(url, context, siteConfig, dispatcher);
                // -- Import Metadata Mappings
            }
            else if (resourceType == 'mapping') {
                await this.handleMappingResource(url, context, siteConfig, dispatcher);
                // -- Process JS files
            }
            else if (resourceType === 'js') {
                await this.handleJavascriptResource(url, context, siteConfig, dispatcher);
            }
        }
    }
    /**
     * Handle processing a returned javascript module or bundle and follow all returned references
     * @param url - URL of the request javascript resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleJavascriptResource(url, context, siteConfig, dispatcher) {
        const { outputDir } = siteConfig;
        const normalizedUrl = decodeURIComponent(url);
        createResourceDir(dirname(normalizedUrl), outputDir);
        const ext = extname(normalizedUrl);
        const fullPath = join(outputDir, `${normalizedUrl}${ext ? '' : '.js'}`);
        await writeResponse(context, fullPath);
        // Build up a list of dispatch requests to kick off in parallel
        const dispatchRequests = [];
        // Add URL re-writes for module redirects
        if (normalizedUrl.indexOf('/s/') !== -1) {
            // Redirect unsigned to signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf('/s/')), normalizedUrl);
            // Redirect encoded signed URIs to UNencoded signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule%2Fv%2F0_1_6/s/{signature} -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf('/s/')), normalizedUrl);
            // Redirect unversioned/unsigned URIs to signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c/module -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            // e.g. with importer /1/bundle/amd/l/en-US/bi/0/module/mi/c/module?importer=parent%2Fmodule%2Fv%2F2_1_0 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf('/v/')), normalizedUrl);
            // Redirect encoded unversioned/unsigned URIs to UNencoded signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            // e.g. with importer /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule?importer=parent%2Fmodule%2Fv%2F2_1_0 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf('%2Fv%2F')), normalizedUrl);
        }
        // Recursively traverse dependencies
        const moduleDefinition = context.fs?.metadata?.moduleDefinition; // LinkedModuleDefinition | BundleDefinition
        if (moduleDefinition) {
            // Imports
            const imports = moduleDefinition.linkedModuleRecord?.imports || moduleDefinition.bundleRecord?.imports || [];
            // /1/module/esm/0/l/en-US/mi/lwc
            for (const importModule of imports) {
                const jsUri = importModule.specifier.startsWith('/')
                    ? importModule.specifier
                    : getSpecifier(importModule);
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
            // Dynamic imports
            const dynamicImports = moduleDefinition.linkedModuleRecord?.dynamicImports ||
                moduleDefinition.bundleRecord?.dynamicImports ||
                [];
            for (const importModule of dynamicImports) {
                const jsUri = importModule.specifier.startsWith('/')
                    ? importModule.specifier
                    : getSpecifier(importModule);
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
        }
        // Bundles with unresolved module uris
        const uris = context.fs?.metadata?.resolvedUris || [];
        for (const jsUri of uris) {
            dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
        }
        // -- Dispatch dependencies
        await Promise.all(dispatchRequests);
    }
    /**
     * Handle processing a returned module URI mapping resource and follow all returned references
     * @param url - URL of the request mapping resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleMappingResource(url, context, siteConfig, dispatcher) {
        const { importMetadata: importMetatdata } = siteConfig;
        const statusCode = context.response?.status;
        // Received a server error
        if (statusCode === 200) {
            // Read JSON
            const newImportMetadata = context.fs?.body;
            let filteredImportMetadata;
            if (!importMetatdata) {
                filteredImportMetadata = newImportMetadata;
            }
            else {
                // need to handle importMetadata when generating from a view
                filteredImportMetadata = importMetatdata.addAdditionalMetadata(newImportMetadata);
            }
            // Filter out and import metadata already included with the view
            // const filteredImportMetadata = importMetatdata.addAdditionalMetadata(newImportMetadata);
            // Build up a list of dispatch requests to kick off in parallel
            const dispatchRequests = [];
            // Iterate through the import mappings and return request uris
            for (const uri of Object.keys(filteredImportMetadata.imports)) {
                dispatchRequests.push(this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'js' }, siteConfig));
            }
            // Wait for all requests to comeback
            await Promise.all(dispatchRequests);
        }
        else {
            const body = context.fs?.body;
            logger.warn(`Failed to fetch ${url}: (${statusCode}) ${body}`);
        }
    }
    /**
     * Handle processing a returned HTML resource and process any provided view metadata
     *
     * @param url - URL of the requested HTML resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network Dispatcher
     */
    async handleHtmlResource(url, context, siteConfig, dispatcher) {
        const { outputDir } = siteConfig;
        let fileName = 'index.html';
        let directoryPath = url;
        // If we have a route path that ends with a html or xml file extension,
        // use that last path segment for the file name
        if (url.endsWith('.html') || url.endsWith('.xml')) {
            const lastPathIndex = url.lastIndexOf('/') + 1;
            fileName = url.substring(lastPathIndex, url.length);
            directoryPath = url.substring(0, lastPathIndex);
        }
        const dir = createResourceDir(directoryPath, outputDir);
        const localeDir = createResourceDir(directoryPath, join(outputDir, siteConfig.locale));
        // TODO: Should we handle routes with non-html extensions differently?
        // Example Route: "path": "/mixed_templates.md" (not sure why you would do this)
        //                "contentTemplate": "$contentDir/composed_markdown.md"
        // Today this will get written to  /mixed_templates.md/index.html
        // Which we workaround by setting "renderSingle": true in serve.json
        const filePath = join(dir, fileName);
        const fileLocalePath = join(localeDir, fileName);
        // Default Path (only write once)
        // The default locale is english
        if (siteConfig.locale.toLowerCase().startsWith('en')) {
            siteConfig.viewPaths.add(filePath);
            await writeResponse(context, filePath);
        }
        // Language path (always write out)
        createDir(localeDir);
        siteConfig.viewPaths.add(fileLocalePath);
        await writeResponse(context, fileLocalePath);
        // Get the metadata
        const viewDefinition = context.fs?.metadata?.viewDefinition;
        if (viewDefinition) {
            // Process all references in the view
            await this.handleViewDefinition(viewDefinition, siteConfig, dispatcher);
        }
    }
    /**
     * Handle processing a returned view definition by following all returned references
     * @param viewDefinition - Metadata about everything directly referenced form the view
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleViewDefinition(viewDefinition, siteConfig, dispatcher) {
        // Save existing import metadata
        if (viewDefinition.viewRecord.importMetadata) {
            // Initialize import metadata collector
            siteConfig.importMetadata = new ViewImportMetadataImpl(viewDefinition.viewRecord.importMetadata);
        }
        // Build up a list of dispatch requests to kick off in parallel
        const dispatchRequests = [];
        // Assets
        const assets = viewDefinition.viewRecord.assetReferences || [];
        for (const asset of assets) {
            const assetUrl = asset.override?.uri || asset.url;
            // skip self referential asset urls / data urls (i.e. <img src="" /> <img src="data:image/png;base64, iVBORw0..." />)
            if (assetUrl && !isSelfUrl(assetUrl)) {
                dispatchRequests.push(this.dispatchResourceRecursive(assetUrl, dispatcher, { resourceType: 'asset', asset }, siteConfig));
            }
        }
        // Custom Elements
        const customElements = viewDefinition.viewRecord.customElements || [];
        for (const customElement of customElements) {
            const jsUris = Object.values(customElement.flatGraph.uriMap);
            for (const jsUri of jsUris) {
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
        }
        // Bootstrap modules
        if (viewDefinition.viewRecord.bootstrapModule) {
            const boot = viewDefinition.viewRecord.bootstrapModule;
            const jsUris = Object.values(boot.flatGraph.uriMap);
            for (const jsUri of jsUris) {
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
        }
        // Bootstrap Resources
        const bootstrapResources = viewDefinition.viewRecord.bootstrapModule?.resources || [];
        for (const resource of bootstrapResources) {
            // If resource is not inline download it for reference
            if (!resource.inline) {
                const resourceUri = resource.src || resource.specifier;
                if (resourceUri) {
                    dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, { resourceType: 'resource' }, siteConfig));
                    // Rough identify if this is the config Uri and add it to the site config to store additional import metadata
                    if (resourceUri.match(/\/application\/.*\/ai\/.*\/configuration/)) {
                        siteConfig.viewConfigPath = this.getResourcePathFromUrl(siteConfig, resourceUri);
                    }
                }
                else {
                    logger.warn('Skipped inline bootstrap resource: %j', resource);
                }
            }
        }
        // Resources
        const resources = viewDefinition.viewRecord.resources || [];
        for (const resource of resources) {
            const resourceUri = resource.src || resource.specifier || '';
            if (resourceUri.startsWith('/')) {
                dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, { resourceType: 'resource' }, siteConfig));
            }
            else {
                logger.warn('Skipped resource: %j', resource);
            }
        }
        // -- Dispatch dependencies
        await Promise.all(dispatchRequests);
    }
    async dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig, isAdditionalModulesRequest) {
        if (jsUri.startsWith('/')) {
            await this.dispatchResourceRecursive(jsUri, dispatcher, { resourceType: 'js' }, siteConfig);
        }
        else {
            const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
            if (supportsFingerprints) {
                // Download mapping
                const mappingEndpoint = siteConfig.endpoints?.uris?.mapping;
                if (mappingEndpoint) {
                    const mappingURL = siteConfig.endpoints?.uris?.mapping + encodeURIComponent(jsUri);
                    await this.dispatchResourceRecursive(mappingURL, dispatcher, { resourceType: 'mapping' }, siteConfig);
                }
                else {
                    logger.warn('Unable to fetch mapping for bare specifier or variable dynamic import: "' +
                        jsUri +
                        '"');
                }
            }
            // TODO: this code path was still being hit prior to _additionalModules
            // flag for bare dynamic imports metadata.  This flag keeps the behavior as
            // before until we can figure out what to do with those requests.
            else if (isAdditionalModulesRequest) {
                // fallback to globalThis.LWR.imports.default
                const uri = `${siteConfig.endpoints?.uris.legacyDefault}${encodeURIComponent(jsUri)}`;
                await this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'js' }, siteConfig);
            }
        }
    }
    /**
     * Handle processing a returned asset or resource
     * @param url - URL of the requested asset or resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     */
    async handleAssetOrResource(url, context, siteConfig, dispatcher) {
        const metadata = context.fs?.metadata;
        const fullPath = this.getResourcePathFromUrl(siteConfig, url);
        await writeResponse(context, fullPath);
        // Call and referenced assets...
        const assetReferences = metadata?.asset?.metadata?.assetReferences || [];
        const dispatchRequests = [];
        for (const ref of assetReferences) {
            const refUrl = ref.override?.uri || ref.url;
            dispatchRequests.push(this.dispatchResourceRecursive(refUrl, dispatcher, { resourceType: 'asset', asset: metadata?.asset }, siteConfig).catch((err) => {
                // Warn the user that the we failed to fetch a referenced asset
                logger.warn(`Failed to fetch asset reference => ${refUrl} from ${url}`, err);
            }));
        }
        return Promise.all(dispatchRequests);
    }
    getResourcePathFromUrl(siteConfig, url) {
        const { outputDir } = siteConfig;
        const normalizedUrl = decodeURIComponent(url);
        createResourceDir(dirname(normalizedUrl), outputDir);
        const fullPath = join(outputDir, normalizedUrl);
        return fullPath;
    }
    /**
     *  Write out redirect mapping files for static hosting services like netlify. Examples for why this is needed:
     *  -- Redirect /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6/s/{signature}
     *  -- Redirect /1/bundle/amd/l/en-US/bi/0/module/mi/lwr%2Fnavigation%2Fv%2F0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6/s/{signature}
     *
     * @param outputDir
     * @param urlRewriteMap
     */
    writeNetlifyRedirectConfig(outputDir, urlRewriteMap) {
        const serveJsonPath = join(outputDir, 'serve.json');
        const _redirectsPath = join(outputDir, '_redirects');
        if (fs.existsSync(_redirectsPath)) {
            fs.unlinkSync(_redirectsPath); // Delete the file if it exists
        }
        fs.createFileSync(_redirectsPath);
        const rewrites = [];
        urlRewriteMap.forEach((destination, source) => {
            // serve.json (serve)
            rewrites.push({
                source,
                destination,
            });
            // _redirects (netlify)
            fs.appendFileSync(_redirectsPath, source + ' ' + destination + ' 302!\n');
        });
        // write out the serve.json - redirects for modules without signatures
        fs.writeFileSync(serveJsonPath, JSON.stringify({ rewrites, directoryListing: false, renderSingle: true }, null, 1));
    }
    /**
     * Copy over assets
     * TODO this results in duplicate assets at the moment since assets can be referenced multiple ways:
     * '/public/assets/images/logo.svg'
     * '/1/asset/s/latest/public/assets/images/logo.svg'
     *
     * @param assets AssetConfig
     *
     */
    copyAssets(assets, outputDir) {
        for (const asset of assets) {
            try {
                const assetSrcDir = asset.dir || asset.file;
                const assetOutputDir = join(outputDir, asset.urlPath);
                if (assetSrcDir && fs.existsSync(assetSrcDir)) {
                    fs.copySync(assetSrcDir, assetOutputDir);
                }
                else {
                    logger.warn('Could not find assets to copy at path: ' + assetSrcDir);
                }
            }
            catch (e) {
                logger.error('Error occurred processing asset config: ' + JSON.stringify(asset), e);
            }
        }
    }
    /**
     * Create a new site config for the current view
     */
    createSiteConfig(outputDir, locale, urlRewriteMap, runtimeEnvironment) {
        const featureFlags = this.filterFeatureFlags();
        const endpoints = {
            uris: {
                // legacy globalThis.LWR.importMappings.default
                legacyDefault: getModuleUriPrefix(runtimeEnvironment, { locale }),
                mapping: getMappingUriPrefix(runtimeEnvironment, { locale }),
            },
        };
        return {
            outputDir,
            viewPaths: new Set(),
            visitedUrls: new Set(),
            locale,
            urlRewriteMap,
            endpoints,
            // Only include LEGACY_LOADER if true
            ...featureFlags,
        };
    }
    filterFeatureFlags() {
        if (getFeatureFlags().LEGACY_LOADER) {
            return { featureFlags: { LEGACY_LOADER: true } };
        }
        else {
            return undefined;
        }
    }
    /**
     * Add any additional import metadata collected during static site generation to the Client Bootstrap Config for this view.
     */
    addAdditionalImportMetadataToViewConfig(siteConfig) {
        const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
        const additionalImportMetadata = siteConfig?.importMetadata?.getAdditionalImportMetadata();
        if (supportsFingerprints &&
            siteConfig.viewConfigPath &&
            additionalImportMetadata?.imports &&
            Object.keys(additionalImportMetadata.imports).length > 0) {
            // Build and stringify the new import metadata
            const imports = additionalImportMetadata.imports
                ? JSON.stringify(additionalImportMetadata.imports)
                : '{}';
            const initImports = `if (!globalThis.LWR.imports) { globalThis.LWR.imports = {}; }`;
            const mergeImports = `Object.assign(globalThis.LWR.imports, ${imports})`;
            const index = additionalImportMetadata.index
                ? JSON.stringify(additionalImportMetadata.index)
                : '{}';
            const initIndex = `if (!globalThis.LWR.index) { globalThis.LWR.index = {}; }`;
            const mergeIndex = `Object.assign(globalThis.LWR.index, ${index})`;
            // Read in the old config and append the new import metadata
            const oldConfig = fs.readFileSync(siteConfig.viewConfigPath, 'utf-8');
            const newConfig = `${oldConfig}\n// Appended by Static Site Generator\n${initImports}\n${mergeImports}\n${initIndex}\n${mergeIndex}\n`;
            const configHash = hashContent(newConfig);
            // Write the updated config to a new filepath containing its hash signature, and delete the old config
            const sigRegex = /\/s\/[a-z0-9]+\/config\.js/i;
            const configSuffix = `/s/${configHash}/config.js`;
            const newConfigPath = siteConfig.viewConfigPath.replace(sigRegex, configSuffix);
            fs.mkdirSync(dirname(newConfigPath), { recursive: true }); // we know this dir does not exist
            fs.writeFileSync(newConfigPath, newConfig, 'utf-8');
            fs.rmSync(siteConfig.viewConfigPath);
            // Update the config script src in the view document(s)
            siteConfig.viewPaths.forEach((path) => {
                const oldDoc = fs.readFileSync(path, 'utf-8');
                const newDoc = oldDoc.toString().replace(sigRegex, configSuffix);
                fs.writeFileSync(path, newDoc, 'utf-8');
            });
        }
    }
}
// Class used to track import metadata for a view
export class ViewImportMetadataImpl {
    constructor(existingImportMetadata, additionalImportMetadata) {
        this.existing = existingImportMetadata;
        this.additional = additionalImportMetadata || { imports: {}, index: {} };
    }
    /**
     * Get the additional import metadata collected while generating this view
     * @returns
     */
    getAdditionalImportMetadata() {
        return this.additional;
    }
    /**
     * Adds any new imports found to the additional metadata map.  Returns a filtered
     * map of imports not in the initial view
     */
    addAdditionalMetadata(newMetadata) {
        const filteredImports = this.filterMetadata(newMetadata);
        this.mergeImportMetadata(this.additional, filteredImports);
        return filteredImports;
    }
    /**
     * Filter out any existing import metadata the would have already been sent back with the view from set of additional metadata detected
     */
    filterMetadata(newMetadata) {
        // Filter Imports
        const importsArray = Object.entries(newMetadata.imports);
        const filteredImports = importsArray.filter(([key]) => !this.existing.imports[key]);
        const imports = Object.fromEntries(filteredImports);
        // Filter Index
        const indexArray = Object.entries(newMetadata.index || {});
        const filteredIndex = indexArray.filter(([key]) => !this.existing.index || !this.existing.index[key]);
        const index = Object.fromEntries(filteredIndex);
        return {
            imports,
            index,
        };
    }
    /**
     * Merge new import metadata into target import metadata
     */
    mergeImportMetadata(targetImportMetdadata, newImportMetadata) {
        Object.assign(targetImportMetdadata.imports, newImportMetadata.imports);
        if (targetImportMetdadata.index) {
            Object.assign(targetImportMetdadata.index, newImportMetadata.index || {});
        }
    }
}
//# sourceMappingURL=static-generation.js.map