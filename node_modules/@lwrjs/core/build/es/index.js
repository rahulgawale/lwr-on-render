import { deepFreeze, getFeatureFlags, DEFAULT_LWR_BOOTSTRAP_CONFIG, logger } from '@lwrjs/shared-utils';
import { LwrCompiler } from '@lwrjs/compiler';
import { LwrModuleBundler } from '@lwrjs/module-bundler';
import { LwrModuleRegistry } from '@lwrjs/module-registry';
import { LwrResourceRegistry } from '@lwrjs/resource-registry';
import { LwrAssetRegistry } from '@lwrjs/asset-registry';
import { LwrViewRegistry } from '@lwrjs/view-registry';
import { LwrServerError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { normalizeConfig, explodeMode } from '@lwrjs/config';
import { LwrApplicationObserver } from '@lwrjs/shared-utils';
import localeMiddleware from './middlewares/locale-middleware.js';
import apiMiddleware from './middlewares/api-middleware.js';
import uiMiddleware from './middlewares/ui-middleware.js';
import hmrMiddleware from './middlewares/hmr-middleware.js';
import { getGlobalData } from './context/global-data.js';
import { runConfigurationsHook } from './context/hooks.js';
import baseMiddleware from './middlewares/base-middleware.js';
import { createInternalServer } from '@lwrjs/server';
import { getServiceModule } from './context/services.js';
import SiteGenerator from './tools/static-generation.js';
import { warmupServer } from './tools/server-warmup.js';
// Parse the service constructors and instantiate them
async function getServices(services, providerContext, lwrConfig) {
    return Promise.all(services.map(async (serviceEntry) => {
        const [serviceName, serviceConfig = {}] = Array.isArray(serviceEntry)
            ? serviceEntry
            : [serviceEntry];
        const ServiceCtor = await getServiceModule(serviceName, lwrConfig);
        return new ServiceCtor(serviceConfig, providerContext);
    }));
}
function initMiddlewares(app, server, serverContext) {
    // Base middlewares for cookies, session, admin authentication, gzip, ...
    baseMiddleware(app, serverContext);
    localeMiddleware(app, serverContext);
    apiMiddleware(app, serverContext);
    uiMiddleware(app, serverContext);
    if (serverContext.runtimeEnvironment.hmrEnabled) {
        // setup hmr middleware
        hmrMiddleware(server, serverContext);
    }
}
async function initContext(app, server, rawLwrConfig) {
    const { apiVersion, basePath, lwrVersion, serverMode, globalDataDir, globalData } = rawLwrConfig;
    const rawDataConfig = getGlobalData(globalDataDir, globalData);
    const rawRuntimeEnvConfig = {
        ...explodeMode(serverMode),
        apiVersion,
        basePath,
        lwrVersion,
        debug: false,
        serverMode,
        featureFlags: getFeatureFlags(),
    };
    const hookProviders = await getServices(rawLwrConfig.hooks, undefined, rawLwrConfig);
    const { lwrConfig, dataConfig, runtimeConfig } = await runConfigurationsHook(hookProviders, rawLwrConfig, rawDataConfig, rawRuntimeEnvConfig);
    const assetTransformers = await getServices(rawLwrConfig.assetTransformers, undefined, rawLwrConfig);
    const appObserver = new LwrApplicationObserver();
    const appEmitter = appObserver.createLwrEmitter();
    const compiler = new LwrCompiler();
    const assetRegistry = new LwrAssetRegistry({
        assetTransformers,
        appObserver,
        appEmitter,
        runtimeEnvironment: runtimeConfig,
    }, lwrConfig);
    const moduleRegistry = new LwrModuleRegistry({
        compiler,
        appObserver,
        appEmitter,
        runtimeEnvironment: runtimeConfig,
    }, lwrConfig);
    const moduleBundler = new LwrModuleBundler({ compiler, moduleRegistry, appObserver }, lwrConfig);
    const resourceRegistry = new LwrResourceRegistry();
    const viewRegistry = new LwrViewRegistry({
        moduleRegistry,
        moduleBundler,
        resourceRegistry,
        assetRegistry,
        appObserver,
        appEmitter,
        globalData: dataConfig,
        runtimeEnvironment: runtimeConfig,
    }, lwrConfig);
    // Initialized PRIVATE server-side context, passed to middlewares
    const serverContext = {
        compiler,
        server,
        appObserver,
        appEmitter,
        moduleRegistry,
        moduleBundler,
        resourceRegistry,
        assetRegistry,
        viewRegistry,
        appConfig: lwrConfig,
        runtimeEnvironment: runtimeConfig,
    };
    // This is a subset of config to user-land code
    const { cacheDir, lwc: { modules = [] }, routes, errorRoutes, rootDir, contentDir, layoutsDir, locker, amdLoader, esmLoader, environment, } = lwrConfig;
    const { onModuleDefinitionChange, onModuleSourceChange } = appObserver;
    const { notifyModuleDefinitionChanged, notifyModuleSourceChanged, notifyViewSourceChanged, notifyAssetSourceChanged, } = appEmitter;
    const providerContext = {
        compiler,
        appObserver: deepFreeze({ onModuleDefinitionChange, onModuleSourceChange }),
        appEmitter: {
            notifyModuleDefinitionChanged: (payload) => notifyModuleDefinitionChanged.call(appEmitter, payload),
            notifyModuleSourceChanged: (payload) => notifyModuleSourceChanged.call(appEmitter, payload),
            notifyViewSourceChanged: (payload) => notifyViewSourceChanged.call(appEmitter, payload),
            notifyAssetSourceChanged: (payload) => notifyAssetSourceChanged.call(appEmitter, payload),
        },
        moduleRegistry: moduleRegistry.getPublicApi(),
        moduleBundler: moduleBundler,
        resourceRegistry: resourceRegistry.getPublicApi(),
        viewRegistry: viewRegistry.getPublicApi(),
        assetRegistry: assetRegistry.getPublicApi(),
        config: deepFreeze({
            cacheDir,
            modules,
            routes,
            errorRoutes,
            rootDir,
            basePath,
            contentDir,
            layoutsDir,
            locker,
            amdLoader,
            esmLoader,
            environment,
        }),
        runtimeEnvironment: deepFreeze(runtimeConfig),
    };
    // Module Providers
    const moduleProviders = await getServices(lwrConfig.moduleProviders, providerContext, lwrConfig);
    moduleRegistry.addModuleProviders(moduleProviders);
    // Resource Providers
    const resourceProviders = await getServices(lwrConfig.resourceProviders, providerContext, lwrConfig);
    resourceRegistry.addResourceProviders(resourceProviders);
    // View Providers
    const viewProviders = await getServices(lwrConfig.viewProviders, providerContext, lwrConfig);
    // View Transformers
    const viewTransformers = await getServices(rawLwrConfig.viewTransformers, providerContext, rawLwrConfig);
    viewRegistry.addViewProviders(viewProviders);
    viewRegistry.addViewTransformers(viewTransformers);
    await viewRegistry.initializeViewProviders();
    // Asset Providers
    const assetProviders = await getServices(lwrConfig.assetProviders, providerContext, lwrConfig);
    assetRegistry.addAssetProviders(assetProviders);
    return serverContext;
}
export class LwrApp {
    constructor(config) {
        this.initialized = false;
        this.config = normalizeConfig(config);
        const { basePath } = this.config;
        this.app = createInternalServer(this.config.serverType, { basePath });
        this.server = this.app.createHttpServer();
    }
    setConfig(config) {
        this.config = normalizeConfig(config);
    }
    getConfig() {
        return this.config;
    }
    async init() {
        if (!this.initialized) {
            this.initialized = true;
            try {
                const context = await initContext(this.app, this.server, this.config);
                initMiddlewares(this.app, this.server, context);
            }
            catch (e) {
                this.initialized = false;
                throw e;
            }
        }
    }
    async listen(callback) {
        await this.init();
        const { server, config, app } = this;
        const { serverMode, port } = config;
        return new Promise((resolve, reject) => {
            const handleError = (err) => {
                server.off('error', handleError);
                if (err.code === 'EADDRINUSE') {
                    err = new Error(`Port ${port} is already in use.`);
                }
                reject(err);
            };
            server.on('error', handleError);
            server.listen(port, async () => {
                server.off('error', handleError);
                if (process.env.WARMUP?.toLowerCase() === 'true') {
                    try {
                        await warmupServer(config, app.getInternalRequestKey());
                    }
                    catch (err) {
                        const diagnostic = createSingleDiagnosticError({
                            description: descriptions.SERVER.WARMUP_ERROR(err.message),
                        }, LwrServerError);
                        return reject(diagnostic);
                    }
                }
                const opts = { serverMode, port };
                callback?.(opts);
                resolve(opts);
            });
        });
    }
    async close() {
        this.server?.close && (await this.server.close());
    }
    // Get the underlying server (e.g. express, koa...)
    getInternalServer() {
        return this.app.getImpl();
    }
    // Return the public server interface which is compatible with all server types
    getServer() {
        return {
            use: this.app.use.bind(this.app),
            all: this.app.all.bind(this.app),
            get: this.app.get.bind(this.app),
            post: this.app.post.bind(this.app),
            getRegexWildcard: this.app.getRegexWildcard.bind(this.app),
        };
    }
}
export function createServer(config) {
    return new LwrApp(config);
}
export async function generateStaticSite(config) {
    config = config || {};
    config.serverType = 'fs'; // override serverType
    const { serverMode } = config;
    if (serverMode === 'dev' || serverMode === 'compat') {
        // TODO: dynamic imports are not generated in dev mode
        // https://github.com/salesforce/lwr/issues/1111
        logger.warn('static generation in `dev` or `compat` mode is currently not fully supported');
    }
    const lwrApp = createServer(config);
    overrideConfigAsSrc(lwrApp);
    await lwrApp.init();
    const dispatcher = lwrApp.getInternalServer();
    await new SiteGenerator().buildStaticApplication(lwrApp.getConfig(), dispatcher);
}
/**
 * Create normalized config for static generation forcing the app config to come as src
 */
function overrideConfigAsSrc(lwrApp) {
    if (!getFeatureFlags().LEGACY_LOADER) {
        const normalizedConfig = lwrApp.getConfig();
        const routes = normalizedConfig.routes || [];
        for (const route of routes) {
            route.bootstrap = {
                ...DEFAULT_LWR_BOOTSTRAP_CONFIG,
                ...route.bootstrap,
                configAsSrc: true,
            };
        }
    }
}
//# sourceMappingURL=index.js.map