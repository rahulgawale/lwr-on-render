var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/module-bundler/src/esm/rollup-esm-bundler-plugin.ts
__markAsModule(exports);
__export(exports, {
  bundleDefinitions: () => bundleDefinitions
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
function bundleDefinitions(options) {
  const {
    rootModuleDef,
    moduleRegistry,
    exclude,
    alias = {},
    runtimeEnvironment,
    runtimeParams,
    requiredImports,
    dynamicImports
  } = options;
  const visitedDefs = new Map([[rootModuleDef.specifier, rootModuleDef]]);
  const visitedAliasUris = new Map();
  return {
    name: "bundle-plugin",
    resolveDynamicImport() {
      return false;
    },
    resolveId(id, importer) {
      const moduleDef = visitedDefs.get(id);
      if (visitedAliasUris.has(id)) {
        return visitedAliasUris.get(id);
      }
      if (moduleDef && moduleDef.linkedModuleRecord) {
        const d = moduleDef.linkedModuleRecord.dynamicImports || [];
        d.forEach((e) => {
          const {namespace, name, version, sourceSpecifier, moduleNameType} = e;
          dynamicImports.set(`${sourceSpecifier}_${version}`, {
            namespace,
            name,
            specifier: sourceSpecifier,
            version,
            sourceSpecifier,
            moduleNameType
          });
        });
      }
      if (exclude && moduleDef && importer && exclude.includes(moduleDef.specifier)) {
        const {namespace, name, specifier, version} = moduleDef;
        requiredImports.set(`${specifier}_${version}`, {
          namespace,
          name,
          specifier,
          version
        });
        return {
          id,
          external: true
        };
      }
      return id;
    },
    async load(id) {
      const moduleDef = visitedDefs.get(id);
      const imports = moduleDef.linkedModuleRecord.imports || [];
      for (const refImport of imports) {
        let refModuleDef = visitedDefs.get(refImport.specifier);
        if (!refModuleDef) {
          let specifier = (0, import_shared_utils.getSpecifier)({namespace: refImport.namespace, name: refImport.name});
          let explodedSpecifier = refImport;
          let aliasSpecifierUri;
          const specifierUri = refImport.specifier;
          const hasAlias = !!alias[specifier];
          if (hasAlias) {
            specifier = alias[specifier];
            explodedSpecifier = (0, import_shared_utils.explodeSpecifier)(specifier);
            const aliasModuleEntry = await moduleRegistry.getModuleEntry(explodedSpecifier, runtimeParams);
            aliasSpecifierUri = await moduleRegistry.resolveModuleUri(aliasModuleEntry, runtimeEnvironment, runtimeParams);
          }
          refModuleDef = await moduleRegistry.getLinkedModule({
            specifier,
            namespace: explodedSpecifier.namespace,
            name: explodedSpecifier.name,
            scope: hasAlias ? void 0 : refImport.scope,
            version: explodedSpecifier.version
          }, runtimeEnvironment, runtimeParams);
          visitedDefs.set(specifierUri, refModuleDef);
          if (hasAlias) {
            visitedDefs.set(aliasSpecifierUri, refModuleDef);
            visitedAliasUris.set(specifierUri, aliasSpecifierUri);
          }
        }
      }
      return moduleDef.linkedSource;
    }
  };
}
