import { getCacheKeyFromJson, InflightTasks, TaskPool } from '@lwrjs/shared-utils';
import { amdBundler } from './amd/amd-bundler.js';
import { esmBundler } from './esm/esm-bundler.js';
const TASK_POOL = new TaskPool();
export class LwrModuleBundler {
    constructor(config, globalConfig) {
        this.cache = new Map();
        // Pending bundle definitions are tracked to prevent concurrent resolution of the same bundle.
        // Subsequent requests for the same bundle will await the original promise.
        // Cache entries will be removed once the bundle is resolved.
        this.inflightBundleDefinitions = new InflightTasks();
        this.config = globalConfig;
        this.moduleRegistry = config.moduleRegistry;
        this.appObserver = config.appObserver;
        this.compiler = config.compiler;
        this.appObserver?.onModuleDefinitionChange(() => {
            // TODO: This is a very naive approach however
            // this would only happen in non-prod environments
            this.cache.clear();
        });
    }
    async getModuleBundle(moduleId, runtimeEnvironment, runtimeParams = {}, bundleConfigOverrides) {
        const { moduleRegistry } = this;
        const { format, minify, debug } = runtimeEnvironment;
        const cacheKey = `${moduleId.specifier}|${moduleId.version}|${getCacheKeyFromJson({
            locale: runtimeParams.locale,
            format,
            minify,
            debug,
            bundleConfigOverrides,
        })}`;
        const cacheDisabled = process.env.NOCACHE === 'true';
        if (!cacheDisabled) {
            // Return the cached bundle definition
            if (this.cache.has(cacheKey)) {
                // TODO add to profiling
                // console.log('[INFO] Bundle Cache Hit: ', cacheKey);
                const bundleDef = this.cache.get(cacheKey);
                return bundleDef;
            }
        }
        return this.inflightBundleDefinitions.execute(cacheKey, () => {
            // TODO add to profiling
            // console.log('[INFO] Create Bundle: ', cacheKey);
            // Run theses tasks in a task pool to throttle parallel requests.
            return TASK_POOL.execute(async () => {
                const pendingBundleDef = format === 'amd'
                    ? amdBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams, this.config, bundleConfigOverrides)
                    : esmBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams, this.config, bundleConfigOverrides);
                pendingBundleDef.then(async (bundleDef) => {
                    const minified = !!minify && !debug;
                    if (minified) {
                        bundleDef.code = (await this.compiler.minifyJavascript(bundleDef.code)).code;
                    }
                    if (!cacheDisabled) {
                        this.cache.set(cacheKey, bundleDef);
                    }
                    return bundleDef;
                });
                return pendingBundleDef;
            }, this);
        });
    }
}
//# sourceMappingURL=index.js.map