/* eslint-disable no-await-in-loop */
import { explodeSpecifier, getSpecifier } from '@lwrjs/shared-utils';
/*
 * Note: The prefix "@bundle" is do allow rollup to pretty print the imports in case of an error
 * Otherwise since the imports start with a "/" it think its an absolute path doing "../" all over the place
 */
export function bundleDefinitions(options) {
    const { rootModuleDef, moduleRegistry, exclude, alias = {}, runtimeEnvironment, runtimeParams, requiredImports, dynamicImports, } = options;
    // Manually add the root to visited so it can be found on the load hook
    const visitedDefs = new Map([[rootModuleDef.specifier, rootModuleDef]]);
    const visitedAliasUris = new Map();
    return {
        name: 'bundle-plugin',
        resolveDynamicImport() {
            // NOTE: This might be configurable in the future
            return false;
        },
        resolveId(id, importer) {
            const moduleDef = visitedDefs.get(id);
            if (visitedAliasUris.has(id)) {
                return visitedAliasUris.get(id);
            }
            // Collect dynamic import information here
            if (moduleDef && moduleDef.linkedModuleRecord) {
                const d = moduleDef.linkedModuleRecord.dynamicImports || [];
                d.forEach((e) => {
                    const { namespace, name, version, sourceSpecifier, moduleNameType } = e;
                    // Not sure why this has to be source specifier but things break otherwise
                    dynamicImports.set(`${sourceSpecifier}_${version}`, {
                        namespace,
                        name,
                        specifier: sourceSpecifier,
                        version,
                        sourceSpecifier,
                        moduleNameType,
                    });
                });
            }
            // if importer is null is the entry which we must ignore for externals
            if (exclude && moduleDef && importer && exclude.includes(moduleDef.specifier)) {
                const { namespace, name, specifier, version } = moduleDef;
                requiredImports.set(`${specifier}_${version}`, {
                    namespace,
                    name,
                    specifier,
                    version,
                });
                return {
                    id: id,
                    external: true,
                };
            }
            return id;
        },
        async load(id) {
            const moduleDef = visitedDefs.get(id); // by definition we must have a cache hit
            const imports = moduleDef.linkedModuleRecord.imports || [];
            /*
             * For each import we are going to fetch its moduleDefinition so we can add it
             * ahead of time to the visited list so it will be found as rollup traverses the tree
             */
            for (const refImport of imports) {
                let refModuleDef = visitedDefs.get(refImport.specifier);
                if (!refModuleDef) {
                    // The refeference imports have the specifier pointing to a URI.
                    // so we take the original specifier instead
                    let specifier = getSpecifier({ namespace: refImport.namespace, name: refImport.name });
                    let explodedSpecifier = refImport;
                    let aliasSpecifierUri;
                    const specifierUri = refImport.specifier;
                    const hasAlias = !!alias[specifier];
                    if (hasAlias) {
                        // Override the original raw specifier and the exploded version
                        // so the code that will load will be the aliased
                        specifier = alias[specifier];
                        explodedSpecifier = explodeSpecifier(specifier);
                        // We also need to remap the original URI to point to the aliased URI so
                        // we endup having the same module identity (otherwise we will have duplicated code)
                        const aliasModuleEntry = await moduleRegistry.getModuleEntry(explodedSpecifier, runtimeParams);
                        aliasSpecifierUri = await moduleRegistry.resolveModuleUri(aliasModuleEntry, runtimeEnvironment, runtimeParams);
                    }
                    // eslint-disable-next-line no-await-in-loop
                    refModuleDef = await moduleRegistry.getLinkedModule({
                        specifier,
                        namespace: explodedSpecifier.namespace,
                        name: explodedSpecifier.name,
                        scope: hasAlias ? undefined : refImport.scope,
                        version: explodedSpecifier.version,
                    }, runtimeEnvironment, runtimeParams);
                    // This specifier is the final URI specifier
                    visitedDefs.set(specifierUri, refModuleDef);
                    // If there is an alias we need to point the alias URI to the same code
                    // The resolveId must have both URIs (original, and alias) pointing to the same def
                    if (hasAlias) {
                        visitedDefs.set(aliasSpecifierUri, refModuleDef);
                        visitedAliasUris.set(specifierUri, aliasSpecifierUri);
                    }
                }
            }
            return moduleDef.linkedSource;
        },
    };
}
//# sourceMappingURL=rollup-esm-bundler-plugin.js.map