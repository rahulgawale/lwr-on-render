import { AMD_DEFINE } from '@lwrjs/compiler';
import { GraphDepth, getModuleGraphs, getSpecifier } from '@lwrjs/shared-utils';
import { rollup } from 'rollup';
import { bundleDefinitions } from './rollup-amd-bundler-plugin.js';
async function bundle(id, moduleGraphs) {
    const bundler = await rollup({
        input: id,
        plugins: [
            bundleDefinitions({
                moduleGraphs,
            }),
        ],
    });
    const { output } = await bundler.generate({
        amd: { id, define: AMD_DEFINE },
        exports: 'named',
        format: 'amd',
    });
    return output[0].code;
}
export async function amdBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams = {}, { bundleConfig, amdLoader }, bundleConfigOverride) {
    const { exclude, external } = bundleConfigOverride ?? bundleConfig;
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const includedModules = [];
    const graphOptions = {
        includeLinkedDefinitions: true,
        depth: {
            static: GraphDepth.ALL,
            dynamic: 0,
            includeId: (moduleRef) => {
                // loader should be auto bundled with shim already
                if (exclude?.includes(moduleRef.specifier) || moduleRef.specifier === amdLoader) {
                    requiredImports.set(`${moduleId.specifier}_${moduleId.version}`, moduleRef);
                    return false;
                }
                return true;
            },
        },
    };
    const moduleGraphs = await getModuleGraphs(moduleId.specifier, graphOptions, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams);
    const rootModule = moduleGraphs.graphs[0];
    const modules = [rootModule.specifier, ...moduleGraphs.graphs[0].static];
    const bundles = await Promise.all(modules
        .reduce((filteredModules, specifier) => {
        const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
        // skip modules that do not have a linked definition
        if (!linkedDefinition) {
            return filteredModules;
        }
        // add any dynamic imports from each of the linked definitions in the module graph
        linkedDefinition.linkedModuleRecord.dynamicImports?.forEach((dynamicImport) => {
            if (dynamicImport.moduleNameType !== 'unresolved') {
                dynamicImports.set(`${dynamicImport.specifier}_${dynamicImport.version}`, dynamicImport);
            }
        });
        // skip relative dependencies
        if (specifier.includes('#')) {
            return filteredModules;
        }
        // prepend the linked definition for the correct order
        filteredModules.unshift(linkedDefinition);
        return filteredModules;
    }, [])
        .map((linkedDefinition) => {
        const id = getSpecifier(linkedDefinition);
        if (id !== rootModule.specifier) {
            includedModules.push(id);
        }
        // bundle all dependencies for the linked definition and convert to AMD
        return bundle(id, moduleGraphs);
    }));
    const { id, name, namespace, version, specifier } = moduleGraphs.linkedDefinitions[rootModule.specifier];
    return {
        id,
        name,
        namespace,
        version,
        specifier,
        code: bundles.join(''),
        config: { external, exclude },
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules,
        },
    };
}
//# sourceMappingURL=amd-bundler.js.map