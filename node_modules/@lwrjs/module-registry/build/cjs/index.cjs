var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/module-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrModuleRegistry: () => LwrModuleRegistry
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_linker = __toModule(require("./linker/linker.cjs"));
var import_module_record = __toModule(require("./module-record.cjs"));
var import_amd_strategy = __toModule(require("./linker/strategies/amd-strategy.cjs"));
var import_esm_strategy = __toModule(require("./linker/strategies/esm-strategy.cjs"));
var import_signature = __toModule(require("./signature.cjs"));
var LwrModuleRegistry = class {
  constructor(context, globalConfig, registries) {
    this.providers = [];
    this.moduleDefCache = new Map();
    this.moduleLinkedCache = new Map();
    this.inflightModuleDefinitions = new import_shared_utils.InflightTasks();
    this.name = "lwr-module-registry";
    this.context = context;
    this.globalConfig = globalConfig;
    this.emitter = context.appEmitter;
    if (registries) {
      this.providers = registries;
    }
    if (globalConfig.environment?.default) {
      this.interchangeableModules = (0, import_shared_utils.discoverInterchangeableModules)(globalConfig.lwc.modules, globalConfig.lwc.interchangeableModulesMap);
    }
    context.appObserver.onModuleSourceChange(async ({payload: moduleCompiled}) => {
      const id = moduleCompiled.id;
      if (!this.moduleDefCache.has(id)) {
        console.log("[WARNING] Unable to find match in moduleDefCache", {id});
      }
      this.moduleDefCache.delete(id);
      const linkedModules = this.moduleLinkedCache.get(id);
      if (linkedModules) {
        this.moduleLinkedCache.delete(id);
        for (const [cacheId, module2] of linkedModules) {
          linkedModules.delete(cacheId);
          const moduleDefinition = await this.getLinkedModule(moduleCompiled, module2.runtimeEnvironment, module2.runtimeParams);
          this.emitter.notifyModuleDefinitionChanged(moduleDefinition);
        }
      }
    });
  }
  resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature) {
    if (signature !== void 0) {
      const uri = (0, import_esm_strategy.default)(moduleId, runtimeEnvironment, runtimeParams, signature);
      return uri;
    }
    const {bundle, format} = runtimeEnvironment;
    if (bundle) {
      return new Promise((resolve, reject) => {
        (0, import_signature.getBundleSignature)(moduleId, this, this.globalConfig?.bundleConfig?.exclude).then((bundleSignature) => resolve((0, import_esm_strategy.default)(moduleId, runtimeEnvironment, runtimeParams, bundleSignature))).catch(reject);
      });
    } else {
      return new Promise((resolve, reject) => {
        this.getModule(moduleId, runtimeParams).then((moduleDef) => resolve((0, import_esm_strategy.default)(moduleId, runtimeEnvironment, runtimeParams, !bundle && format === "esm" ? import_shared_utils.LATEST_SIGNATURE : moduleDef.ownHash))).catch(reject);
      });
    }
  }
  addModuleProviders(registries) {
    this.providers.push(...registries);
  }
  getModuleEntry(moduleId, runtimeParams) {
    return this.delegateGetModuleEntryOnServices(moduleId, runtimeParams);
  }
  async getModule(moduleId, runtimeParams) {
    const moduleEntry = await this.getModuleEntry(moduleId, runtimeParams);
    const cacheDisabled = process.env.NOCACHE === "true";
    if (cacheDisabled === false && this.moduleDefCache.has(moduleEntry.id)) {
      return this.moduleDefCache.get(moduleEntry.id);
    }
    return this.inflightModuleDefinitions.execute(moduleEntry.id, async () => {
      const moduleDef = await this.createModuleDefinition(moduleId, runtimeParams);
      if (cacheDisabled === false) {
        this.moduleDefCache.set(moduleDef.id, moduleDef);
      }
      return moduleDef;
    });
  }
  async createModuleDefinition(moduleId, runtimeParams) {
    const {locker} = this.globalConfig;
    const moduleCompiled = await this.delegateGetModuleOnProviders(moduleId, runtimeParams);
    if (locker.enabled && !locker.clientOnly) {
      const {runtimeEnvironment} = this.context;
      const {minify, sourceMapUrl} = runtimeEnvironment;
      const sourcemap = typeof sourceMapUrl === "string" || !minify;
      const {code: lockerizedCode} = this.context.compiler.lockerize(moduleCompiled, locker, sourcemap);
      moduleCompiled.compiledSource = lockerizedCode;
    }
    const moduleRecord = await (0, import_module_record.getModuleRecord)(moduleCompiled, this, this.context.compiler);
    return {...moduleCompiled, moduleRecord};
  }
  async getLinkedModule(moduleId, runtimeEnvironment, runtimeParams) {
    const moduleEntry = await this.getModuleEntry(moduleId, runtimeParams);
    const id = moduleEntry.id;
    const {
      format,
      compat,
      debug,
      minify,
      bundle,
      env: {NODE_ENV: envMode}
    } = runtimeEnvironment;
    const locale = runtimeParams?.["locale"];
    const environment = runtimeParams?.["environment"];
    const {
      locker: {enabled: lockerEnabled}
    } = this.globalConfig;
    const cacheDisabled = process.env.NOCACHE === "true";
    if (cacheDisabled === false && this.moduleLinkedCache.has(id)) {
      const moduleLinks = this.moduleLinkedCache.get(id);
      const runtimeEnvKey = (0, import_shared_utils.getCacheKeyFromJson)({
        format,
        compat,
        debug,
        minify,
        bundle,
        lockerEnabled,
        locale,
        environment
      });
      const moduleLinked2 = moduleLinks.get(runtimeEnvKey);
      if (moduleLinked2) {
        return moduleLinked2;
      }
    }
    const moduleDef = await this.getModule(moduleId, runtimeParams);
    const moduleLinked = await this.createLinkedModuleDefinition(moduleDef, runtimeEnvironment, runtimeParams);
    if (format === "amd" && !bundle) {
      moduleLinked.linkedSource = (await this.context.compiler.convertToAmd(moduleLinked.linkedSource, {
        id: moduleLinked.id
      })).code;
    }
    const minified = !!minify && !debug;
    if (minified && !bundle) {
      moduleLinked.linkedSource = (await this.context.compiler.minifyJavascript(moduleLinked.linkedSource)).code;
      moduleLinked.linkedConfig.minified = true;
    } else {
      moduleLinked.linkedSource = (await this.context.compiler.parseJavascript(moduleLinked.linkedSource, {envMode})).code;
    }
    if (cacheDisabled === false) {
      const linkedMap = this.moduleLinkedCache.get(id) || new Map();
      linkedMap.set((0, import_shared_utils.getCacheKeyFromJson)({
        format,
        compat,
        debug,
        minify,
        bundle,
        lockerEnabled,
        locale,
        environment
      }), moduleLinked);
      this.moduleLinkedCache.set(id, linkedMap);
    }
    return moduleLinked;
  }
  async createLinkedModuleDefinition(moduleDef, runtimeEnvironment, runtimeParams) {
    const {format} = runtimeEnvironment;
    const {amdLoader, esmLoader} = this.globalConfig;
    if (format === "amd") {
      const loaderModuleEntry = await this.getModuleEntry({specifier: amdLoader}, runtimeParams);
      const {
        id,
        code: linkedSource,
        linkedModuleRecord
      } = await (0, import_linker.link)(this, moduleDef, import_amd_strategy.default, import_esm_strategy.default, runtimeEnvironment, runtimeParams, {
        amdLoaderModule: loaderModuleEntry
      }, this.interchangeableModules);
      linkedModuleRecord.dynamicImports = linkedModuleRecord.dynamicImports?.filter((imp) => imp.moduleNameType !== import_shared_utils.ModuleNameType.unresolved);
      return {
        ...moduleDef,
        id,
        linkedSource,
        linkedConfig: {
          minified: false
        },
        linkedModuleRecord,
        runtimeEnvironment
      };
    } else {
      let loaderModuleEntry;
      const dynamicImports = moduleDef.moduleRecord.dynamicImports;
      if (moduleDef.moduleEntry.specifier !== esmLoader && dynamicImports) {
        loaderModuleEntry = await this.getModuleEntry({specifier: esmLoader}, runtimeParams);
      }
      const {
        id,
        code: linkedSource,
        linkedModuleRecord
      } = await (0, import_linker.link)(this, moduleDef, import_amd_strategy.default, import_esm_strategy.default, runtimeEnvironment, runtimeParams, loaderModuleEntry && {
        esmLoaderModule: loaderModuleEntry
      }, this.interchangeableModules, this.globalConfig.bundleConfig?.exclude);
      linkedModuleRecord.dynamicImports = linkedModuleRecord.dynamicImports?.filter((imp) => imp.moduleNameType !== import_shared_utils.ModuleNameType.unresolved);
      return {
        ...moduleDef,
        id,
        linkedSource,
        linkedConfig: {
          minified: false
        },
        linkedModuleRecord,
        runtimeEnvironment,
        runtimeParams
      };
    }
  }
  async delegateGetModuleEntryOnServices(moduleId, runtimeParams) {
    for (const registry of this.providers) {
      const result = await registry.getModuleEntry(moduleId, runtimeParams);
      if (result) {
        return result;
      }
    }
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.MODULE_ENTRY(moduleId.specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  async delegateGetModuleOnProviders(moduleId, runtimeParams) {
    for (const registry of this.providers) {
      const result = await registry.getModule(moduleId, runtimeParams);
      if (result) {
        return result;
      }
    }
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.MODULE(moduleId.specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  getPublicApi() {
    return {
      getModuleEntry: this.getModuleEntry.bind(this),
      getModule: this.getModule.bind(this),
      resolveModuleUri: this.resolveModuleUri.bind(this)
    };
  }
};
