import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { discoverInterchangeableModules, getCacheKeyFromJson, InflightTasks, LATEST_SIGNATURE, ModuleNameType, } from '@lwrjs/shared-utils';
import { link } from './linker/linker.js';
import { getModuleRecord } from './module-record.js';
import amdLinkingStrategy from './linker/strategies/amd-strategy.js';
import esmLinkingStrategy from './linker/strategies/esm-strategy.js';
import { getBundleSignature } from './signature.js';
export class LwrModuleRegistry {
    constructor(context, globalConfig, registries) {
        this.providers = [];
        this.moduleDefCache = new Map();
        this.moduleLinkedCache = new Map();
        this.inflightModuleDefinitions = new InflightTasks();
        this.name = 'lwr-module-registry';
        this.context = context;
        this.globalConfig = globalConfig;
        this.emitter = context.appEmitter;
        if (registries) {
            this.providers = registries;
        }
        if (globalConfig.environment?.default) {
            this.interchangeableModules = discoverInterchangeableModules(globalConfig.lwc.modules, globalConfig.lwc.interchangeableModulesMap);
        }
        context.appObserver.onModuleSourceChange(async ({ payload: moduleCompiled }) => {
            const id = moduleCompiled.id;
            if (!this.moduleDefCache.has(id)) {
                console.log('[WARNING] Unable to find match in moduleDefCache', { id });
            }
            this.moduleDefCache.delete(id);
            const linkedModules = this.moduleLinkedCache.get(id);
            if (linkedModules) {
                // refresh the module in the linkedCache
                this.moduleLinkedCache.delete(id);
                for (const [cacheId, module] of linkedModules) {
                    linkedModules.delete(cacheId);
                    // eslint-disable-next-line no-await-in-loop
                    const moduleDefinition = await this.getLinkedModule(moduleCompiled, module.runtimeEnvironment, module.runtimeParams);
                    // emit changes for each module definition already cached
                    this.emitter.notifyModuleDefinitionChanged(moduleDefinition);
                }
            }
        });
    }
    resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature) {
        if (signature !== undefined) {
            const uri = esmLinkingStrategy(moduleId, runtimeEnvironment, runtimeParams, signature);
            return uri;
        }
        const { bundle, format } = runtimeEnvironment;
        if (bundle) {
            return new Promise((resolve, reject) => {
                getBundleSignature(moduleId, this, this.globalConfig?.bundleConfig?.exclude)
                    .then((bundleSignature) => resolve(esmLinkingStrategy(moduleId, runtimeEnvironment, runtimeParams, bundleSignature)))
                    .catch(reject);
            });
            // For individual files we a module URL
        }
        else {
            return new Promise((resolve, reject) => {
                this.getModule(moduleId, runtimeParams)
                    .then((moduleDef) => resolve(esmLinkingStrategy(moduleId, runtimeEnvironment, runtimeParams, 
                // Simple rule for determining usage of LATEST v. fingerprinted URI.
                !bundle && format === 'esm' ? LATEST_SIGNATURE : moduleDef.ownHash)))
                    .catch(reject);
            });
        }
    }
    // -- Public API --------------------------------------------------------------------
    addModuleProviders(registries) {
        this.providers.push(...registries);
    }
    getModuleEntry(moduleId, runtimeParams) {
        return this.delegateGetModuleEntryOnServices(moduleId, runtimeParams);
    }
    async getModule(moduleId, runtimeParams) {
        const moduleEntry = await this.getModuleEntry(moduleId, runtimeParams);
        const cacheDisabled = process.env.NOCACHE === 'true';
        if (cacheDisabled === false && this.moduleDefCache.has(moduleEntry.id)) {
            // TODO add to profiling
            // console.log('[INFO] Module Cache Hit: %s', moduleEntry.id);
            return this.moduleDefCache.get(moduleEntry.id);
        }
        return this.inflightModuleDefinitions.execute(moduleEntry.id, async () => {
            const moduleDef = await this.createModuleDefinition(moduleId, runtimeParams);
            if (cacheDisabled === false) {
                this.moduleDefCache.set(moduleDef.id, moduleDef);
            }
            return moduleDef;
        });
    }
    async createModuleDefinition(moduleId, runtimeParams) {
        const { locker } = this.globalConfig;
        const moduleCompiled = await this.delegateGetModuleOnProviders(moduleId, runtimeParams); // provider source + hash
        /** Locker before collecting dep module records so locker imports are processed normally */
        if (locker.enabled && !locker.clientOnly) {
            const { runtimeEnvironment } = this.context;
            // Locker should generate inline source maps in non-minified modes
            // in addition to being explicitly enabled.
            const { minify, sourceMapUrl } = runtimeEnvironment;
            const sourcemap = typeof sourceMapUrl === 'string' || !minify;
            const { code: lockerizedCode } = this.context.compiler.lockerize(moduleCompiled, locker, sourcemap);
            moduleCompiled.compiledSource = lockerizedCode;
        }
        const moduleRecord = await getModuleRecord(moduleCompiled, this, this.context.compiler);
        return { ...moduleCompiled, moduleRecord };
    }
    async getLinkedModule(moduleId, runtimeEnvironment, runtimeParams) {
        const moduleEntry = await this.getModuleEntry(moduleId, runtimeParams);
        const id = moduleEntry.id;
        // cache key pivots from the runtimeEnvironment
        const { format, compat, debug, minify, bundle, env: { NODE_ENV: envMode }, } = runtimeEnvironment;
        const locale = runtimeParams?.['locale'];
        const environment = runtimeParams?.['environment'];
        const { locker: { enabled: lockerEnabled }, } = this.globalConfig;
        const cacheDisabled = process.env.NOCACHE === 'true';
        if (cacheDisabled === false && this.moduleLinkedCache.has(id)) {
            const moduleLinks = this.moduleLinkedCache.get(id);
            const runtimeEnvKey = getCacheKeyFromJson({
                format,
                compat,
                debug,
                minify,
                bundle,
                lockerEnabled,
                locale,
                environment,
            });
            const moduleLinked = moduleLinks.get(runtimeEnvKey);
            if (moduleLinked) {
                return moduleLinked;
            }
        }
        const moduleDef = await this.getModule(moduleId, runtimeParams);
        const moduleLinked = await this.createLinkedModuleDefinition(moduleDef, runtimeEnvironment, runtimeParams);
        // the bundler will convert the linked source to AMD when bundling is enabled
        if (format === 'amd' && !bundle) {
            // convert the linkedSource to the transport AMD format
            moduleLinked.linkedSource = (await this.context.compiler.convertToAmd(moduleLinked.linkedSource, {
                id: moduleLinked.id,
            })).code;
        }
        const minified = !!minify && !debug;
        // the bundler will minify when bundling is enabled
        if (minified && !bundle) {
            moduleLinked.linkedSource = (await this.context.compiler.minifyJavascript(moduleLinked.linkedSource)).code;
            moduleLinked.linkedConfig.minified = true;
        }
        else {
            moduleLinked.linkedSource = (await this.context.compiler.parseJavascript(moduleLinked.linkedSource, { envMode })).code;
        }
        // Add to cache
        if (cacheDisabled === false) {
            const linkedMap = this.moduleLinkedCache.get(id) || new Map();
            linkedMap.set(getCacheKeyFromJson({
                format,
                compat,
                debug,
                minify,
                bundle,
                lockerEnabled,
                locale,
                environment,
            }), moduleLinked);
            this.moduleLinkedCache.set(id, linkedMap);
        }
        return moduleLinked;
    }
    async createLinkedModuleDefinition(moduleDef, runtimeEnvironment, runtimeParams) {
        const { format } = runtimeEnvironment;
        const { amdLoader, esmLoader } = this.globalConfig;
        // TODO: compat transformation based on runtimeEnvironment.compat
        if (format === 'amd') {
            // Resolve the loader entry
            const loaderModuleEntry = await this.getModuleEntry({ specifier: amdLoader }, runtimeParams);
            // transforms compiledModule into linkedModule (which means the imports may have changed)
            const { id, code: linkedSource, linkedModuleRecord, } = await link(this, moduleDef, amdLinkingStrategy, esmLinkingStrategy, runtimeEnvironment, runtimeParams, {
                amdLoaderModule: loaderModuleEntry,
            }, this.interchangeableModules);
            // Filter out variable dynamic imports
            linkedModuleRecord.dynamicImports = linkedModuleRecord.dynamicImports?.filter((imp) => imp.moduleNameType !== ModuleNameType.unresolved);
            return {
                ...moduleDef,
                id,
                linkedSource,
                linkedConfig: {
                    minified: false,
                },
                linkedModuleRecord,
                runtimeEnvironment,
            };
        }
        else {
            // resolve the loader entry if there are VARIABLE dynamic imports
            let loaderModuleEntry;
            const dynamicImports = moduleDef.moduleRecord.dynamicImports;
            if (moduleDef.moduleEntry.specifier !== esmLoader && dynamicImports) {
                // ONLY include the ESM loader if there are dynamic imports
                // AND this is not the ESM loader itself (it uses a variable dynamic import we DO NOT want to link)
                loaderModuleEntry = await this.getModuleEntry({ specifier: esmLoader }, runtimeParams);
            }
            const { id, code: linkedSource, linkedModuleRecord, } = await link(this, moduleDef, amdLinkingStrategy, esmLinkingStrategy, runtimeEnvironment, runtimeParams, loaderModuleEntry && {
                esmLoaderModule: loaderModuleEntry,
            }, this.interchangeableModules, this.globalConfig.bundleConfig?.exclude);
            // Filter out variable dynamic imports
            linkedModuleRecord.dynamicImports = linkedModuleRecord.dynamicImports?.filter((imp) => imp.moduleNameType !== ModuleNameType.unresolved);
            return {
                ...moduleDef,
                id,
                linkedSource,
                linkedConfig: {
                    minified: false,
                },
                linkedModuleRecord,
                runtimeEnvironment,
                runtimeParams,
            };
        }
    }
    // -- Service delegation ----------------------------------------------
    async delegateGetModuleEntryOnServices(moduleId, runtimeParams) {
        for (const registry of this.providers) {
            // eslint-disable-next-line no-await-in-loop
            const result = await registry.getModuleEntry(moduleId, runtimeParams);
            if (result) {
                return result;
            }
        }
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.MODULE_ENTRY(moduleId.specifier),
        }, LwrUnresolvableError);
    }
    async delegateGetModuleOnProviders(moduleId, runtimeParams) {
        for (const registry of this.providers) {
            // eslint-disable-next-line no-await-in-loop
            const result = await registry.getModule(moduleId, runtimeParams);
            if (result) {
                return result;
            }
        }
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.MODULE(moduleId.specifier),
        }, LwrUnresolvableError);
    }
    getPublicApi() {
        return {
            getModuleEntry: this.getModuleEntry.bind(this),
            getModule: this.getModule.bind(this),
            resolveModuleUri: this.resolveModuleUri.bind(this),
        };
    }
}
//# sourceMappingURL=index.js.map