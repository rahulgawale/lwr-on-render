import crypto from 'crypto';
import path from 'path';
import { cwd } from 'process';
import { createRequire } from 'module';
import { getFeatureFlags, getSpecifier, logger } from '@lwrjs/shared-utils';
const LWC_VERSION = getLWCVersion();
const ENABLED_FINGERPRINTS = !getFeatureFlags().LEGACY_LOADER;
const ENV_KEY = `LWC:${LWC_VERSION},FINGERPRINTS:${ENABLED_FINGERPRINTS}`;
async function getRecursiveModuleHash(modules, registry, hash, visitedDefinitions = new Set()) {
    if (!modules.length) {
        return;
    }
    const definitions = await Promise.all(modules.map((module) => registry.getModule(module)));
    const imports = new Map();
    for (const definition of definitions) {
        const { ownHash, moduleRecord } = definition;
        // include module in the bundle signature
        hash.update(ownHash);
        // track the module to ensure it is only processed once
        visitedDefinitions.add(getSpecifier(definition));
        // map imports to prevent processing duplicates
        moduleRecord.imports?.forEach((importReference) => {
            imports.set(getSpecifier(importReference), importReference);
        });
    }
    // filter out bundle config exclusions and already visited dependencies
    const dependencies = Array.from(imports, ([_, dependency]) => dependency).filter((dependency) => 
    // exclusions are not versioned
    !visitedDefinitions.has(dependency.specifier) &&
        // already visited dependencies will be versioned
        !visitedDefinitions.has(getSpecifier(dependency)));
    if (dependencies.length) {
        return getRecursiveModuleHash(dependencies, registry, hash, visitedDefinitions);
    }
}
/**
 * Generate a bundle signature
 *
 * Traverses the module graph from the specified root module to generate a
 *  signature. Modules that are marked for exclusion will be skipped. The
 *  bundle signature will be generated based on the environment
 *  keys(i.e. LWC version) and the ownHash of each module in the graph.
 *
 * @param moduleId - root module id
 * @param registry - module registry
 * @param exclude - bundle config exclusions
 * @returns a bungle signature
 */
export async function getBundleSignature(moduleId, registry, exclude) {
    const hash = crypto.createHash('sha1');
    hash.update(ENV_KEY);
    // add bundle config exclusions to visited definitions to prevent including
    //  them in the bundle signature
    // Note: if the root module is an excluded module, it will be included in
    //  the signature
    await getRecursiveModuleHash([moduleId], registry, hash, new Set(exclude));
    return hash.digest('hex');
}
/**
 * Get the configured LWC version
 */
function getLWCVersion() {
    let lwcVersion;
    try {
        // check if it is set on the global shim
        if (LWR?.LWC_VERSION) {
            lwcVersion = LWR.LWC_VERSION;
        }
    }
    catch (err) {
        // No-op throws an error in cli when LWR versison not set in global
    }
    if (!lwcVersion) {
        const require = createRequire(path.join(cwd(), './env-config.js'));
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { version } = require('lwc/package.json');
        lwcVersion = version;
    }
    logger.debug(`Signature LWC Version: ${lwcVersion}`);
    return lwcVersion;
}
//# sourceMappingURL=signature.js.map