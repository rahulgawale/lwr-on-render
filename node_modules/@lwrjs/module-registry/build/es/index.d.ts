import { ModuleProvider, LinkedModuleDefinition, LwrAppObserver, Compiler, RuntimeEnvironment, LwrAppEmitter, ModuleRegistry, ModuleEntry, PublicModuleRegistry, NormalizedLwrGlobalConfig, ModuleDefinition, AbstractModuleId, ModuleId, RuntimeParams } from '@lwrjs/types';
interface RegistryContext {
    appObserver: LwrAppObserver;
    appEmitter: LwrAppEmitter;
    compiler: Compiler;
    runtimeEnvironment: RuntimeEnvironment;
}
export declare class LwrModuleRegistry implements ModuleRegistry {
    name: string;
    providers: ModuleProvider[];
    moduleDefCache: Map<string, ModuleDefinition>;
    moduleLinkedCache: Map<string, Map<string, LinkedModuleDefinition>>;
    context: RegistryContext;
    emitter: LwrAppEmitter;
    globalConfig: NormalizedLwrGlobalConfig;
    private interchangeableModules?;
    private inflightModuleDefinitions;
    constructor(context: RegistryContext, globalConfig: NormalizedLwrGlobalConfig, registries?: ModuleProvider[]);
    resolveModuleUri<R extends RuntimeEnvironment, S extends string | undefined>(moduleId: Required<Pick<ModuleId, 'specifier' | 'version'>>, runtimeEnvironment: R, runtimeParams?: RuntimeParams, signature?: S): S extends string ? string : Promise<string>;
    addModuleProviders(registries: ModuleProvider[]): void;
    getModuleEntry<T extends AbstractModuleId>(moduleId: T, runtimeParams?: RuntimeParams): Promise<ModuleEntry>;
    getModule<T extends AbstractModuleId>(moduleId: T, runtimeParams?: RuntimeParams): Promise<ModuleDefinition>;
    private createModuleDefinition;
    getLinkedModule<T extends AbstractModuleId>(moduleId: T, runtimeEnvironment: RuntimeEnvironment, runtimeParams?: RuntimeParams): Promise<LinkedModuleDefinition>;
    private createLinkedModuleDefinition;
    private delegateGetModuleEntryOnServices;
    private delegateGetModuleOnProviders;
    getPublicApi(): PublicModuleRegistry;
}
export {};
//# sourceMappingURL=index.d.ts.map