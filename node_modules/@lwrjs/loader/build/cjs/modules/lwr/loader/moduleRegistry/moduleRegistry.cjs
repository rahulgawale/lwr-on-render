var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/loader/src/modules/lwr/loader/moduleRegistry/moduleRegistry.ts
__markAsModule(exports);
__export(exports, {
  ModuleRegistry: () => ModuleRegistry
});
var import_messages = __toModule(require("../errors/messages"));
var import_url = __toModule(require("../utils/url"));
var import_dom = __toModule(require("../utils/dom"));
var import_scriptLoad = __toModule(require("./scriptLoad"));
var import_importMetadataResolver = __toModule(require("./importMetadataResolver"));
var import_moduleInvalidation = __toModule(require("../hooks/moduleInvalidation"));
var import_resolveAndLoadHook = __toModule(require("../hooks/resolveAndLoadHook"));
var import_metrics = __toModule(require("lwr/metrics"));
var import_constants = __toModule(require("../constants/constants"));
var ModuleRegistry = class {
  constructor(config) {
    this.namedDefineRegistry = new Map();
    this.moduleRegistry = new Map();
    this.aliases = new Map();
    this.profiler = config.profiler;
    this.resolver = new import_importMetadataResolver.ImportMetadataResolver(config, this.importMetadataInvalidationCallback.bind(this));
  }
  async load(id, importer) {
    const resolvedId = await this.resolve(id, importer);
    const moduleRecord = this.getModuleRecord(resolvedId, id);
    if (moduleRecord.evaluated) {
      return moduleRecord.module;
    } else {
      if (!moduleRecord.evaluationPromise) {
        moduleRecord.evaluationPromise = this.topLevelEvaluation(moduleRecord);
      }
      return moduleRecord.evaluationPromise;
    }
  }
  async resolve(id, importer) {
    const parentUrl = this.resolver.getBaseUrl();
    let resolved;
    let aliasedId = id;
    const resolveHooks = this.resolveHook;
    if (resolveHooks) {
      for (let i = 0; i < resolveHooks.length; i++) {
        const resolveHook = resolveHooks[i];
        const response = resolveHook(aliasedId, {parentUrl});
        let result;
        if (response || response === null) {
          result = (0, import_resolveAndLoadHook.isResponseAPromise)(response) ? await response : response;
        }
        if (result !== null) {
          if (typeof result === "string") {
            if ((0, import_url.resolveIfNotPlainOrUrl)(result, parentUrl)) {
              throw new import_messages.LoaderError(import_messages.INVALID_LOADER_SERVICE_RESPONSE);
            }
            aliasedId = result;
            continue;
          }
          resolved = result && result.url && ((0, import_url.resolveIfNotPlainOrUrl)(result.url, parentUrl) || result.url);
          if (!resolved) {
            throw new import_messages.LoaderError(import_messages.INVALID_LOADER_SERVICE_RESPONSE);
          }
          break;
        }
      }
      if (aliasedId !== id) {
        if (!resolved && this.namedDefineRegistry.has(aliasedId)) {
          return aliasedId;
        } else {
          id = aliasedId;
        }
      }
    }
    if (!resolved) {
      const resolvedOrPlain = (0, import_url.resolveIfNotPlainOrUrl)(id, parentUrl) || id;
      if (this.moduleRegistry.has(resolvedOrPlain)) {
        return resolvedOrPlain;
      }
      const resolvedUrl = this.resolver.resolveLocal(resolvedOrPlain);
      if (resolvedUrl) {
        if (this.namedDefineRegistry.has(resolvedOrPlain) && this.namedDefineRegistry.get(resolvedOrPlain).defined) {
          const record = this.moduleRegistry.get(resolvedUrl);
          if (!record || !this.aliases.has(resolvedOrPlain)) {
            return resolvedOrPlain;
          }
        }
        return resolvedUrl;
      }
      if (this.namedDefineRegistry.has(resolvedOrPlain)) {
        return resolvedOrPlain;
      }
      try {
        resolved = await this.resolver.resolve(resolvedOrPlain);
      } catch (e) {
      }
    }
    if (!resolved || !(0, import_url.isUrl)(resolved)) {
      if (this.namedDefineRegistry.has(id)) {
        return id;
      }
      throw new import_messages.LoaderError(import_messages.UNRESOLVED, [id]);
    }
    if (importer && (0, import_url.isUrl)(resolved)) {
      resolved += `?importer=${encodeURIComponent(importer)}`;
    }
    return resolved;
  }
  has(id) {
    return this.moduleRegistry.has(id);
  }
  define(name, dependencies, exporter) {
    const mod = this.namedDefineRegistry.get(name);
    if (mod && mod.defined) {
      if (process.env.NODE_ENV !== "production" && import_dom.hasConsole) {
        console.warn(`Module redefine attempted: ${name}`);
      }
      this.lastDefine = mod;
      return;
    }
    const moduleDef = {
      name,
      dependencies,
      exporter,
      defined: true
    };
    if (mod && mod.external) {
      mod.external.resolveExternal(moduleDef);
    }
    this.profiler.logOperationStart({id: import_metrics.MODULE_DEFINE, specifier: name});
    this.namedDefineRegistry.set(name, moduleDef);
    this.lastDefine = moduleDef;
  }
  registerExternalModules(modules) {
    const alreadyRegistered = [];
    modules.map((id) => {
      if (this.namedDefineRegistry.has(id)) {
        alreadyRegistered.push(id);
      } else {
        let resolveExternal;
        let timer;
        const moduleDefPromise = new Promise((resolve, reject) => {
          resolveExternal = resolve;
          timer = setTimeout(() => {
            reject(new import_messages.LoaderError(import_messages.MODULE_LOAD_TIMEOUT, [id]));
          }, import_constants.MODULE_LOAD_TIMEOUT_TIMER);
        }).finally(() => {
          clearTimeout(timer);
        });
        const moduleDef = {
          name: id,
          defined: false,
          external: {
            resolveExternal,
            moduleDefPromise
          }
        };
        this.namedDefineRegistry.set(id, moduleDef);
      }
    });
    if (alreadyRegistered.length) {
      throw new import_messages.LoaderError(import_messages.MODULE_ALREADY_LOADED, [alreadyRegistered.join(", ")]);
    }
  }
  getImportMetadataResolver() {
    return this.resolver;
  }
  getExistingModuleRecord(resolvedId, aliasId) {
    const moduleRecord = this.moduleRegistry.get(resolvedId);
    if (moduleRecord) {
      this.storeModuleAlias(aliasId, resolvedId);
      return moduleRecord;
    }
    if (resolvedId !== aliasId) {
      const alias = this.aliases.get(aliasId);
      if (alias) {
        const aliasedModule = this.moduleRegistry.get(alias);
        if (aliasedModule) {
          return aliasedModule;
        }
      }
    }
    return moduleRecord;
  }
  getModuleRecord(resolvedId, id) {
    const existingRecord = this.getExistingModuleRecord(resolvedId, id);
    if (existingRecord) {
      return existingRecord;
    }
    const instantiation = this.getModuleDef(resolvedId, id);
    const dependencyRecords = instantiation.then((moduleDef) => {
      const dependencies = moduleDef.dependencies;
      const filtered = dependencies.map((dep) => {
        if (dep === "exports") {
          return;
        }
        (0, import_messages.invariant)(dep !== "require", import_messages.NO_AMD_REQUIRE);
        return this.getModuleDependencyRecord.call(this, dep);
      }).filter((depRecord) => depRecord !== void 0);
      return Promise.all(filtered);
    });
    const newModuleRecord = {
      id: resolvedId,
      module: Object.create(null),
      dependencyRecords,
      instantiation,
      evaluated: false,
      evaluationPromise: null
    };
    this.moduleRegistry.set(resolvedId, newModuleRecord);
    this.storeModuleAlias(id, resolvedId);
    return newModuleRecord;
  }
  storeModuleAlias(aliasId, resolvedId) {
    if (aliasId !== resolvedId) {
      if (!this.aliases.has(aliasId)) {
        this.aliases.set(aliasId, resolvedId);
      } else if (import_dom.hasConsole) {
        const currentResolvedId = this.aliases.get(aliasId);
        if (currentResolvedId !== resolvedId) {
          console.warn(`Alias update attempt: ${aliasId}=>${currentResolvedId}, ${resolvedId}`);
        }
      }
    }
  }
  async getModuleDependencyRecord(dependency) {
    const resolvedDepId = await this.resolve(dependency);
    return this.getModuleRecord(resolvedDepId, dependency);
  }
  async topLevelEvaluation(moduleRecord) {
    await this.instantiateAll(moduleRecord, {});
    return this.evaluateModule(moduleRecord, {});
  }
  async instantiateAll(moduleRecord, instantiatedMap) {
    if (!instantiatedMap[moduleRecord.id]) {
      instantiatedMap[moduleRecord.id] = true;
      const dependencyModuleRecords = await moduleRecord.dependencyRecords;
      if (dependencyModuleRecords) {
        for (let i = 0; i < dependencyModuleRecords.length; i++) {
          const depRecord = dependencyModuleRecords[i];
          await this.instantiateAll(depRecord, instantiatedMap);
        }
      }
    }
  }
  async evaluateModule(moduleRecord, evaluationMap) {
    const dependencyModuleRecords = await moduleRecord.dependencyRecords;
    if (dependencyModuleRecords.length > 0) {
      evaluationMap[moduleRecord.id] = true;
      await this.evaluateModuleDependencies(dependencyModuleRecords, evaluationMap);
    }
    const {exporter, dependencies} = await moduleRecord.instantiation;
    const exports2 = {};
    const depsMapped = await Promise.all(dependencies.map(async (dep) => {
      if (dep === "exports") {
        return exports2;
      }
      const resolvedDepId = await this.resolve(dep);
      const moduleRecord2 = this.moduleRegistry.get(resolvedDepId);
      if (!moduleRecord2) {
        throw new import_messages.LoaderError(import_messages.FAILED_DEP, [resolvedDepId]);
      }
      const module2 = moduleRecord2.module;
      if (!moduleRecord2.evaluated) {
        return this.getCircularDependencyWrapper(module2);
      }
      if (module2) {
        return module2.__defaultInterop ? module2.default : module2;
      }
      throw new import_messages.LoaderError(import_messages.FAILED_DEP, [resolvedDepId]);
    }));
    if (moduleRecord.evaluated) {
      return moduleRecord.module;
    }
    let moduleDefault = exporter(...depsMapped);
    if (moduleDefault !== void 0) {
      moduleDefault = {default: moduleDefault};
      Object.defineProperty(moduleDefault, "__defaultInterop", {value: true});
    } else {
      if (this.isNamedExportDefaultOnly(exports2)) {
        Object.defineProperty(exports2, "__useDefault", {value: true});
      }
    }
    const moduleExports = moduleDefault || exports2;
    for (const key in moduleExports) {
      Object.defineProperty(moduleRecord.module, key, {
        enumerable: true,
        set(value) {
          moduleExports[key] = value;
        },
        get() {
          return moduleExports[key];
        }
      });
    }
    if (moduleExports.__useDefault) {
      Object.defineProperty(moduleRecord.module, "__useDefault", {value: true});
    }
    if (moduleExports.__defaultInterop) {
      Object.defineProperty(moduleRecord.module, "__defaultInterop", {value: true});
    }
    if (moduleExports.__esModule) {
      Object.defineProperty(moduleRecord.module, "__esModule", {value: true});
    }
    moduleRecord.evaluated = true;
    Object.freeze(moduleRecord.module);
    return moduleRecord.module;
  }
  isNamedExportDefaultOnly(exports2) {
    return exports2 !== void 0 && Object.getOwnPropertyNames(exports2).length === 2 && Object.prototype.hasOwnProperty.call(exports2, "default") && Object.prototype.hasOwnProperty.call(exports2, "__esModule");
  }
  getCircularDependencyWrapper(module2) {
    const tmp = () => {
      return module2.__useDefault || module2.__defaultInterop ? module2.default : module2;
    };
    tmp.__circular__ = true;
    return tmp;
  }
  async evaluateModuleDependencies(dependencyModuleRecords, evaluationMap) {
    for (let i = 0; i < dependencyModuleRecords.length; i++) {
      const depRecord = dependencyModuleRecords[i];
      if (!depRecord.evaluated && !evaluationMap[depRecord.id]) {
        evaluationMap[depRecord.id] = true;
        await this.evaluateModule(depRecord, evaluationMap);
      }
    }
  }
  async getModuleDef(resolvedId, originalId) {
    this.lastDefine = void 0;
    const moduleName = !(0, import_url.isUrl)(resolvedId) ? resolvedId : originalId !== resolvedId ? originalId : void 0;
    let moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
    if (moduleDef && moduleDef.external) {
      return moduleDef.external.moduleDefPromise;
    }
    if (moduleDef && moduleDef.defined) {
      return moduleDef;
    }
    const parentUrl = this.resolver.getBaseUrl();
    const specifier = moduleName || originalId;
    this.profiler.logOperationStart({id: import_metrics.MODULE_FETCH, specifier});
    return Promise.resolve().then(async () => {
      const loadHooks = this.loadHook;
      if (loadHooks) {
        for (let i = 0; i < loadHooks.length; i++) {
          const loadHook = loadHooks[i];
          const response = loadHook(resolvedId, parentUrl);
          const result = (0, import_resolveAndLoadHook.isResponseAPromise)(response) ? await (0, import_resolveAndLoadHook.evaluateLoadHook)(resolvedId, response) : response;
          if (result === void 0) {
            throw new import_messages.LoaderError(import_messages.INVALID_LOADER_SERVICE_RESPONSE);
          }
          if (result && result !== null) {
            return (0, import_resolveAndLoadHook.evaluateLoadHookResponse)(result, resolvedId);
          }
        }
      }
      return false;
    }).then((result) => {
      if (result !== true && import_dom.hasDocument) {
        return (0, import_scriptLoad.loadModuleDef)(resolvedId);
      }
    }).then(() => {
      moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
      if (!moduleDef) {
        moduleDef = this.lastDefine;
      }
      if (!moduleDef) {
        throw new import_messages.LoaderError(import_messages.FAIL_INSTANTIATE, [resolvedId]);
      }
      this.profiler.logOperationEnd({id: import_metrics.MODULE_FETCH, specifier});
      return moduleDef;
    }).catch((e) => {
      this.profiler.logOperationStart({id: import_metrics.MODULE_ERROR, specifier});
      throw e;
    });
  }
  addLoaderPlugin(hooks) {
    if (typeof hooks !== "object") {
      throw new import_messages.LoaderError(import_messages.INVALID_HOOK);
    }
    const {loadModule: loadHook, resolveModule: resolveHook, loadMapping} = hooks;
    if (resolveHook) {
      if (this.resolveHook) {
        this.resolveHook.push(resolveHook);
      } else {
        this.resolveHook = [resolveHook];
      }
    }
    if (loadHook) {
      if (this.loadHook) {
        this.loadHook.push(loadHook);
      } else {
        this.loadHook = [loadHook];
      }
    }
    if (loadMapping) {
      this.resolver.addLoadMappingHook(loadMapping);
    }
  }
  importMetadataInvalidationCallback({name, oldUrl, newUrl}) {
    const handleStaleModuleHooks = this.handleStaleModuleHook;
    if (handleStaleModuleHooks) {
      (0, import_moduleInvalidation.evaluateHandleStaleModuleHooks)(handleStaleModuleHooks, {
        name,
        oldUrl,
        newUrl
      });
    } else {
      if (import_dom.hasConsole) {
        console.warn(`stale module detected ${name}, current URL:${oldUrl}, new URL:${newUrl}`);
      }
    }
  }
  registerHandleStaleModuleHook(handleStaleModule) {
    if (this.handleStaleModuleHook) {
      this.handleStaleModuleHook.push(handleStaleModule);
    } else {
      this.handleStaleModuleHook = [handleStaleModule];
    }
  }
};
