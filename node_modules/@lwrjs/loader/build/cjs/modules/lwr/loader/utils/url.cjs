var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/loader/src/modules/lwr/loader/utils/url.ts
__markAsModule(exports);
__export(exports, {
  getBaseUrl: () => getBaseUrl,
  isUrl: () => isUrl,
  resolveIfNotPlainOrUrl: () => resolveIfNotPlainOrUrl,
  resolveUrl: () => resolveUrl
});
var import_dom = __toModule(require("./dom"));
function getBaseUrl() {
  let baseUrl = void 0;
  if (import_dom.hasDocument) {
    const baseEl = document.querySelector("base[href]");
    baseUrl = baseEl && baseEl.href;
  }
  if (!baseUrl && typeof location !== "undefined") {
    baseUrl = location.href.split("#")[0].split("?")[0];
    const lastSepIndex = baseUrl.lastIndexOf("/");
    if (lastSepIndex !== -1) {
      baseUrl = baseUrl.slice(0, lastSepIndex + 1);
    }
  }
  return baseUrl;
}
function isUrl(url) {
  return url.indexOf("://") !== -1;
}
function resolveIfNotPlainOrUrl(relUrl, parentUrl) {
  const backslashRegEx = /\\/g;
  if (relUrl.indexOf("\\") !== -1)
    relUrl = relUrl.replace(backslashRegEx, "/");
  if (relUrl[0] === "/" && relUrl[1] === "/") {
    return parentUrl.slice(0, parentUrl.indexOf(":") + 1) + relUrl;
  } else if (relUrl[0] === "." && (relUrl[1] === "/" || relUrl[1] === "." && (relUrl[2] === "/" || relUrl.length === 2 && (relUrl += "/")) || relUrl.length === 1 && (relUrl += "/")) || relUrl[0] === "/") {
    const parentProtocol = parentUrl.slice(0, parentUrl.indexOf(":") + 1);
    let pathname;
    if (parentUrl[parentProtocol.length + 1] === "/") {
      if (parentProtocol !== "file:") {
        pathname = parentUrl.slice(parentProtocol.length + 2);
        pathname = pathname.slice(pathname.indexOf("/") + 1);
      } else {
        pathname = parentUrl.slice(8);
      }
    } else {
      pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === "/" ? 1 : 0));
    }
    if (relUrl[0] === "/")
      return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl;
    const segmented = pathname.slice(0, pathname.lastIndexOf("/") + 1) + relUrl;
    const output = [];
    let segmentIndex = -1;
    for (let i = 0; i < segmented.length; i++) {
      if (segmentIndex !== -1) {
        if (segmented[i] === "/") {
          output.push(segmented.slice(segmentIndex, i + 1));
          segmentIndex = -1;
        }
      } else if (segmented[i] === ".") {
        if (segmented[i + 1] === "." && (segmented[i + 2] === "/" || i + 2 === segmented.length)) {
          output.pop();
          i += 2;
        } else if (segmented[i + 1] === "/" || i + 1 === segmented.length) {
          i += 1;
        } else {
          segmentIndex = i;
        }
      } else {
        segmentIndex = i;
      }
    }
    if (segmentIndex !== -1)
      output.push(segmented.slice(segmentIndex));
    return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join("");
  }
}
function resolveUrl(relUrl, parentUrl) {
  const resolvedUrl = resolveIfNotPlainOrUrl(relUrl, parentUrl) || (isUrl(relUrl) ? relUrl : resolveIfNotPlainOrUrl("./" + relUrl, parentUrl));
  return resolvedUrl;
}
