import { BOOTSTRAP_DURATION, BOOTSTRAP_END, BOOTSTRAP_ERROR, BOOTSTRAP_ERROR_COUNT, MAPPINGS_ERROR, MAPPINGS_ERROR_COUNT, MAPPINGS_FETCH, MAPPINGS_FETCH_COUNT, MAPPINGS_FETCH_DURATION, MODULE_DEFINE, MODULE_DEFINE_COUNT, MODULE_ERROR, MODULE_ERROR_COUNT, MODULE_FETCH, MODULE_FETCH_COUNT, MODULE_FETCH_DURATION, ROUTER_ERROR, ROUTER_ERROR_COUNT, ROUTER_NAV, ROUTER_NAV_COUNT, ROUTER_NAV_DURATION, ROUTER_VIEW, ROUTER_VIEW_DURATION } from 'lwr/metrics';
const doNotClear = [MODULE_FETCH, MAPPINGS_FETCH, ROUTER_NAV, ROUTER_VIEW];
const durationMetrics = [ROUTER_NAV_DURATION, ROUTER_VIEW_DURATION];
const countMap = {
  [BOOTSTRAP_ERROR]: BOOTSTRAP_ERROR_COUNT,
  [MODULE_DEFINE]: MODULE_DEFINE_COUNT,
  [MODULE_FETCH]: MODULE_FETCH_COUNT,
  [MODULE_ERROR]: MODULE_ERROR_COUNT,
  [MAPPINGS_FETCH]: MAPPINGS_FETCH_COUNT,
  [MAPPINGS_ERROR]: MAPPINGS_ERROR_COUNT,
  [ROUTER_NAV]: ROUTER_NAV_COUNT,
  [ROUTER_ERROR]: ROUTER_ERROR_COUNT
};
const metricsToCount = Object.keys(countMap);
export class PerformanceApiSink {
  constructor(instrumentation, config) {
    this.config = config || {};
    this.instrumentation = instrumentation;
  }

  track() {
    this.trackExistingMarks();
    this.setupObserver();
  } // Retrieve existing loader define metrics to this point


  trackExistingMarks() {
    const defineMarks = performance.getEntriesByType('mark').filter(e => e.name.startsWith(MODULE_DEFINE)); // Initialize the module define count
    // At this point in time, the count will include modules NOT fetched by the loader:
    //      - required modules
    //      - preload modules
    //      - the application bootstrap module
    //      - the loader module itself

    if (defineMarks.length > 0) {
      this.instrumentation.incrementCounter(MODULE_DEFINE_COUNT, defineMarks.length);
    }
  } // Add observer to log future metrics


  setupObserver() {
    const observer = new PerformanceObserver(list => {
      list.getEntries().forEach(entry => {
        const {
          name,
          duration,
          startTime
        } = entry; // Track the bootstrap duration from navigation.start to lwr.bootstrap.end

        if (name === BOOTSTRAP_END) {
          this.instrumentation.trackValue(BOOTSTRAP_DURATION, startTime);
        } // Increment count metrics


        const metricToCount = metricsToCount.find(c => name.startsWith(c));

        if (metricToCount) {
          this.instrumentation.incrementCounter(countMap[metricToCount], 1);
        } // Record duration metrics


        if (this.config.enableModuleFetchTracking && name.startsWith(MODULE_FETCH_DURATION)) {
          this.instrumentation.trackValue(name, duration);
        }

        if (this.config.enableMappingFetchTracking && name.startsWith(MAPPINGS_FETCH_DURATION)) {
          this.instrumentation.trackValue(name, duration);
        }

        if (durationMetrics.some(d => name.startsWith(d))) {
          this.instrumentation.trackValue(name, duration);
        } // Remove clearable marks
        // A mark is clearable if it does not have a corresponding logOperationEnd / measure


        if (!doNotClear.some(m => name.startsWith(m))) {
          performance.clearMarks(name);
        }
      });
    });
    observer.observe({
      entryTypes: ['mark', 'measure']
    });
  }

}