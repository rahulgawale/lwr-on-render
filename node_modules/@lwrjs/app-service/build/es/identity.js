import { parsePackageSpecifier } from '@lwrjs/shared-utils';
/*
    App Identity Taxonomy and Schema
    Application identity is an extension of the URI package identity semantics:
    https://rfcs.lwc.dev/rfcs/lwr/0000-uri-patterns#identity-semantics

    Based on the App identity semantics:
    https://rfcs.lwc.dev/rfcs/lwr/0000-lwr-bootstrap#application-definition-identifier-constraints

    The combined schema for the domain of all application resource identities is described by the following
    EBNF grammar:
    ------------------------------------------------------------------------------------------------------
    taxonomy            = packageName "/" appId "/" resourceType "/" format ["/" appSubResource]

    packageName       = ["@" safeString "/"] safeString
    appId               = scopedPackage / namespacedPackage
    scopedPackage       =  ["@" safeString "/"] safeString
    namespacedPackage   = safeString [ "/" safeString ]
    resourceType        =  "config" / "mapping" / "json" / "module"
    format              = "esm" / "amd"
    appSubResourceType  = pathSubResource / workerSubResource
    pathSubResource     = "path/" relativePath
    relativePath        = safeString *([slashEnc safeString])
    workerSubResource     = "worker/" safeString
    
    safeString          = (ALPHA / DIGIT) *(ALPHA / DIGIT / "-" / "_")
    ------------------------------------------------------------------------------------------------------
    
    Examples of potential application resource identities include:
    Default App
    @lwrjs/app-service/lwr/app/module/esm  -- "lwr/app" Bootstrap ESM Module
    @lwrjs/app-service/lwr/app/module/amd  -- "lwr/app" Bootstrap AMD Module

    Nested application resources
    @lwrjs/app-service/lwr/app/module/amd/path/blog      -- Bootstrap ESM Module for "blog" view of the "lwr/app"
    @lwrjs/app-service/lwr/app/module/amd/worker/priming -- Bootstrap ESM Module for "priming" worker of the "lwr/app"
*/
export const APP_BOOTSTRAP_PACKAGE_NAME = '@lwrjs/app-service';
export const SUPPORTED_MODULE_FORMATS = ['amd', 'esm'];
export var AppResourceEnum;
(function (AppResourceEnum) {
    AppResourceEnum["MODULE"] = "module";
})(AppResourceEnum || (AppResourceEnum = {}));
export var ResourceIdentityTypes;
(function (ResourceIdentityTypes) {
    ResourceIdentityTypes["PATH"] = "path";
    ResourceIdentityTypes["WORKER"] = "worker";
})(ResourceIdentityTypes || (ResourceIdentityTypes = {}));
export function parseAppIdentity(specifier) {
    const { packageName, subResource: packageSubResource } = parsePackageSpecifier(specifier);
    if (packageSubResource === '') {
        // appIdentity requires a subResource
        return;
    }
    const { appIdentity, appName, appResourceId } = parseAppResource(packageSubResource);
    const appResource = parseResourceId(appResourceId);
    if (!appResource) {
        return;
    }
    return {
        packageName,
        appIdentity,
        appName,
        ...appResource,
    };
}
export function isWorkerSubResource(subResource) {
    return subResource.type === ResourceIdentityTypes.WORKER;
}
export function getAppSpecifier(appIdentity) {
    // @lwrjs/app-service/lwr/app/module/esm/path/blog
    // @lwrjs/app-service/lwr/app/module/esm/worker/priming
    // taxonomy            = packageName "/" appId "/" resourceType "/" format ["/" appSubResource]
    // appId               = scopedPackage / namespacedPackage
    // scopedPackage       =  ["@" safeString "/"] safeString
    // namespacedPackage   = safeString [ "/" safeString ]
    const appSubResourceIdentifier = appIdentity.subResource
        ? isWorkerSubResource(appIdentity.subResource)
            ? `/${appIdentity.subResource.type}/${appIdentity.subResource.workerId}`
            : `/${appIdentity.subResource.type}${appIdentity.subResource.requestPath}`
        : '';
    return `${APP_BOOTSTRAP_PACKAGE_NAME}/${appIdentity.appName}/${appIdentity.resourceType}/${appIdentity.format}${appSubResourceIdentifier}`;
}
function parseResourceId(resourceId) {
    // e.g --  module/esm/[path/blog]
    const [resourceType, format, type, ...remaining] = resourceId.split('/');
    let subResource;
    if (!isValidFormat(format) || !isValidResourceType(resourceType)) {
        return;
    }
    switch (type) {
        case ResourceIdentityTypes.PATH:
            subResource = {
                subResource: {
                    type,
                    requestPath: `/${remaining.join('/')}`,
                },
            };
            break;
        case ResourceIdentityTypes.WORKER: {
            subResource = {
                subResource: {
                    type,
                    workerId: `${remaining[0]}`,
                },
            };
        }
    }
    return {
        resourceType,
        format,
        ...subResource,
    };
}
function parseAppResource(appResource) {
    const { scope: appScope, packageName: appPackageName, subResource: appResourceId, } = parsePackageSpecifier(appResource);
    if (appScope) {
        // appResource =
        // @my/app = {id: "@my/app", scope: "@my", name: "app"}
        return {
            appName: `${appScope}/${appPackageName}`,
            appIdentity: {
                scope: appScope,
                name: appPackageName,
            },
            appResourceId,
        };
    }
    else if (/^(config|mapping|json|module)/.test(appResourceId)) {
        // app = {id: "app", name: "app"}
        return {
            appName: appPackageName,
            appIdentity: {
                name: appPackageName,
            },
            appResourceId,
        };
    }
    else {
        // lwr/app = {id: "lwr/app", namespace: "lwr" name: "app"}
        const [name, ...remaining] = appResourceId.split('/');
        return {
            appName: `${appPackageName}/${name}`,
            appIdentity: {
                namespace: appPackageName,
                name,
            },
            appResourceId: remaining.join('/'),
        };
    }
}
/* validation methods */
function isValidFormat(format) {
    return (format !== undefined &&
        (format === 'esm' || format === 'amd'));
}
function isValidResourceType(resourceType) {
    return resourceType !== undefined && resourceType === 'module';
}
export function isValidResourceIdentity(appIdentity, resourceType) {
    return (appIdentity.packageName === APP_BOOTSTRAP_PACKAGE_NAME &&
        isValidResourceType(resourceType) &&
        appIdentity.resourceType === resourceType &&
        isValidFormat(appIdentity.format));
}
//# sourceMappingURL=identity.js.map