import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { hashContent } from '@lwrjs/shared-utils';
import { createAppRouteViewBootstrapModule, createAppWorkerBootstrapModule } from './utils.js';
import { AppResourceEnum, isValidResourceIdentity, isWorkerSubResource, parseAppIdentity, } from '../identity.js';
// Validation gating methods
function validateSpecifier(specifier) {
    const appIdentity = parseAppIdentity(specifier);
    return !!appIdentity && isValidResourceIdentity(appIdentity, AppResourceEnum.MODULE);
}
export default class AppModuleProvider {
    constructor(appPluginConfig, { config, runtimeEnvironment: { hmrEnabled, lwrVersion } }) {
        this.name = 'app-provider';
        this.hmrEnabled = false;
        this.config = config;
        this.hmrEnabled = hmrEnabled;
        this.version = lwrVersion;
        this.lockerConfig = config.locker;
    }
    async getModuleEntry({ specifier }) {
        // Validate the root app module specifier
        // expected format: @lwrjs/app-service/{appName}/module/{format}[/worker/{workerId}]
        if (validateSpecifier(specifier)) {
            const normalizedSpecifier = specifier.endsWith('/') ? `${specifier}index` : specifier;
            const virtualId = `<virtual>/${normalizedSpecifier}`;
            return {
                id: `${virtualId}|${this.version}`,
                virtual: true,
                entry: virtualId,
                specifier,
                version: this.version,
            };
        }
    }
    async getModuleSource({ specifier, namespace, name, }) {
        const appIdentity = parseAppIdentity(specifier);
        if (!appIdentity || !isValidResourceIdentity(appIdentity, AppResourceEnum.MODULE)) {
            return;
        }
        // Fetch the Module Entry and corresponding route config object
        const moduleEntry = await this.getModuleEntry({ specifier });
        const route = [...this.config.routes, ...this.config.errorRoutes].find((r) => r.id === appIdentity.appName);
        if (!moduleEntry || !route) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.MODULE(specifier),
            }, LwrUnresolvableError);
        }
        const { format } = appIdentity;
        const moduleLoader = format === 'amd' ? this.config.amdLoader : this.config.esmLoader;
        let originalSource;
        if (appIdentity.subResource && isWorkerSubResource(appIdentity.subResource)) {
            // Only needs to initialize the worker module (no support for custom view components or other dynamic use cases)
            const workerId = appIdentity.subResource.workerId;
            // validate worker exists
            const workerSpecifier = route.bootstrap.workers[workerId];
            if (!workerSpecifier) {
                throw createSingleDiagnosticError({
                    description: descriptions.UNRESOLVABLE.MODULE(specifier),
                }, LwrUnresolvableError);
            }
            originalSource = createAppWorkerBootstrapModule(workerSpecifier, route, {
                format,
                moduleLoader,
                hmrEnabled: false,
            });
        }
        else {
            // Support for root components + content-derived view template components
            originalSource = createAppRouteViewBootstrapModule(route, {
                format,
                hmrEnabled: this.hmrEnabled,
                moduleLoader,
            }, this.lockerConfig);
        }
        return {
            id: moduleEntry.id,
            namespace,
            name: name || specifier,
            version: this.version,
            specifier,
            moduleEntry,
            ownHash: hashContent(originalSource),
            originalSource,
        };
    }
    async getModule(moduleId) {
        if (!validateSpecifier(moduleId.specifier)) {
            return;
        }
        // Get the source to compile
        const moduleSource = (await this.getModuleSource(moduleId));
        const compiledSource = moduleSource.originalSource;
        return {
            ...moduleSource,
            compiledSource,
        };
    }
}
//# sourceMappingURL=index.js.map