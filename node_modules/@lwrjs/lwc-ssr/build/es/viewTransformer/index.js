import { kebabCaseToModuleSpecifer, logger } from '@lwrjs/shared-utils';
import { LWC_SSR_PREFIX, SSR_PROPS_ATTR, SSR_PROPS_KEY, getPropsId } from '../identity.js';
import { ssrElement } from './ssr-element.js';
/**
 * This is a view transformer run by the view registry during linking of a page document/route (configured in lwr.config.json[routes]).
 * If the "ssr" bootstrap flag is on for the route, it will server-side render (SSR) each custom element found in the page HTML.
 *
 * SSR Flow:
 *  1. There is a request to generate a view (ie: page document) via the UI middleware or static site generation
 *  2. During view generation, the view registry runs all the registered view transformers (including this one)
 *  3. This view transformer links the SSRed string for EVERY custom element (ie: root component) found in the page document:
 *      a) It requests a module which SSRs a given custom element, generated by "lwc-ssr/moduleProvider"
 *      b) A bundle is created for the generated SSR module (see "./ssr-element")
 *      c) The bundle code is run inside a worker (see "./ssr-element"), with context stored in "workerData"
 *      d) RootComponent.getPageData() is run to preload data and <links>, if available
 *      e) The generated SSR module (running the worker) passes the SSRed code string back to the main thread
 *      f) The SSRed string is used to overwrite/link each custom element (eg: "<c-app></c-app>") in the document (see "stringBuilder.overwrite")
 *      g) A script containing all the serialized properties is added for hydration
 * 4. The view/page document now contains SSRed components, which will be sent to the client
 * 5. During bootstrap on the client, the "lwr/initSsr" module will hydrate ALL the custom elements on the page
 */
export default function lwcSsrViewTranformer(options, { moduleBundler }) {
    return {
        name: 'ssr-lwc-transformer',
        async link(stringBuilder, viewContext, { customElements }) {
            logger.debug('lwcSsrViewTranformer');
            logger.verbose('lwcSsrViewTranformer input', stringBuilder);
            // SSR currently does not support locker because the module constructor returns undefined
            // and the call to renderComponent would fail
            if (process.env.LOCKER === 'true') {
                return;
            }
            if (viewContext.view.bootstrap?.ssr) {
                // Gather all the SSRable custom elements (ie: root components) into 1 list
                const ssrModules = [];
                for (const { tagName, location, props } of customElements) {
                    if (location) {
                        const { startOffset, endOffset } = location;
                        const moduleSpecifier = kebabCaseToModuleSpecifer(tagName);
                        ssrModules.push({
                            startOffset,
                            endOffset,
                            props,
                            tagName,
                            specifier: `${LWC_SSR_PREFIX}${moduleSpecifier}`,
                        });
                    }
                }
                // SSR and gather the properties and links for each eligible custom element, in parallel
                const ssrProps = {};
                let ssrLinks = '';
                await Promise.all(ssrModules.map(({ specifier, tagName, props, startOffset, endOffset }) => {
                    return ssrElement({ specifier, props }, moduleBundler, viewContext)
                        .then(({ html, props, markup: { links = [] } = { links: [] } }) => {
                        if (props) {
                            // Add the props id to the HTML for the custom element
                            // eg: <some-cmp> -> <some-cmp data-lwr-props-id="1234">
                            const propsId = getPropsId();
                            ssrProps[propsId] = props;
                            const [, remain] = html.split(`<${tagName}`);
                            html = [`<${tagName}`, ` ${SSR_PROPS_ATTR}="${propsId}"`, remain].join('');
                        }
                        links.forEach(({ href, rel, as, fetchpriority }) => {
                            // Create HTML <link> strings for each item in the links array
                            const relStr = rel ? ` rel="${rel}"` : '', asStr = as ? ` as="${as}"` : '', fetchStr = fetchpriority ? ` fetchpriority="${fetchpriority}"` : '';
                            ssrLinks += `<link href="${href}"${relStr}${asStr}${fetchStr}>\n`;
                        });
                        // Overwrite the custom element with the SSRed component string
                        stringBuilder.overwrite(startOffset, endOffset, html);
                    })
                        .catch((err) => {
                        logger.warn(`Server-side rendering for "${specifier}" failed. Falling back to client-side rendering. Reason: `, err.stack);
                    });
                }));
                if (Object.keys(ssrProps).length) {
                    // Serialize all root component properties into a single script for the page
                    // Append the script before the custom elements; it MUST appear before the AMD shim to avoid timing issues
                    stringBuilder.prependLeft(ssrModules[0].startOffset, `<script type="application/javascript">globalThis.LWR = globalThis.LWR || {};globalThis.LWR.${SSR_PROPS_KEY} = ${JSON.stringify(ssrProps)};</script>`);
                }
                if (ssrLinks) {
                    // Add all the links to the <head> section of the base document
                    const headIndex = stringBuilder.original.indexOf('</head>');
                    if (headIndex >= 0) {
                        stringBuilder.prependLeft(headIndex, ssrLinks);
                    }
                    else {
                        logger.error('Adding links during server-side rendering failed. Could not find the </head> tag.');
                    }
                }
                logger.verbose('lwcSsrViewTranformer response', stringBuilder);
            }
        },
    };
}
//# sourceMappingURL=index.js.map