# Server-side rendering (SSR) in LWR

## Overview

### What is SSR?

[Lightning Web Components (LWC)](https://lwc.dev/) is a framework for creating client-side applications. However, these components can also be rendered as an HTML string on the **server**. LWR sends these strings to the client, where they can be ["hydrated"](#client-hydration) to create an interactive web app.

### Why use SSR?

With SSR, the browser does not need to wait for all the JavaScript to download and execute before displaying component markup. This results in faster time-to-content, especially on slower devices or internet connections. It also makes the content accessible to search engine crawlers, improving SEO.

That said, SSR is best used for apps where time-to-content is important, such as B2C websites. The benefits of SSR should be weighed against the costs: higher server load, increased build & deployment complexity, developing server-compatible component code.

## Using SSR with LWR

Learn how to use SSR in your LWR apps.

### Turn on SSR

SSR is activated on a per-route basis by changing `bootstrap.ssr` to `true`:

```json
// my-app/lwr.config.json
{
    "routes": [
        {
            "id": "ssr-page",
            // parameterized path
            "path": "/category/:category",
            // content template
            "contentTemplate": "$contentDir/page.html",
            "bootstrap": {
                // turn on SSR for the page here
                "ssr": true
            }
        }
    ]
}
```

### Building SSR pages

When a route with `bootstrap.ssr` is requested, LWR will use [LWC'S `renderComponent()` function](https://rfcs.lwc.dev/rfcs/lwc/0112-server-engine) to SSR each **root component** on the page. This is done whether the page is generated at runtime, or pre-built using `generateStaticSite()`.

> A "root component" is any lwc in an app route's [content template, layout template](https://github.com/salesforce/lwr-recipes/tree/main/packages/templating#templates), or [`rootComponent` configuration](https://github.com/salesforce/lwr-recipes/blob/main/doc/config.md#routes).

LWR will automatically pass any root component attributes from a [template](https://github.com/salesforce/lwr-recipes/tree/main/packages/templating#templates) as [public properties](https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reactivity_public) during SSR. For example, `my/root` will receive `{ limit: '10' }`.

```html
<!-- my-app/src/content/page.html -->
<section>
    <!-- "limit" is a template attribute property -->
    <my-root limit="10"></my-root>
</section>
```

#### Limitations

There are restrictions on component code for it to successfully render on the server. The `renderComponent()` function executes the [`constructor` and `connectedCallback`](https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reference_lifecycle_hooks) of each component. This code must be **portable** or SSR will fail.

> Code is _portable_ when it can run in a headless environment, where there is no access to DOM APIs (eg: window).

### Loading data during SSR

Many components depend on external data and resources. LWR provides a `getPageData()` hook for developers to fetch data on the server. During SSR, LWR calls the `getPageData()` hook for each **root component**, then serializes the resulting data into the page document as either [JSON](#json) or [markup](#markup).

> **Important**: `getPageData()` is **only** run for root components.

```ts
type GetPageDataHook = (context: SsrRequestContext) => Promise<PageDataResponse>;

interface SsrRequestContext {
    // existing props from template attributes
    props: Json;
    // values from a parameterized route defined in lwr.config.json
    params: { [key: string]: string };
    // search parameters from the request URL
    query: { [key: string]: string };
    // locale string for the request, eg: 'en-US'
    locale: string;
}

interface PageDataResponse {
    props?: Json; // JSON serializable properties for the root component
    markup?: {
        // HTML serializable data
        links?: {
            // links to contribute to the <head> markup
            href: string;
            as?: string;
            rel?: string;
            fetchpriority?: 'high' | 'low' | 'auto';
        }[];
    };
}

type Json = undefined | null | boolean | number | string | Json[] | { [prop: string]: Json };
```

In LWR, the SSR process runs in a sandbox. This sandbox supports `globalThis.fetch` so developers can use `fetch()` in their `getPageData()` hooks as if the module is being executed in browser.

#### JSON

Data in `PageDataResponse.props` is serialized into the page document as JSON. LWR passes this data to the component as [public properties](<(https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reactivity_public)>) during both SSR and [client hydration](#client-hydration).

#### Markup

Data in `PageDataResponse.markup` is serialized into the page document as HTML. LWR adds each `markup.link` returned by `getPageData()` to the `<head>` section of the page document. For example, developers can [preload images](https://developer.chrome.com/blog/link-rel-preload/) to improve a page's performance on the client.

#### Example

The `getPageData()` hook is exported as a function from a root component module:

```ts
// my-app/src/modules/my/root/root.ts
import { LightningElement, api } from 'lwc';
import type { SsrRequestContext, PageDataResponse } from '@lwrjs/types';

export default class MyRoot extends LightningElement {
    @api data: SomeDataType[] = [];
}

export async function getPageData(context: SsrRequestContext): Promise<PageDataResponse> {
    // "/category/books" => context.params = { category: 'books' }
    const category = context.params.category;

    // page.html template => context.props = { limit: '10' }
    const num = context.props.limit || '25';
    const res = await fetch(`https://www.some-api.com/${category}?lang=${context.locale}&num=${num}`);
    const data = await res.json();

    return {
        props: {
            // will be passed to the root component as props
            data,
            ...context.props, // pass the template props through, if desired
        },
        markup: {
            links: [
                {
                    // preload an important image to boost performance
                    href: data.thumbnail,
                    as: 'image',
                    rel: 'preload',
                    fetchpriority: 'high',
                },
            ],
        },
    };
}
```

Notes:

-   The `getPageData()` hook can choose to merge the properties from `SsrRequestContext.props` into its return object, or it can ignore/discard them.
-   The author of `getPageData()` is responsible for validating the `params` and `query` from `SsrRequestContext` before using them.
-   The **same** `props` returned by `getPageData()` are passed to the component during server rendering **and** client hydration.

### Client hydration

When SSRed component HTML reaches the browser, each root component is automatically hydrated. LWR uses the [LWC `hydrateComponent()` API](https://rfcs.lwc.dev/rfcs/lwc/0117-ssr-rehydration) to do so. Hydrating a component starts its component lifecycle and makes it interactive.

### Debugging

With the introduction of [@locker/near-membrane-node](https://github.com/salesforce/near-membrane/tree/main/packages/near-membrane-node) sandbox, debugging a module in server side rendering is straightforward:

1. setting a `debugger;` statement in your module
2. attach node process to the LWR server

```sh
LOCKER_SB=true yarn lwr:example:debug
```

3. visit intended url(http://localhost:3000/ssr in this example) with a browser
4. when `debugger;` statement is executed, VS Code would break with the VM tab showing up

![Sandbox Debugging Screenshot](../../../assets/sandbox-debug.png)
