import { explodeSpecifier, getImportMetadata } from '@lwrjs/shared-utils';
import { rollup } from 'rollup';
import { Compiler as Locker } from '@locker/compiler';
import { minify, parse } from './transformer.js';
export const AMD_DEFINE = 'LWR.define';
const AMD_ROLLUP_PLUGIN = function (rootId, source) {
    return {
        name: 'lwr-amd-inline',
        resolveId(id) {
            return rootId === id ? id : undefined;
        },
        load(id) {
            return rootId === id ? source : undefined;
        },
    };
};
export class LwrCompiler {
    constructor() {
        this.getModuleMetadata = getImportMetadata;
    }
    async convertToAmd(source, { id }, forceNamedExports = true) {
        const bundler = await rollup({
            input: id,
            plugins: [AMD_ROLLUP_PLUGIN(id, source)],
            onwarn(warning, warn) {
                // do not print out these: 'a' is imported by b, but could not be resolved â€“ treating it as an external dependency
                if (warning.code === 'UNRESOLVED_IMPORT')
                    return;
                warn(warning);
            },
        });
        const { output } = await bundler.generate({
            amd: { id, define: AMD_DEFINE },
            exports: forceNamedExports ? 'named' : 'auto',
            format: 'amd',
        });
        const { code } = output[0];
        return { code, map: null };
    }
    /** Locker
     * Trusted Components can contain namespaces with wildcard or single component
     */
    lockerize({ compiledSource: source, specifier, moduleEntry: { entry: filename } }, { trustedComponents }, sourcemap = false) {
        const { namespace, name: rawName } = explodeSpecifier(specifier);
        const [name] = rawName.split('#');
        const bareSpecifier = namespace ? `${namespace}/${name}` : name;
        const isJS = filename.endsWith('.js') || filename.endsWith('.mjs') || filename.endsWith('.ts');
        // lockerize if component is JS and is not explicitly trusted or in a trusted namespace
        if (isJS &&
            trustedComponents &&
            !trustedComponents.includes(`${namespace}/*`) &&
            !trustedComponents.includes(bareSpecifier)) {
            const { code } = Locker.compile(source, {
                componentName: name,
                filename,
                // put non-namespaced modules in a single sandbox - this should only be non-lwc npm modules
                sandboxKey: namespace || 'sandbox',
                sourcemap,
                remapDynamicImport: true, // support for dynamic imports
            });
            return { code, map: null };
        }
        return { code: source, map: null };
    }
    minifyJavascript(source) {
        return minify(source);
    }
    parseJavascript(source, options) {
        return parse(source, options);
    }
    minifyCSS(source) {
        return minify(source, { fileType: 'css' });
    }
}
//# sourceMappingURL=index.js.map