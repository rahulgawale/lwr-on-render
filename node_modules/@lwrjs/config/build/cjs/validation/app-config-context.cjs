var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/validation/app-config-context.ts
__markAsModule(exports);
__export(exports, {
  ASSET_DIR_ATTRIBUTE_KEYS: () => ASSET_DIR_ATTRIBUTE_KEYS,
  ASSET_FILE_ATTRIBUTE_KEYS: () => ASSET_FILE_ATTRIBUTE_KEYS,
  BASE_PATH_REGEX: () => BASE_PATH_REGEX,
  BOOTSTRAP_ATTRIBUTE_KEYS: () => BOOTSTRAP_ATTRIBUTE_KEYS,
  ERROR_ROUTE_ATTRIBUTE_KEYS: () => ERROR_ROUTE_ATTRIBUTE_KEYS,
  LOCKER_ATTRIBUTE_KEYS: () => LOCKER_ATTRIBUTE_KEYS,
  ROOT_ATTRIBUTE_KEYS: () => ROOT_ATTRIBUTE_KEYS,
  ROUTE_ATTRIBUTE_KEYS: () => ROUTE_ATTRIBUTE_KEYS,
  ValidationContext: () => ValidationContext
});
var import_jsonc_parser = __toModule(require("jsonc-parser"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_helpers = __toModule(require("./helpers.cjs"));
function createKeys(p, t) {
  return p && t;
}
var ROOT_ATTRIBUTE_KEYS = createKeys("root", [
  "amdLoader",
  "apiVersion",
  "assets",
  "assetProviders",
  "assetTransformers",
  "bundleConfig",
  "cacheDir",
  "contentDir",
  "environment",
  "errorRoutes",
  "esmLoader",
  "staticSiteGenerator",
  "globalData",
  "globalDataDir",
  "hooks",
  "ignoreLwrConfigFile",
  "lwrConfigFile",
  "layoutsDir",
  "locker",
  "lwc",
  "lwrVersion",
  "moduleProviders",
  "port",
  "basePath",
  "resourceProviders",
  "rootDir",
  "routes",
  "serverMode",
  "serverType",
  "templateEngine",
  "viewProviders",
  "viewTransformers"
]);
var ASSET_DIR_ATTRIBUTE_KEYS = createKeys("assetDir", ["alias", "dir", "urlPath"]);
var ASSET_FILE_ATTRIBUTE_KEYS = createKeys("assetFile", ["alias", "file", "urlPath"]);
var LOCKER_ATTRIBUTE_KEYS = createKeys("locker", ["enabled", "trustedComponents", "clientOnly"]);
var ROUTE_ATTRIBUTE_KEYS = createKeys("routes", [
  "bootstrap",
  "subRoutes",
  "contentTemplate",
  "id",
  "cache",
  "layoutTemplate",
  "method",
  "path",
  "rootComponent",
  "routeHandler",
  "properties"
]);
var ERROR_ROUTE_ATTRIBUTE_KEYS = createKeys("errorRoutes", [
  "bootstrap",
  "subRoutes",
  "contentTemplate",
  "id",
  "layoutTemplate",
  "rootComponent",
  "routeHandler",
  "status",
  "properties",
  "cache"
]);
var BOOTSTRAP_ATTRIBUTE_KEYS = createKeys("bootstrap", [
  "autoBoot",
  "syntheticShadow",
  "workers",
  "services",
  "configAsSrc",
  "ssr"
]);
var SPECIFIER_REGEX = /^@?[\w-]+(\/[\w-]+)*$/;
function isNotEmptyString(node) {
  return node.type === "string" && node.value.length > 0;
}
var BASE_PATH_REGEX = /^(\/[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)+$/g;
var ValidationContext = class {
  constructor(sourceText) {
    this.diagnostics = [];
    this.sourceText = sourceText;
  }
  getLocationFromNode(node) {
    return (0, import_helpers.calculatePositionFromSource)(this.sourceText, node);
  }
  assertIsObject(node, property) {
    if (node.type !== "object") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "object", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsBoolean(node, property) {
    if (node && node.type !== "boolean") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "boolean", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsArray(node, property) {
    if (node && node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsSpecifier(node, property) {
    if (node && (node.type !== "string" || !SPECIFIER_REGEX.test(node.value))) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SPECIFIER(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsPath(node, property) {
    if (node && (node.type !== "string" || node.value[0] !== "/")) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PATH(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsPort(node, property) {
    if (node && (node.type !== "number" || node.value < 0 || node.value > 65353)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PORT(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsServerType(node, property) {
    if (node && node.value !== "express" && node.value !== "koa" && node.value !== "fs") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SERVER_TYPE(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsStaticSiteGenerator(node, property) {
    if (node && node.type !== "object") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_GENERATOR_CONFIG(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsMethod(node, property) {
    if (node && node.value !== "get" && node.value !== "post") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_METHOD(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsStatus(node, property) {
    if (node && node.value !== 404 && node.value !== 500) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_STATUS(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsEnvironment(node, property) {
    if (!node) {
      return;
    }
    let defaultProperty;
    let supportedProperty;
    if (node.type === "object" && node.children?.length) {
      for (const child of node.children) {
        if (child.type === "property" && child.children?.length) {
          if (child.children[0].value === "default" && isNotEmptyString(child.children[1])) {
            defaultProperty = child;
          }
          if (child.children[0].value === "supported") {
            supportedProperty = child;
          }
        }
      }
    }
    if (node.type !== "object" || supportedProperty && !defaultProperty) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_ENVIRONMENT(property),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsBasePath(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "string") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "string", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.value === "") {
      return;
    } else if (node.value.match(BASE_PATH_REGEX) === null) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_BASEPATH(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertNotEmptyString(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "string") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "string", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (!isNotEmptyString(node)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertNotEmptyArray(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (!node.children || node.children.length === 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_ARRAY(property, "[]"),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertHasOneOrMore(node, property, childProps) {
    if (!childProps.some((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p]) !== void 0)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.MISSING_ONE_OF(property, childProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertHasOnlyOne(node, property, childProps) {
    if (childProps.filter((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p])).length !== 1) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.TOO_MANY(property, childProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertArrayOfStrings(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        if (!isNotEmptyString(n)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_STRING(`${property}[${index}]`, n.value),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertArrayOfSpecifiers(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        if (n.type !== "string" || !SPECIFIER_REGEX.test(n.value)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, n.value),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertArrayOfServices(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        if (n.type !== "string" && n.type !== "array") {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(`${property}[${index}]`, "string or array", n.type),
            location: this.getLocationFromNode(n)
          });
        }
        if (n.type === "string" && n.value.length === 0 || n.type === "array" && n.children && (n.children.length !== 2 || !isNotEmptyString(n.children[0]))) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SERVICE(`${property}[${index}]`, n.value === void 0 && n.children ? `invalid Array[${n.children.length}]` : n.value),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertUniqueIds(nodes, property) {
    const ids = nodes.map((n) => {
      const idNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["id"]);
      return idNode ? idNode.value : void 0;
    }).filter((id) => id !== void 0);
    const dupeIds = ids.filter((id, index) => ids.indexOf(id) !== index);
    if (dupeIds.length > 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.DUPLICATE_IDS(property, dupeIds),
        location: this.getLocationFromNode(nodes[0])
      });
    }
  }
  assertRequiredKeys(node, property, requiredPropertyKeys) {
    const missingProps = requiredPropertyKeys.filter((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p]) === void 0);
    if (missingProps.length > 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.MISSING_REQUIRED(property, missingProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertValidKeys(node, property, validPropertyKeys) {
    const {children} = node;
    if (!children) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_EMPTY_NODE(property),
        location: this.getLocationFromNode(node)
      });
      return;
    } else {
      for (const propertyNode of children) {
        if (propertyNode.type === "property" && propertyNode.children) {
          const [keyNode] = propertyNode.children;
          const {type, value} = keyNode;
          if (type === "string" && !validPropertyKeys.includes(value)) {
            this.diagnostics.push({
              description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PROPERTY(property, value),
              location: this.getLocationFromNode(keyNode)
            });
          }
        }
      }
    }
  }
};
