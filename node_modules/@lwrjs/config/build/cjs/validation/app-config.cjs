var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/validation/app-config.ts
__markAsModule(exports);
__export(exports, {
  SOURCE_BY_PHASE: () => SOURCE_BY_PHASE,
  validateLwrAppConfig: () => validateLwrAppConfig
});
var import_jsonc_parser = __toModule(require("jsonc-parser"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_app_config_context = __toModule(require("./app-config-context.cjs"));
var import_helpers = __toModule(require("./helpers.cjs"));
var SOURCE_BY_PHASE = {
  file: "lwr.config.json",
  pre: "argument passed to createServer",
  post: "configuration hooks"
};
function validateBootstrap(node, validationContext, propPrefix) {
  if (node) {
    validationContext.assertIsObject(node, "bootstrap");
    validationContext.assertValidKeys(node, "bootstrap", import_app_config_context.BOOTSTRAP_ATTRIBUTE_KEYS);
    validationContext.assertArrayOfSpecifiers((0, import_jsonc_parser.findNodeAtLocation)(node, ["services"]), `${propPrefix}.services`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["autoBoot"]), `${propPrefix}.autoBoot`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["ssr"]), `${propPrefix}.ssr`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["configAsSrc"]), `${propPrefix}.configAsSrc`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["syntheticShadow"]), `${propPrefix}.syntheticShadow`);
    const workers = (0, import_jsonc_parser.findNodeAtLocation)(node, ["workers"]);
    if (workers && workers.children) {
      workers.children.forEach((w, index) => {
        if (w.children && w.children.length > 1) {
          validationContext.assertIsSpecifier(w.children[1], `${propPrefix}.workers[${index}]`);
        }
      });
    }
  }
}
function validateRouteCommon(node, validationContext, propPrefix) {
  validationContext.assertHasOneOrMore(node, propPrefix, [
    "rootComponent",
    "contentTemplate",
    "routeHandler"
  ]);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["id"]), `${propPrefix}.id`);
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["rootComponent"]), `${propPrefix}.rootComponent`);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["contentTemplate"]), `${propPrefix}.contentTemplate`);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["layoutTemplate"]), `${propPrefix}.layoutTemplate`);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["routeHandler"]), `${propPrefix}.routeHandler`);
  validateBootstrap((0, import_jsonc_parser.findNodeAtLocation)(node, ["bootstrap"]), validationContext, `${propPrefix}.bootstrap`);
}
function validateRoutes(node, validationContext) {
  if (node) {
    validationContext.assertNotEmptyArray(node, "routes");
    if (node.children) {
      node.children.forEach((n, index) => {
        const propPrefix = `routes[${index}]`;
        validationContext.assertIsObject(n, "routes");
        validationContext.assertValidKeys(n, "routes", import_app_config_context.ROUTE_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(n, propPrefix, ["id", "path"]);
        validationContext.assertIsPath((0, import_jsonc_parser.findNodeAtLocation)(n, ["path"]), `${propPrefix}.path`);
        validationContext.assertIsMethod((0, import_jsonc_parser.findNodeAtLocation)(n, ["method"]), `${propPrefix}.method`);
        validateRouteCommon(n, validationContext, propPrefix);
      });
    }
  }
}
function validateErrorRoutes(node, validationContext) {
  if (node) {
    validationContext.assertIsArray(node, "errorRoutes");
    if (node.children) {
      node.children.forEach((n, index) => {
        const propPrefix = `errorRoutes[${index}]`;
        validationContext.assertIsObject(n, "errorRoutes");
        validationContext.assertValidKeys(n, "errorRoutes", import_app_config_context.ERROR_ROUTE_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(n, propPrefix, ["id", "status"]);
        validationContext.assertIsStatus((0, import_jsonc_parser.findNodeAtLocation)(n, ["status"]), `${propPrefix}.status`);
        validateRouteCommon(n, validationContext, propPrefix);
      });
    }
  }
}
function validateAssets(node, validationContext, preMerge) {
  if (node) {
    if (preMerge && node.type === "string") {
      validationContext.assertNotEmptyString(node, "assets");
    } else {
      validationContext.assertNotEmptyArray(node, "assets");
      if (node.children) {
        node.children.forEach((n, index) => {
          const dirNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["dir"]);
          const fileNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["file"]);
          if (dirNode?.type === "string") {
            validationContext.assertIsObject(n, "assetDir");
            validationContext.assertValidKeys(n, "assetDir", import_app_config_context.ASSET_DIR_ATTRIBUTE_KEYS);
          } else if (fileNode?.type === "string") {
            validationContext.assertIsObject(n, "assetFile");
            validationContext.assertValidKeys(n, "assetFile", import_app_config_context.ASSET_FILE_ATTRIBUTE_KEYS);
          }
          validationContext.assertRequiredKeys(n, `assets[${index}]`, ["urlPath"]);
          validationContext.assertHasOnlyOne(n, `assets[${index}]`, ["dir", "file"]);
          validationContext.assertNotEmptyString(dirNode, `assets[${index}].dir`);
          validationContext.assertNotEmptyString(fileNode, `assets[${index}].file`);
          validationContext.assertIsPath((0, import_jsonc_parser.findNodeAtLocation)(n, ["urlPath"]), `assets[${index}].urlPath`);
          validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(n, ["alias"]), `assets[${index}].alias`);
        });
      }
    }
  }
}
function validateLocker(node, validationContext) {
  if (node) {
    validationContext.assertIsObject(node, "locker");
    validationContext.assertValidKeys(node, "locker", import_app_config_context.LOCKER_ATTRIBUTE_KEYS);
    validationContext.assertRequiredKeys(node, "locker", ["enabled"]);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["enabled"]), "locker.enabled");
    validationContext.assertArrayOfStrings((0, import_jsonc_parser.findNodeAtLocation)(node, ["trustedComponents"]), "locker.trustedComponents");
  }
}
function validateRoot(node, validationContext, preMerge) {
  validationContext.assertIsObject(node, "root");
  validationContext.assertValidKeys(node, "root", import_app_config_context.ROOT_ATTRIBUTE_KEYS);
  !preMerge && validationContext.assertRequiredKeys(node, "root", import_app_config_context.ROOT_ATTRIBUTE_KEYS);
  const routes = (0, import_jsonc_parser.findNodeAtLocation)(node, ["routes"]);
  const errorRoutes = (0, import_jsonc_parser.findNodeAtLocation)(node, ["errorRoutes"]);
  validationContext.assertUniqueIds([...routes?.children || [], ...errorRoutes?.children || []], "routes");
  validateRoutes(routes, validationContext);
  validateErrorRoutes(errorRoutes, validationContext);
  validateAssets((0, import_jsonc_parser.findNodeAtLocation)(node, ["assets"]), validationContext, preMerge);
  validateLocker((0, import_jsonc_parser.findNodeAtLocation)(node, ["locker"]), validationContext);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["apiVersion"]), "apiVersion");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["lwrVersion"]), "lwrVersion");
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["amdLoader"]), "amdLoader");
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["esmLoader"]), "esmLoader");
  validationContext.assertIsPort((0, import_jsonc_parser.findNodeAtLocation)(node, ["port"]), "port");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["serverMode"]), "serverMode");
  validationContext.assertIsServerType((0, import_jsonc_parser.findNodeAtLocation)(node, ["serverType"]), "serverType");
  validationContext.assertIsStaticSiteGenerator((0, import_jsonc_parser.findNodeAtLocation)(node, ["staticSiteGenerator"]), "staticSiteGenerator");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["rootDir"]), "rootDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["cacheDir"]), "cacheDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["contentDir"]), "contentDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["layoutsDir"]), "layoutsDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["globalDataDir"]), "globalDataDir");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["hooks"]), "hooks");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["templateEngine"]), "templateEngine");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["moduleProviders"]), "moduleProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["viewProviders"]), "viewProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["resourceProviders"]), "resourceProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["assetProviders"]), "assetProviders");
  validationContext.assertNotEmptyArray((0, import_jsonc_parser.findNodeAtLocation)(node, ["lwc", "modules"]), "lwc.modules");
  validationContext.assertIsEnvironment((0, import_jsonc_parser.findNodeAtLocation)(node, ["environment"]), "environment");
  validationContext.assertIsBasePath((0, import_jsonc_parser.findNodeAtLocation)(node, ["basePath"]), "basePath");
}
function validateLwrAppConfig(jsonSourceText, phase) {
  const errors = [];
  const preMerge = phase !== "post";
  const rootNode = (0, import_jsonc_parser.parseTree)(jsonSourceText, errors);
  if (errors.length) {
    const {error, length, offset} = errors[0];
    const message = (0, import_jsonc_parser.printParseErrorCode)(error);
    const sourceLocation = (0, import_helpers.calculatePositionFromSource)(jsonSourceText, {length, offset});
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      location: sourceLocation,
      description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_JSON(message)
    }, import_diagnostics.LwrConfigValidationError);
  }
  const validationContext = new import_app_config_context.ValidationContext(jsonSourceText);
  validateRoot(rootNode, validationContext, preMerge);
  if (validationContext.diagnostics.length) {
    throw new import_diagnostics.LwrConfigValidationError(`Configuration validation errors in ${SOURCE_BY_PHASE[phase]}`, validationContext.diagnostics);
  }
  return (0, import_jsonc_parser.parse)(jsonSourceText);
}
