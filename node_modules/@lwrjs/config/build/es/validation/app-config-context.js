import { findNodeAtLocation } from 'jsonc-parser';
import { descriptions } from '@lwrjs/diagnostics';
import { calculatePositionFromSource } from './helpers.js';
// Run the duplicate and missing property checks against an object of a given type
function createKeys(p, t) {
    return p && t;
}
// These properties are kept in sync with the NormalizedLwrGlobalConfig type via ts checks
export const ROOT_ATTRIBUTE_KEYS = createKeys('root', [
    'amdLoader',
    'apiVersion',
    'assets',
    'assetProviders',
    'assetTransformers',
    'bundleConfig',
    'cacheDir',
    'contentDir',
    'environment',
    'errorRoutes',
    'esmLoader',
    'staticSiteGenerator',
    'globalData',
    'globalDataDir',
    'hooks',
    'ignoreLwrConfigFile',
    'lwrConfigFile',
    'layoutsDir',
    'locker',
    'lwc',
    'lwrVersion',
    'moduleProviders',
    'port',
    'basePath',
    'resourceProviders',
    'rootDir',
    'routes',
    'serverMode',
    'serverType',
    'templateEngine',
    'viewProviders',
    'viewTransformers',
]);
export const ASSET_DIR_ATTRIBUTE_KEYS = createKeys('assetDir', ['alias', 'dir', 'urlPath']);
export const ASSET_FILE_ATTRIBUTE_KEYS = createKeys('assetFile', ['alias', 'file', 'urlPath']);
export const LOCKER_ATTRIBUTE_KEYS = createKeys('locker', ['enabled', 'trustedComponents', 'clientOnly']);
export const ROUTE_ATTRIBUTE_KEYS = createKeys('routes', [
    'bootstrap',
    'subRoutes',
    'contentTemplate',
    'id',
    'cache',
    'layoutTemplate',
    'method',
    'path',
    'rootComponent',
    'routeHandler',
    'properties',
]);
export const ERROR_ROUTE_ATTRIBUTE_KEYS = createKeys('errorRoutes', [
    'bootstrap',
    'subRoutes',
    'contentTemplate',
    'id',
    'layoutTemplate',
    'rootComponent',
    'routeHandler',
    'status',
    'properties',
    'cache',
]);
export const BOOTSTRAP_ATTRIBUTE_KEYS = createKeys('bootstrap', [
    'autoBoot',
    'syntheticShadow',
    'workers',
    'services',
    'configAsSrc',
    'ssr',
]);
const SPECIFIER_REGEX = /^@?[\w-]+(\/[\w-]+)*$/;
function isNotEmptyString(node) {
    return node.type === 'string' && node.value.length > 0;
}
export const BASE_PATH_REGEX = /^(\/[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)+$/g;
export class ValidationContext {
    constructor(sourceText) {
        this.diagnostics = [];
        this.sourceText = sourceText;
    }
    getLocationFromNode(node) {
        return calculatePositionFromSource(this.sourceText, node);
    }
    assertIsObject(node, property) {
        if (node.type !== 'object') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'object', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsBoolean(node, property) {
        if (node && node.type !== 'boolean') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'boolean', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsArray(node, property) {
        if (node && node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsSpecifier(node, property) {
        if (node && (node.type !== 'string' || !SPECIFIER_REGEX.test(node.value))) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_SPECIFIER(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsPath(node, property) {
        if (node && (node.type !== 'string' || node.value[0] !== '/')) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_PATH(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsPort(node, property) {
        if (node && (node.type !== 'number' || node.value < 0 || node.value > 65353)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_PORT(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsServerType(node, property) {
        if (node && node.value !== 'express' && node.value !== 'koa' && node.value !== 'fs') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_SERVER_TYPE(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsStaticSiteGenerator(node, property) {
        if (node && node.type !== 'object') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_GENERATOR_CONFIG(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsMethod(node, property) {
        if (node && node.value !== 'get' && node.value !== 'post') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_METHOD(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsStatus(node, property) {
        if (node && node.value !== 404 && node.value !== 500) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_STATUS(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsEnvironment(node, property) {
        if (!node) {
            return;
        }
        let defaultProperty;
        let supportedProperty;
        if (node.type === 'object' && node.children?.length) {
            for (const child of node.children) {
                if (child.type === 'property' && child.children?.length) {
                    if (child.children[0].value === 'default' && isNotEmptyString(child.children[1])) {
                        defaultProperty = child;
                    }
                    if (child.children[0].value === 'supported') {
                        supportedProperty = child;
                    }
                }
            }
        }
        if (node.type !== 'object' || (supportedProperty && !defaultProperty)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_ENVIRONMENT(property),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsBasePath(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'string') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'string', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.value === '') {
            return;
        }
        else if (node.value.match(BASE_PATH_REGEX) === null) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_BASEPATH(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertNotEmptyString(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'string') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'string', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (!isNotEmptyString(node)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertNotEmptyArray(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (!node.children || node.children.length === 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.NON_EMPTY_ARRAY(property, '[]'),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertHasOneOrMore(node, property, childProps) {
        // At least one of the given child properties of node must exist
        if (!childProps.some((p) => findNodeAtLocation(node, [p]) !== undefined)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.MISSING_ONE_OF(property, childProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertHasOnlyOne(node, property, childProps) {
        // One and ONLY one of the given child properties of node must exist
        if (childProps.filter((p) => findNodeAtLocation(node, [p])).length !== 1) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.TOO_MANY(property, childProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertArrayOfStrings(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                if (!isNotEmptyString(n)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.NON_EMPTY_STRING(`${property}[${index}]`, n.value),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertArrayOfSpecifiers(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                if (n.type !== 'string' || !SPECIFIER_REGEX.test(n.value)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, n.value),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertArrayOfServices(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                if (n.type !== 'string' && n.type !== 'array') {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(`${property}[${index}]`, 'string or array', n.type),
                        location: this.getLocationFromNode(n),
                    });
                }
                if ((n.type === 'string' && n.value.length === 0) ||
                    (n.type === 'array' &&
                        n.children &&
                        (n.children.length !== 2 || !isNotEmptyString(n.children[0])))) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.INVALID_SERVICE(`${property}[${index}]`, n.value === undefined && n.children
                            ? `invalid Array[${n.children.length}]`
                            : n.value),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertUniqueIds(nodes, property) {
        const ids = nodes
            .map((n) => {
            const idNode = findNodeAtLocation(n, ['id']);
            return idNode ? idNode.value : undefined;
        })
            .filter((id) => id !== undefined);
        const dupeIds = ids.filter((id, index) => ids.indexOf(id) !== index);
        if (dupeIds.length > 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.DUPLICATE_IDS(property, dupeIds),
                location: this.getLocationFromNode(nodes[0]),
            });
        }
    }
    assertRequiredKeys(node, property, requiredPropertyKeys) {
        // All of the given properties must exist on the node
        const missingProps = requiredPropertyKeys.filter((p) => findNodeAtLocation(node, [p]) === undefined);
        if (missingProps.length > 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.MISSING_REQUIRED(property, missingProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertValidKeys(node, property, validPropertyKeys) {
        const { children } = node;
        if (!children) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_EMPTY_NODE(property),
                location: this.getLocationFromNode(node),
            });
            return;
        }
        else {
            for (const propertyNode of children) {
                if (propertyNode.type === 'property' && propertyNode.children) {
                    const [keyNode] = propertyNode.children;
                    const { type, value } = keyNode;
                    if (type === 'string' && !validPropertyKeys.includes(value)) {
                        this.diagnostics.push({
                            description: descriptions.CONFIG_PARSER.INVALID_PROPERTY(property, value),
                            location: this.getLocationFromNode(keyNode),
                        });
                    }
                }
            }
        }
    }
}
//# sourceMappingURL=app-config-context.js.map