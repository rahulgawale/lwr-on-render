import { parse, parseTree, printParseErrorCode, findNodeAtLocation as findNode, } from 'jsonc-parser';
import { createSingleDiagnosticError, descriptions, LwrConfigValidationError } from '@lwrjs/diagnostics';
import { ASSET_DIR_ATTRIBUTE_KEYS, ASSET_FILE_ATTRIBUTE_KEYS, BOOTSTRAP_ATTRIBUTE_KEYS, ERROR_ROUTE_ATTRIBUTE_KEYS, LOCKER_ATTRIBUTE_KEYS, ROOT_ATTRIBUTE_KEYS, ROUTE_ATTRIBUTE_KEYS, ValidationContext, } from './app-config-context.js';
import { calculatePositionFromSource } from './helpers.js';
export const SOURCE_BY_PHASE = {
    file: 'lwr.config.json',
    pre: 'argument passed to createServer',
    post: 'configuration hooks',
};
/**
 * Check config.routes[x].bootstrap:
 *      - services: optional array of specifiers
 *      - autoBoot: optional boolean
 *      - syntheticShadow: optional boolean
 *      - workers: optional map of string:specifier pairs
 *      - configAsSrc: optional boolean to include the client bootstrap config as src via in-lined
 */
function validateBootstrap(node, validationContext, propPrefix) {
    if (node) {
        validationContext.assertIsObject(node, 'bootstrap');
        validationContext.assertValidKeys(node, 'bootstrap', BOOTSTRAP_ATTRIBUTE_KEYS);
        validationContext.assertArrayOfSpecifiers(findNode(node, ['services']), `${propPrefix}.services`);
        validationContext.assertIsBoolean(findNode(node, ['autoBoot']), `${propPrefix}.autoBoot`);
        validationContext.assertIsBoolean(findNode(node, ['ssr']), `${propPrefix}.ssr`);
        validationContext.assertIsBoolean(findNode(node, ['configAsSrc']), `${propPrefix}.configAsSrc`);
        validationContext.assertIsBoolean(findNode(node, ['syntheticShadow']), `${propPrefix}.syntheticShadow`);
        // Each value in the worker map msut be a specifier
        const workers = findNode(node, ['workers']);
        if (workers && workers.children) {
            workers.children.forEach((w, index) => {
                if (w.children && w.children.length > 1) {
                    // get the value in a map entry: { "key": "value" }
                    validationContext.assertIsSpecifier(w.children[1], `${propPrefix}.workers[${index}]`);
                }
            });
        }
    }
}
/**
 * Check common properties of config.routes[] and config.errorRoutes[]:
 *      - id: required string
 *      - each route must have at least 1 of the following:
 *          - rootComponent
 *          - contentTemplate
 *          - routeHandler
 *      - rootComponent: optional specifier
 *      - contentTemplate: optional string
 *      - layoutTemplate: optional string
 *      - routeHandler: optional string
 *      - optional bootstrap...
 */
function validateRouteCommon(node, validationContext, propPrefix) {
    validationContext.assertHasOneOrMore(node, propPrefix, [
        'rootComponent',
        'contentTemplate',
        'routeHandler',
    ]);
    validationContext.assertNotEmptyString(findNode(node, ['id']), `${propPrefix}.id`);
    validationContext.assertIsSpecifier(findNode(node, ['rootComponent']), `${propPrefix}.rootComponent`);
    validationContext.assertNotEmptyString(findNode(node, ['contentTemplate']), `${propPrefix}.contentTemplate`);
    validationContext.assertNotEmptyString(findNode(node, ['layoutTemplate']), `${propPrefix}.layoutTemplate`);
    validationContext.assertNotEmptyString(findNode(node, ['routeHandler']), `${propPrefix}.routeHandler`);
    validateBootstrap(findNode(node, ['bootstrap']), validationContext, `${propPrefix}.bootstrap`);
}
/**
 * Check config.routes[]:
 *      - must have length > 0
 *      - path: required path segment string
 *      - method: optional 'get' | 'post'
 */
function validateRoutes(node, validationContext) {
    if (node) {
        validationContext.assertNotEmptyArray(node, 'routes');
        if (node.children) {
            node.children.forEach((n, index) => {
                const propPrefix = `routes[${index}]`;
                validationContext.assertIsObject(n, 'routes');
                validationContext.assertValidKeys(n, 'routes', ROUTE_ATTRIBUTE_KEYS);
                validationContext.assertRequiredKeys(n, propPrefix, ['id', 'path']);
                validationContext.assertIsPath(findNode(n, ['path']), `${propPrefix}.path`);
                validationContext.assertIsMethod(findNode(n, ['method']), `${propPrefix}.method`);
                validateRouteCommon(n, validationContext, propPrefix);
            });
        }
    }
}
/**
 * Check config.errorRoutes[]:
 *      - status: required 404 | 500
 */
function validateErrorRoutes(node, validationContext) {
    if (node) {
        validationContext.assertIsArray(node, 'errorRoutes');
        if (node.children) {
            node.children.forEach((n, index) => {
                const propPrefix = `errorRoutes[${index}]`;
                validationContext.assertIsObject(n, 'errorRoutes');
                validationContext.assertValidKeys(n, 'errorRoutes', ERROR_ROUTE_ATTRIBUTE_KEYS);
                validationContext.assertRequiredKeys(n, propPrefix, ['id', 'status']);
                validationContext.assertIsStatus(findNode(n, ['status']), `${propPrefix}.status`);
                validateRouteCommon(n, validationContext, propPrefix);
            });
        }
    }
}
/**
 * Check string config.asset OR
 * Check array config.assets[]:
 *      - must have length > 0
 *      - must have either dir or file, NOT both
 *      - dir: optional string
 *      - file: optional string
 *      - urlPath: required path segment string
 *      - alias: optional string
 */
function validateAssets(node, validationContext, preMerge) {
    if (node) {
        // assets can only be a string before the config is merged and normalized
        if (preMerge && node.type === 'string') {
            validationContext.assertNotEmptyString(node, 'assets');
        }
        else {
            validationContext.assertNotEmptyArray(node, 'assets');
            if (node.children) {
                node.children.forEach((n, index) => {
                    const dirNode = findNode(n, ['dir']);
                    const fileNode = findNode(n, ['file']);
                    if (dirNode?.type === 'string') {
                        validationContext.assertIsObject(n, 'assetDir');
                        validationContext.assertValidKeys(n, 'assetDir', ASSET_DIR_ATTRIBUTE_KEYS);
                    }
                    else if (fileNode?.type === 'string') {
                        validationContext.assertIsObject(n, 'assetFile');
                        validationContext.assertValidKeys(n, 'assetFile', ASSET_FILE_ATTRIBUTE_KEYS);
                    }
                    validationContext.assertRequiredKeys(n, `assets[${index}]`, ['urlPath']);
                    validationContext.assertHasOnlyOne(n, `assets[${index}]`, ['dir', 'file']);
                    validationContext.assertNotEmptyString(dirNode, `assets[${index}].dir`);
                    validationContext.assertNotEmptyString(fileNode, `assets[${index}].file`);
                    validationContext.assertIsPath(findNode(n, ['urlPath']), `assets[${index}].urlPath`);
                    validationContext.assertNotEmptyString(findNode(n, ['alias']), `assets[${index}].alias`);
                });
            }
        }
    }
}
/**
 * Check config.locker:
 *      - enabled: required boolean
 *      - trustedComponents: optional array of strings
 */
function validateLocker(node, validationContext) {
    if (node) {
        validationContext.assertIsObject(node, 'locker');
        validationContext.assertValidKeys(node, 'locker', LOCKER_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(node, 'locker', ['enabled']);
        validationContext.assertIsBoolean(findNode(node, ['enabled']), 'locker.enabled');
        validationContext.assertArrayOfStrings(findNode(node, ['trustedComponents']), 'locker.trustedComponents');
    }
}
/**
 * Check the normalized application configuration:
 *      - post-normalization, all properties are required
 *      - routes...
 *      - errorRoutes...
 *      - assets...
 *      - route and errorRoute ids must be unique
 *      - apiVersion: string
 *      - lwrVersion: string
 *      - amdLoader: specifier
 *      - esmLoader: specifier
 *      - port: number, 0 to 65353
 *      - serverMode: string
 *      - serverType: string
 *      - rootDir, cacheDir, contentDir, layoutsDir, globalDataDir: strings
 *      - hooks: array of strings
 *      - templateEngine: string
 *      - moduleProviders: array of services
 *      - viewProviders: array of services
 *      - resourceProviders: array of services
 *      - assetProviders: array of services
 *      - lwc.modules: array
 *      - basePath: valid subdomain part
 * Notes:
 *      - ignore `bundleConfig` because it is not yet RFCed
 *      - specifier strings are validated for type and shape only, NOT if they are resolvable
 */
function validateRoot(node, validationContext, preMerge) {
    validationContext.assertIsObject(node, 'root');
    validationContext.assertValidKeys(node, 'root', ROOT_ATTRIBUTE_KEYS);
    !preMerge && validationContext.assertRequiredKeys(node, 'root', ROOT_ATTRIBUTE_KEYS);
    const routes = findNode(node, ['routes']);
    const errorRoutes = findNode(node, ['errorRoutes']);
    validationContext.assertUniqueIds([...(routes?.children || []), ...(errorRoutes?.children || [])], 'routes');
    validateRoutes(routes, validationContext);
    validateErrorRoutes(errorRoutes, validationContext);
    validateAssets(findNode(node, ['assets']), validationContext, preMerge);
    validateLocker(findNode(node, ['locker']), validationContext);
    validationContext.assertNotEmptyString(findNode(node, ['apiVersion']), 'apiVersion');
    validationContext.assertNotEmptyString(findNode(node, ['lwrVersion']), 'lwrVersion');
    validationContext.assertIsSpecifier(findNode(node, ['amdLoader']), 'amdLoader');
    validationContext.assertIsSpecifier(findNode(node, ['esmLoader']), 'esmLoader');
    validationContext.assertIsPort(findNode(node, ['port']), 'port');
    validationContext.assertNotEmptyString(findNode(node, ['serverMode']), 'serverMode');
    validationContext.assertIsServerType(findNode(node, ['serverType']), 'serverType');
    validationContext.assertIsStaticSiteGenerator(findNode(node, ['staticSiteGenerator']), 'staticSiteGenerator');
    validationContext.assertNotEmptyString(findNode(node, ['rootDir']), 'rootDir');
    validationContext.assertNotEmptyString(findNode(node, ['cacheDir']), 'cacheDir');
    validationContext.assertNotEmptyString(findNode(node, ['contentDir']), 'contentDir');
    validationContext.assertNotEmptyString(findNode(node, ['layoutsDir']), 'layoutsDir');
    validationContext.assertNotEmptyString(findNode(node, ['globalDataDir']), 'globalDataDir');
    validationContext.assertArrayOfServices(findNode(node, ['hooks']), 'hooks');
    validationContext.assertNotEmptyString(findNode(node, ['templateEngine']), 'templateEngine');
    validationContext.assertArrayOfServices(findNode(node, ['moduleProviders']), 'moduleProviders');
    validationContext.assertArrayOfServices(findNode(node, ['viewProviders']), 'viewProviders');
    validationContext.assertArrayOfServices(findNode(node, ['resourceProviders']), 'resourceProviders');
    validationContext.assertArrayOfServices(findNode(node, ['assetProviders']), 'assetProviders');
    validationContext.assertNotEmptyArray(findNode(node, ['lwc', 'modules']), 'lwc.modules');
    validationContext.assertIsEnvironment(findNode(node, ['environment']), 'environment');
    validationContext.assertIsBasePath(findNode(node, ['basePath']), 'basePath');
}
export function validateLwrAppConfig(jsonSourceText, phase) {
    const errors = [];
    const preMerge = phase !== 'post'; // meaning the config has not yet been merged and normalized
    const rootNode = parseTree(jsonSourceText, errors);
    // Fatal error: JSON could not be parsed
    if (errors.length) {
        const { error, length, offset } = errors[0];
        const message = printParseErrorCode(error);
        const sourceLocation = calculatePositionFromSource(jsonSourceText, { length, offset });
        throw createSingleDiagnosticError({
            location: sourceLocation,
            description: descriptions.CONFIG_PARSER.INVALID_JSON(message),
        }, LwrConfigValidationError);
    }
    // Validate from root
    const validationContext = new ValidationContext(jsonSourceText);
    validateRoot(rootNode, validationContext, preMerge);
    // Throw an error with all diagnostics at once
    if (validationContext.diagnostics.length) {
        throw new LwrConfigValidationError(`Configuration validation errors in ${SOURCE_BY_PHASE[phase]}`, validationContext.diagnostics);
    }
    return parse(jsonSourceText);
}
//# sourceMappingURL=app-config.js.map