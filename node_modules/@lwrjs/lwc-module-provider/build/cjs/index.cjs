var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-module-provider/src/index.ts
__markAsModule(exports);
__export(exports, {
  default: () => src_default
});
var import_path = __toModule(require("path"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var import_cache = __toModule(require("./cache.cjs"));
var import_compiler = __toModule(require("./compiler.cjs"));
function getModuleEntryCacheKey(specifier, version) {
  return `${specifier}@${version}`;
}
var LwcModuleProvider = class {
  constructor(options = {}, {
    appEmitter,
    config: {modules, rootDir, cacheDir, environment},
    runtimeEnvironment: {watchFiles}
  }) {
    this.name = "lwc-module-provider";
    this.moduleSourceCache = new Map();
    this.watchedModuleContextMap = new Map();
    this.moduleEntryVersionCache = new Map();
    this.lwcCompiler = new import_compiler.LwcCompiler();
    this.inflightGetModuleJobs = new import_shared_utils.InflightTasks();
    this.inflightGetModuleEntryJobs = new import_shared_utils.InflightTasks();
    const {disableCaching} = options;
    this.emitter = appEmitter;
    this.modules = modules;
    this.rootDir = rootDir;
    this.watcher = watchFiles ? (0, import_utils.setUpWatcher)(this.onModuleChange.bind(this)) : void 0;
    this.moduleFsCacheEnabled = disableCaching !== void 0 ? !disableCaching : true;
    this.interchangeableModulesEnabled = !!environment?.default;
    if (this.moduleFsCacheEnabled) {
      const {lwcCacheDir, lwcCacheIndex} = (0, import_cache.setupModuleCache)(cacheDir);
      this.lwcCacheDir = lwcCacheDir;
      this.lwcCacheIndex = lwcCacheIndex;
    }
  }
  async onModuleChange(fileChanged) {
    const moduleContext = this.watchedModuleContextMap.get(fileChanged);
    if (!moduleContext) {
      throw new Error("We are observing a file we have not yet processed, this should not happen...");
    }
    const {moduleId, id} = moduleContext;
    this.moduleSourceCache.delete(id);
    const recompiledModule = await this.getModule(moduleId);
    if (recompiledModule) {
      this.emitter.notifyModuleSourceChanged(recompiledModule);
    }
  }
  async getModule(moduleId) {
    const id = (0, import_shared_utils.getSpecifier)(moduleId);
    return this.inflightGetModuleJobs.execute(id, () => {
      return this.createGetModuleJob(moduleId);
    });
  }
  async createGetModuleJob(moduleId) {
    const {watcher, watchedModuleContextMap, lwcCacheDir, lwcCacheIndex, moduleFsCacheEnabled} = this;
    import_shared_utils.logger.debug("createGetModuleJob", {moduleId});
    const moduleEntry = await this.getModuleEntry(moduleId);
    if (!moduleEntry) {
      return;
    }
    const moduleSource = await this.getModuleSource(moduleId, moduleEntry);
    const {id, namespace, name: rawName, originalSource} = moduleSource;
    const cacheConfig = {lwcCacheDir, lwcCacheIndex};
    let compiledModule = moduleFsCacheEnabled && (0, import_cache.getCompiledModuleCacheEntry)(moduleSource, cacheConfig);
    if (!compiledModule) {
      const [name] = rawName.split("#");
      const scopedStyles = moduleEntry.entry.endsWith(".css") && moduleEntry.specifier.endsWith("?scoped=true");
      import_shared_utils.logger.debug("createGetModuleJob:compile", {
        namespace,
        name,
        filename: moduleEntry.entry,
        scopedStyles
      });
      compiledModule = await this.lwcCompiler.compileFile(originalSource, {
        namespace,
        name,
        filename: moduleEntry.entry,
        scopedStyles
      });
      import_shared_utils.logger.verbose("createGetModuleJob:compile compiledModule", {
        namespace,
        name,
        filename: moduleEntry.entry,
        scopedStyles
      });
      if (moduleFsCacheEnabled) {
        (0, import_cache.addCompiledModuleCacheEntry)(moduleSource, compiledModule, cacheConfig);
      }
    }
    if (watcher && !watchedModuleContextMap.has(moduleEntry.entry)) {
      watcher.add(moduleEntry.entry);
      watchedModuleContextMap.set(moduleEntry.entry, {id, moduleId});
    }
    return {
      ...moduleSource,
      compiledSource: compiledModule.code,
      compiledMetadata: compiledModule.metadata
    };
  }
  async getModuleSource({name, namespace, specifier}, moduleEntry) {
    const {entry, version, id} = moduleEntry;
    const implicitLwc = (0, import_utils.isImplicitLwcImport)(entry, specifier);
    if (this.moduleSourceCache.has(id)) {
      return this.moduleSourceCache.get(id);
    }
    name = name || (0, import_shared_utils.explodeSpecifier)(specifier).name;
    const originalSource = implicitLwc ? import_utils.DEFAULT_IMPLICIT_DEP : (0, import_shared_utils.readFile)(entry);
    const ownHash = (0, import_shared_utils.hashContent)(originalSource);
    const moduleSource = {
      id,
      namespace,
      name,
      version,
      specifier,
      moduleEntry,
      ownHash,
      originalSource
    };
    this.moduleSourceCache.set(id, moduleSource);
    return moduleSource;
  }
  async getModuleEntry({
    specifier,
    importer,
    version
  }) {
    import_shared_utils.logger.debug("getModuleEntry", {specifier, importer, version});
    const versionId = version || importer;
    if (versionId) {
      const cacheKey2 = getModuleEntryCacheKey(specifier, versionId);
      if (this.moduleEntryVersionCache.has(cacheKey2)) {
        return this.moduleEntryVersionCache.get(cacheKey2);
      }
    }
    const cacheKey = `${specifier}@${version}@${importer}`;
    import_shared_utils.logger.debug("getModuleEntry:cacheKey", {cacheKey});
    return this.inflightGetModuleEntryJobs.execute(cacheKey, async () => {
      return this.createModuleEntry({specifier, importer, version});
    });
  }
  async createModuleEntry({
    specifier,
    importer,
    version
  }) {
    import_shared_utils.logger.debug("createModuleEntry", {specifier, importer, rootDir: this.rootDir, version});
    const [baseSpecifier, fileRelativePathRaw] = specifier.split("#");
    const fileRelativePath = fileRelativePathRaw?.split("?")[0];
    let moduleEntry;
    if (fileRelativePath && version) {
      const cacheKey2 = getModuleEntryCacheKey(specifier, version);
      moduleEntry = this.moduleEntryVersionCache.get(cacheKey2);
    }
    if (!moduleEntry) {
      try {
        import_shared_utils.logger.debug("createModuleEntry:resolveModuleSpecifier", {
          baseSpecifier,
          importer,
          rootDir: this.rootDir,
          modules: this.modules
        });
        const registryEntry = (0, import_utils.resolveModuleSpecifier)(baseSpecifier, importer || this.rootDir, this.modules);
        import_shared_utils.logger.debug("createModuleEntry:registryEntry", {registryEntry});
        moduleEntry = {
          id: getModuleEntryCacheKey(registryEntry.specifier, registryEntry.version),
          ...registryEntry
        };
        if (this.interchangeableModulesEnabled && moduleEntry.scope) {
          const metadata = (0, import_shared_utils.resolveCustomLWCMetadata)(moduleEntry.scope);
          if (metadata.interchangeable?.includes(moduleEntry.specifier)) {
            moduleEntry.interchangeable = true;
          }
        }
      } catch (e) {
        if (e.code !== "NO_LWC_MODULE_FOUND") {
          throw e;
        } else {
          import_shared_utils.logger.verbose(`LWC provider could not find the module ${specifier}`);
        }
      }
    }
    if (!moduleEntry) {
      return;
    }
    if (fileRelativePath) {
      const moduleEntryRoot = (0, import_path.dirname)(moduleEntry.entry);
      const filePath = (0, import_path.join)(moduleEntryRoot, fileRelativePath);
      moduleEntry = {
        ...moduleEntry,
        entry: (0, import_shared_utils.resolveFileExtension)(filePath),
        specifier
      };
    }
    const cacheKey = getModuleEntryCacheKey(specifier, moduleEntry.version);
    const finalModuleEntry = {...moduleEntry, id: cacheKey};
    this.moduleEntryVersionCache.set(cacheKey, finalModuleEntry);
    if (!version && importer) {
      const importerCacheKey = getModuleEntryCacheKey(specifier, importer);
      this.moduleEntryVersionCache.set(importerCacheKey, finalModuleEntry);
    }
    return finalModuleEntry;
  }
};
var src_default = LwcModuleProvider;
