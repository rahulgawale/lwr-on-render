import fs from 'fs';
import path from 'path';
import { readFile, debounce, createFileWatcher, logger } from '@lwrjs/shared-utils';
import { resolveModule } from '@lwc/module-resolver';
export const EXPLICIT_CONSTANT = '/* _implicit_dependency_ */';
export const DEFAULT_IMPLICIT_DEP = `${EXPLICIT_CONSTANT} export default void 0`;
export function resolveModuleSpecifier(specifier, importer, modules = []) {
    logger.debug('resolveModuleSpecifier', { specifier, importer, modules });
    const resolvedModule = resolveModule(specifier, importer, { modules });
    logger.debug('resolveModuleSpecifier:resolvedModule', { resolvedModule });
    const json = readFile(path.join(resolvedModule.scope, 'package.json'));
    const version = JSON.parse(json).version;
    return { ...resolvedModule, version };
}
// An implicit import is dependency that the LWC includes automatically to "auto-magically" bind JS, HTML and CSS
// Sometimes this file might not exist, in which case we need to provide a default
export function isImplicitLwcImport(entry, specifier) {
    const [, fileRelativePathQs] = specifier.split('#');
    const fileRelativePath = fileRelativePathQs?.split('?')[0]; // Remove queryString as LWC uses it for scope style
    // If is not relative or the file exists it's not an implicit import
    if (!fileRelativePath || fs.existsSync(entry)) {
        return false;
    }
    // The LWC compiler only does implicit imports for html or css
    const ext = path.extname(fileRelativePath);
    // Implicit scope style
    if (fileRelativePath.endsWith('.scoped.css')) {
        return true;
    }
    if (ext !== '.html' && ext !== '.css') {
        return false;
    }
    const parts = fileRelativePath.split('/');
    if (parts.length > 1) {
        // At this point this can only be implicit if
        // the importer has the same name besides the extension and exists
        // The importer extension is derived from the fact that implicitly:
        //  - js|ts must imports html
        //  - html must import css (which can also be implicit)
        if (ext === '.html') {
            const importerJsEntry = entry.replace('.html', '.js');
            const importerTsEntry = entry.replace('.html', '.ts');
            return fs.existsSync(importerJsEntry) || fs.existsSync(importerTsEntry);
        }
        else {
            const importerHtmlEntry = entry.replace('.css', '.html');
            const importerJsEntry = entry.replace('.css', '.js');
            const importerTsEntry = entry.replace('.css', '.ts');
            return (fs.existsSync(importerHtmlEntry) ||
                fs.existsSync(importerJsEntry) ||
                fs.existsSync(importerTsEntry));
        }
    }
    return true;
}
export function setUpWatcher(onModuleChange) {
    const watcher = createFileWatcher();
    watcher.on('change', debounce((file) => onModuleChange(file), 500));
    watcher.on('unlink', debounce((file) => onModuleChange(file), 500));
    watcher.on('add', (file) => logger.info(`Watching: ${file}`));
    return watcher;
}
//# sourceMappingURL=utils.js.map