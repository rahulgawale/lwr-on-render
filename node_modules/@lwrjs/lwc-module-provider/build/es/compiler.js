import { transformSync as babelTransform } from '@babel/core';
import { transformSync } from '@lwc/compiler';
import { EXPLICIT_CONSTANT } from './utils.js';
import { logger } from '@lwrjs/shared-utils';
const DEFAULT_BABEL_CONFIG = {
    babelrc: false,
    configFile: false,
    sourceMaps: true,
    parserOpts: {
        plugins: [['decorators', { decoratorsBeforeExport: true }]],
    },
};
export class LwcCompiler {
    // compileFile takes a html, css, typecsript, etc, and transforms it to a es6 module
    async compileFile(source, config) {
        const { name, namespace, filename, scopedStyles } = config;
        if (source.startsWith(EXPLICIT_CONSTANT)) {
            return {
                code: source,
                map: null,
                metadata: {},
            };
        }
        if (filename.endsWith('ts')) {
            const babelConfig = {
                ...DEFAULT_BABEL_CONFIG,
                presets: [['@babel/preset-typescript', { onlyRemoveTypeImports: false }]],
                filename,
            };
            logger.debug('babelTransform', { babelConfig });
            let result;
            try {
                result = babelTransform(source, babelConfig);
            }
            catch (error) {
                logger.debug('babelTransform error', error);
                throw error;
            }
            logger.verbose('babelTransform result', { result });
            if (!result || !result.code) {
                logger.debug('babelTransform invalid result', { result });
                throw new Error(`Error TS compiling ${filename}`);
            }
            source = result.code;
        }
        // HACK: This is to avoid running the LWC compiler on the HMR module until we dont allow swap methods
        if (namespace === 'lwr' && name === 'hmr') {
            return {
                code: source,
                map: null,
                metadata: {},
            };
        }
        const transformConfig = {
            namespace,
            name,
            experimentalDynamicComponent: {
                strictSpecifier: false,
            },
            scopedStyles,
        };
        logger.debug('transformSync', { filename, transformConfig });
        const compilerResult = transformSync(source, filename, {
            namespace,
            name,
            experimentalDynamicComponent: {
                strictSpecifier: false,
            },
            scopedStyles,
        });
        logger.verbose('transformSync result', { compilerResult });
        return {
            code: compilerResult.code,
            map: null,
            metadata: {},
        };
    }
}
//# sourceMappingURL=compiler.js.map