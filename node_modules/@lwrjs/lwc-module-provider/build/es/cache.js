import path from 'path';
import fs from 'fs';
export const DEFAULT_COMPILED_DIR = 'lwc_compiled_modules';
export const DEFAULT_CACHE_FOLDER = 'cache';
export const DEFAULT_CACHE_INDEX = `compiled.json`;
// eslint-disable-next-line no-useless-escape
const NORMALIZE_PATH_REGEX = /[@\/#\.\?<>\\:\*\|"]/gm;
/**
 * The module cache allow us to recover modules compiled across server restart
 * We store an index file and the compiler modules individually
 */
export function setupModuleCache(cacheDir) {
    const lwcCacheDir = path.join(cacheDir, `${DEFAULT_COMPILED_DIR}`);
    const lwcCacheIndexPath = path.join(lwcCacheDir, DEFAULT_CACHE_INDEX);
    fs.mkdirSync(`${lwcCacheDir}/${DEFAULT_CACHE_FOLDER}`, { recursive: true });
    if (!fs.existsSync(lwcCacheIndexPath)) {
        fs.writeFileSync(lwcCacheIndexPath, '[]');
        return { lwcCacheDir, lwcCacheIndex: new Map() };
    }
    else {
        const rawIndex = fs.readFileSync(lwcCacheIndexPath, 'utf-8');
        try {
            const cacheIndexJson = JSON.parse(rawIndex);
            return { lwcCacheDir, lwcCacheIndex: new Map(cacheIndexJson) };
        }
        catch (err) {
            const newErr = new Error('Invalid LWC Index: ' + rawIndex);
            if (err.stack) {
                newErr.stack += '\nCaused by: ' + err.stack;
            }
            throw newErr;
        }
    }
}
export function addCompiledModuleCacheEntry(moduleSource, compilerResult, { lwcCacheIndex, lwcCacheDir }) {
    const { specifier, version, ownHash } = moduleSource;
    const lwcCacheIndexPath = path.join(lwcCacheDir, DEFAULT_CACHE_INDEX);
    const cacheKey = `${specifier}@${version}`;
    // Normalize name for fs storage
    const normalizedSpecifier = specifier.replace(NORMALIZE_PATH_REGEX, '_');
    const normalizedVersion = version.replace(NORMALIZE_PATH_REGEX, '_');
    // Store module cached file
    const moduleFileName = `${normalizedSpecifier}_${normalizedVersion}.js`;
    const cachedModulePath = path.join(lwcCacheDir, DEFAULT_CACHE_FOLDER, moduleFileName);
    fs.writeFileSync(cachedModulePath, compilerResult.code);
    // Store module metadata
    const moduleMetaFileName = `${normalizedSpecifier}_${normalizedVersion}.meta.json`;
    const cachedMetaPath = path.join(lwcCacheDir, DEFAULT_CACHE_FOLDER, moduleMetaFileName);
    fs.writeFileSync(cachedMetaPath, JSON.stringify(compilerResult.metadata, null, '  '));
    // WIP: Store sourcemaps
    // Set new cache key in memory and persistent storage
    lwcCacheIndex.set(cacheKey, {
        ownHash,
        module: `./${DEFAULT_CACHE_FOLDER}/${moduleFileName}`,
        moduleMeta: `./${DEFAULT_CACHE_FOLDER}/${moduleMetaFileName}`,
    });
    fs.writeFileSync(lwcCacheIndexPath, JSON.stringify([...lwcCacheIndex], null, '  '));
}
export function getCompiledModuleCacheEntry({ specifier, version, ownHash }, { lwcCacheIndex, lwcCacheDir }) {
    const cacheKey = `${specifier}@${version}`;
    const cacheEntry = lwcCacheIndex.get(cacheKey);
    if (!cacheEntry) {
        return;
    }
    const cacheModulePath = path.join(lwcCacheDir, cacheEntry.module);
    const cacheMetaPath = path.join(lwcCacheDir, cacheEntry.moduleMeta);
    if (ownHash === cacheEntry.ownHash && fs.existsSync(cacheModulePath) && fs.existsSync(cacheMetaPath)) {
        return {
            code: fs.readFileSync(cacheModulePath, 'utf-8'),
            metadata: JSON.parse(fs.readFileSync(cacheMetaPath, 'utf-8')),
        };
    }
}
//# sourceMappingURL=cache.js.map