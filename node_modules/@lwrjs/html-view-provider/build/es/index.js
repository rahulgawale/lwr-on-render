import { getViewSourceFromFile, canResolveView, setupWatcher } from '@lwrjs/shared-utils';
import path from 'path';
import { render } from '@lwrjs/base-template-engine';
import grayMatter from 'gray-matter';
export default class HtmlViewProvider {
    constructor(pluginConfig, providerConfig) {
        this.cachedViews = new Map();
        this.contentDir = providerConfig.config.contentDir;
        this.layoutsDir = providerConfig.config.layoutsDir;
        this.emitter = providerConfig.appEmitter;
        this.name = 'lwr-html-view-provider';
        // Setup watcher
        const { runtimeEnvironment: { watchFiles }, } = providerConfig;
        if (watchFiles) {
            this.watcher = setupWatcher(this.onModuleChange.bind(this));
        }
    }
    async onModuleChange(fileChanged) {
        const cachedView = this.cachedViews.get(fileChanged);
        if (!cachedView) {
            throw new Error('We are observing a file we have not yet processed, this shouldnt happen...');
        }
        const compiledView = await this.getView(cachedView.viewId);
        if (!compiledView) {
            throw new Error('Unable to get compiledView');
        }
        this.emitter.notifyViewSourceChanged(compiledView);
    }
    // -- Public API --------------------------------------------------------------------
    async initialize() {
        return;
    }
    async getView(viewId) {
        // This View Provider can't handle SPAs
        if (viewId.rootComponent) {
            return;
        }
        // Ensure source file is resolvable and in HTML format
        const sourcePath = viewId.contentTemplate;
        if (!sourcePath || !canResolveView(sourcePath, 'html')) {
            return;
        }
        // Retrieve the file contents and create the Compiled View
        const viewSource = getViewSourceFromFile(sourcePath);
        const { content, data } = grayMatter(viewSource.originalSource);
        const { layoutTemplate, ...nonLwrManagedMetadata } = data;
        const compiledView = {
            ...viewSource,
            viewId,
            layoutTemplate,
            properties: {
                ...nonLwrManagedMetadata,
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            render: async (context) => {
                return {
                    renderedView: render(content, context || {}),
                };
            },
        };
        // Watch for changes
        const fullPath = path.resolve(sourcePath);
        if (this.watcher && !this.cachedViews.has(sourcePath)) {
            this.cachedViews.set(fullPath, { compiledView, viewId });
            this.watcher.add(fullPath);
        }
        return compiledView;
    }
}
//# sourceMappingURL=index.js.map