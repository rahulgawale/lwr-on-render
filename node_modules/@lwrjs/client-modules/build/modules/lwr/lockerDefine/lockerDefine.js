/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
var _URLCtor$prototype$LWS;

const {
  apply: ReflectApply$LWS$1,
  construct: ReflectConstruct$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  deleteProperty: ReflectDeleteProperty$LWS$1,
  get: ReflectGet$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS$1,
  has: ReflectHas$LWS,
  ownKeys: ReflectOwnKeys$LWS$1,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS$1
} = Reflect;
const ObjectCtor$LWS$1 = Object;
const {
  assign: ObjectAssign$LWS$1,
  freeze: ObjectFreeze$LWS$1,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS$1
} = ObjectCtor$LWS$1;
const {
  hasOwn: OriginalObjectHasOwn$LWS$1
} = ObjectCtor$LWS$1;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS$1,
  __lookupSetter__: ObjectProtoLookupSetter$LWS$1,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS$1
} = ObjectProto$LWS$1;
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS$1;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

const ObjectHasOwn$LWS$1 = typeof OriginalObjectHasOwn$LWS$1 === 'function' ? OriginalObjectHasOwn$LWS$1 :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS$1(ObjectProtoHasOwnProperty$LWS$1, object$LWS, [key$LWS]);
};

function ObjectLookupOwnGetter$LWS$1(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupGetter$LWS$1, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupSetter$LWS$1, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
}

const SymbolCtor$LWS = Symbol;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS$1,
  toStringTag: SymbolToStringTag$LWS$1,
  unscopables: SymbolUnscopables$LWS$1
} = SymbolCtor$LWS;
const {
  toString: SymbolProtoToString$LWS,
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const ArrayCtor$LWS$1 = Array;
const {
  prototype: ArrayProto$LWS$1
} = ArrayCtor$LWS$1;
const {
  at: ArrayProtoAt$LWS$1,
  concat: ArrayProtoConcat$LWS$1,
  copyWithin: ArrayProtoCopyWithin$LWS$1,
  entries: ArrayProtoEntries$LWS$1,
  every: ArrayProtoEvery$LWS$1,
  fill: ArrayProtoFill$LWS$1,
  find: ArrayProtoFind$LWS$1,
  findIndex: ArrayProtoFindIndex$LWS$1,
  flat: ArrayProtoFlat$LWS$1,
  flatMap: ArrayProtoFlatMap$LWS$1,
  forEach: ArrayProtoForEach$LWS$1,
  keys: ArrayProtoKeys$LWS$1,
  lastIndexOf: ArrayProtoLastIndexOf$LWS$1,
  map: ArrayProtoMap$LWS$1,
  pop: ArrayProtoPop$LWS$1,
  reduce: ArrayProtoReduce$LWS$1,
  reduceRight: ArrayProtoReduceRight$LWS$1,
  reverse: ArrayProtoReverse$LWS$1,
  some: ArrayProtoSome$LWS$1,
  splice: ArrayProtoSplice$LWS$1,
  toLocaleString: ArrayProtoToLocaleString$LWS$1,
  toString: ArrayProtoToString$LWS$1,
  values: ArrayProtoValues$LWS$1,
  [SymbolIterator$LWS$1]: ArrayProtoSymbolIterator$LWS$1
} = ArrayProto$LWS$1;
const ArrayUnscopables$LWS$1 = ObjectFreeze$LWS$1(ObjectAssign$LWS$1({
  __proto__: null
}, ArrayProto$LWS$1[SymbolUnscopables$LWS$1]));
const {
  filter: ArrayProtoFilter$LWS$1,
  includes: ArrayProtoIncludes$LWS$1,
  indexOf: ArrayProtoIndexOf$LWS$1,
  join: ArrayProtoJoin$LWS$1,
  push: ArrayProtoPush$LWS$1,
  shift: ArrayProtoShift$LWS$1,
  slice: ArrayProtoSlice$LWS$1,
  sort: ArrayProtoSort$LWS$1,
  unshift: ArrayProtoUnshift$LWS$1
} = ArrayProto$LWS$1;
const {
  isArray: ArrayIsArray$LWS$1
} = ArrayCtor$LWS$1;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);

  for (let i$LWS = 0, {
    length: length$LWS
  } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];

    if (ArrayIsArray$LWS$1(value$LWS)) {
      ReflectApply$LWS$1(ArrayProtoPush$LWS$1, result$LWS, value$LWS);
    } else {
      result$LWS[result$LWS.length] = value$LWS;
    }
  }

  return result$LWS;
}

function toSafeArray$LWS$1(array$LWS) {
  ReflectSetPrototypeOf$LWS$1(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS$1;
  array$LWS.concat = ArrayProtoConcat$LWS$1; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS$1;
  array$LWS.entries = ArrayProtoEntries$LWS$1;
  array$LWS.every = ArrayProtoEvery$LWS$1;
  array$LWS.fill = ArrayProtoFill$LWS$1;
  array$LWS.filter = ArrayProtoFilter$LWS$1;
  array$LWS.find = ArrayProtoFind$LWS$1;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS$1;
  array$LWS.flat = ArrayProtoFlat$LWS$1;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS$1;
  array$LWS.forEach = ArrayProtoForEach$LWS$1;
  array$LWS.includes = ArrayProtoIncludes$LWS$1;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS$1;
  array$LWS.join = ArrayProtoJoin$LWS$1;
  array$LWS.keys = ArrayProtoKeys$LWS$1;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS$1;
  array$LWS.map = ArrayProtoMap$LWS$1;
  array$LWS.pop = ArrayProtoPop$LWS$1;
  array$LWS.push = ArrayProtoPush$LWS$1;
  array$LWS.reduce = ArrayProtoReduce$LWS$1;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS$1;
  array$LWS.reverse = ArrayProtoReverse$LWS$1;
  array$LWS.shift = ArrayProtoShift$LWS$1;
  array$LWS.slice = ArrayProtoSlice$LWS$1;
  array$LWS.some = ArrayProtoSome$LWS$1;
  array$LWS.sort = ArrayProtoSort$LWS$1;
  array$LWS.splice = ArrayProtoSplice$LWS$1;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS$1;
  array$LWS.toString = ArrayProtoToString$LWS$1;
  array$LWS.unshift = ArrayProtoUnshift$LWS$1;
  array$LWS.values = ArrayProtoValues$LWS$1;
  array$LWS[SymbolIterator$LWS$1] = ArrayProtoSymbolIterator$LWS$1;
  array$LWS[SymbolUnscopables$LWS$1] = ArrayUnscopables$LWS$1;
  ReflectSetPrototypeOf$LWS$1(array$LWS, ArrayProto$LWS$1);
  return array$LWS;
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(ArrayBufferCtor$LWS.prototype, 'byteLength'); // https://caniuse.com/bigint

const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf :
/* istanbul ignore next: currently unreachable via tests */
undefined;
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;
const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore next

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const CHAR_ELLIPSIS$LWS = '\u2026';
const CHAR_QUOTE_DOUBLE$LWS = '"';
const CHAR_QUOTE_SINGLE$LWS = "'";
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  now: DateNow$LWS
} = DateCtor$LWS;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  bind: FunctionProtoBind$LWS,
  toString: FunctionProtoToString$LWS
} = Function.prototype;

function alwaysNull$LWS() {
  return null;
}

function noop$LWS$1() {// No operation performed.
}

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS$1]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS$1]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(MapProto$LWS, 'size');

function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS$1(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS$1] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS$1] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS$1(map$LWS, MapProto$LWS);
  return map$LWS;
}

const NumberCtor$LWS = Number;
const {
  prototype: NumberProto$LWS
} = NumberCtor$LWS;
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS
} = NumberCtor$LWS;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberProto$LWS;
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  endsWith: StringProtoEndsWith$LWS,
  includes: StringProtoIncludes$LWS,
  indexOf: StringProtoIndexOf$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const QUOTE_CHAR_REG_EXP_MAP$LWS = {
  __proto__: null,
  [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
  [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
};
const URLCtor$LWS = typeof URL === 'function' ? URL :
/* istanbul ignore next: unreachable in test env */
undefined; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

const URLProtoToString$LWS = URLCtor$LWS == null ? void 0 : (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString; // To extract the function body start the match from the beginning of the
// source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
// matches everything including newlines where as `.` matches everything except
// newlines. Next, continue matching past the opening left curly bracket of the
// function and beyond optional whitespace and newline. Finally, capture the
// function body up to, but not including, optional newline and whitespace by
// the closing right curly bracket at the end of the source code. The alternate
// pattern matches arrow functions without brackets.

const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (length$LWS) {
    const upper$LWS = ReflectApply$LWS$1(StringProtoToUpperCase$LWS, string$LWS[0], []);
    return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS, string$LWS, [1]);
  }

  return '';
}

function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
  return quoteChar$LWS + ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [QUOTE_CHAR_REG_EXP_MAP$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
}

function extractFunctionBodySource$LWS(func$LWS) {
  var _ref$LWS, _match$$LWS;

  const source$LWS = ReflectApply$LWS$1(FunctionProtoToString$LWS, func$LWS, []);
  const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]); // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

  return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
} // Use `toString()` to coerce values using the default string concatenation
// operation.


function toString$LWS(value$LWS) {
  return typeof value$LWS === 'string' ? value$LWS : // Attempt to coerce `value` to a string with the ToString operation.
  // Section 7.1.17 ToString ( argument )
  // https://tc39.es/ecma262/#sec-tostring
  `${value$LWS}`;
} // Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.


function toSafeTemplateStringValue$LWS(value$LWS) {
  if (typeof value$LWS === 'string') {
    return value$LWS;
  }

  try {
    if (typeof value$LWS === 'function') {
      return ReflectApply$LWS$1(FunctionProtoToString$LWS, value$LWS, []);
    }

    if (typeof value$LWS === 'object' && value$LWS !== null) {
      if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
        return ReflectApply$LWS$1(URLProtoToString$LWS, value$LWS, []);
      }

      const result$LWS = ReflectApply$LWS$1(ObjectProtoToString$LWS, value$LWS, []);
      return result$LWS === TO_STRING_BRAND_SYMBOL$LWS ? ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
    }

    if (typeof value$LWS === 'symbol') {
      return ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []);
    } // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value


    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}

  return '[object Unknown]';
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  exec: RegExpProtoExec$LWS,
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS$1(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  clear: SetProtoClear$LWS,
  delete: SetProtoDelete$LWS,
  entries: SetProtoEntries$LWS,
  forEach: SetProtoForEach$LWS,
  has: SetProtoHas$LWS,
  keys: SetProtoKeys$LWS,
  [SymbolIterator$LWS$1]: SetProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS$1]: SetProtoSymbolToStringTag$LWS
} = SetProto$LWS;
const {
  add: SetProtoAdd$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(SetProto$LWS, 'size');

function toSafeSet$LWS(set$LWS) {
  ReflectSetPrototypeOf$LWS$1(set$LWS, null);
  set$LWS.add = SetProtoAdd$LWS;
  set$LWS.clear = SetProtoClear$LWS;
  set$LWS.delete = SetProtoDelete$LWS;
  set$LWS.entries = SetProtoEntries$LWS;
  set$LWS.forEach = SetProtoForEach$LWS;
  set$LWS.has = SetProtoHas$LWS;
  set$LWS.keys = SetProtoKeys$LWS;
  ReflectDefineProperty$LWS(set$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: SetProtoSizeGetter$LWS,
    set: undefined
  });
  set$LWS.values = SetProtoValues$LWS;
  set$LWS[SymbolIterator$LWS$1] = SetProtoSymbolIterator$LWS;
  set$LWS[SymbolToStringTag$LWS$1] = SetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS$1(set$LWS, SetProto$LWS);
  return set$LWS;
}

const WeakMapCtor$LWS$1 = WeakMap;
const {
  prototype: WeakMapProto$LWS$1
} = WeakMapCtor$LWS$1;
const {
  has: WeakMapProtoHas$LWS$1
} = WeakMapProto$LWS$1;
const {
  delete: WeakMapProtoDelete$LWS$1,
  get: WeakMapProtoGet$LWS$1,
  set: WeakMapProtoSet$LWS$1,
  [SymbolToStringTag$LWS$1]: WeakMapProtoSymbolToStringTag$LWS$1
} = WeakMapProto$LWS$1;

function toSafeWeakMap$LWS$1(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS$1(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS$1;
  weakMap$LWS.get = WeakMapProtoGet$LWS$1;
  weakMap$LWS.has = WeakMapProtoHas$LWS$1;
  weakMap$LWS.set = WeakMapProtoSet$LWS$1;
  weakMap$LWS[SymbolToStringTag$LWS$1] = WeakMapProtoSymbolToStringTag$LWS$1;
  ReflectSetPrototypeOf$LWS$1(weakMap$LWS, WeakMapProto$LWS$1);
  return weakMap$LWS;
}

const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS$1]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;

function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS$1(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS$1] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS$1(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol; // Regular expressions from Acorn:
//     acorn/src/parseutil.js
//     acorn/src/whitespace.js

const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;

function getBrandByTrialAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  //
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value$LWS) {
      ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused3$LWS) {} // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.


  try {
    if ('toLocaleDateString' in value$LWS) {
      ReflectApply$LWS$1(DateProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_DATE$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused4$LWS) {} // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).


  try {
    if ('get' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS$1(MapProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused5$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.


  try {
    if (ObjectHasOwn$LWS$1(value$LWS, 'lastIndex')) {
      ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_REG_EXP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused6$LWS) {} // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).


  try {
    if ('add' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS$1(SetProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused7$LWS) {} // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).


  try {
    if ('get' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS$1(WeakMapProtoHas$LWS$1, value$LWS, []);
      return TO_STRING_BRAND_WEAK_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused8$LWS) {} // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).


  try {
    if ('add' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS$1(WeakSetProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused9$LWS) {} // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.


  try {
    if ('toPrecision' in value$LWS) {
      ReflectApply$LWS$1(NumberProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_NUMBER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {} // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.


  try {
    if (ObjectHasOwn$LWS$1(value$LWS, 'length')) {
      ReflectApply$LWS$1(StringProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_STRING$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused11$LWS) {} // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.


  try {
    if ('description' in value$LWS) {
      ReflectApply$LWS$1(SymbolProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_SYMBOL$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused12$LWS) {} // istanbul ignore else: All platforms that LWS runs tests in support BigInt


  if (SUPPORTS_BIG_INT$LWS) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS$1(BigIntProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BIG_INT$LWS; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  try {
    // Section 20.3.3 Properties of the Boolean Prototype Object
    // https://tc39.es/ecma262/#thisbooleanvalue
    // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    //     a. Let b be value.[[BooleanData]].
    //     b. Assert: Type(b) is Boolean.
    ReflectApply$LWS$1(BooleanProtoValueOf$LWS, value$LWS, []);
    return TO_STRING_BRAND_BOOLEAN$LWS; // eslint-disable-next-line no-empty
  } catch (_unused14$LWS) {} // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS$1(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS$1(ObjectProtoToString$LWS, value$LWS, []);
}

typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : ReflectApply$LWS$1(FunctionProtoBind$LWS, performance.now, [performance]); // Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js

function indexOfPragma$LWS(source$LWS, pragma$LWS) {
  let pos$LWS = 0; // eslint-disable-next-line no-constant-condition

  while (true) {
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    const stringLiteralMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS$1(StringProtoSlice$LWS, source$LWS, [pos$LWS])]);

    if (stringLiteralMatch$LWS === null) {
      return -1;
    }

    if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
      const spaceAfterMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
      const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
      const nextChar$LWS = source$LWS[end$LWS];

      if (nextChar$LWS === ';' || nextChar$LWS === '}') {
        return pos$LWS;
      }

      const indexAfterNext$LWS = end$LWS + 1;

      if (ReflectApply$LWS$1(RegExpProtoTest$LWS, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS$1(RegExpProtoTest$LWS, expressionCharRegExp$LWS, [nextChar$LWS]))) {
        return pos$LWS;
      }
    }

    pos$LWS += stringLiteralMatch$LWS[0].length; // Skip semicolon, if any.

    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;

    if (source$LWS[pos$LWS] === ';') {
      pos$LWS += 1;
    }
  }
}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }

  return false;
}

const SEEN_OBJECTS_MAP$LWS = toSafeMap$LWS(new MapCtor$LWS());

function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS$1(getNearMembraneSerializedValue$LWS(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = ReflectApply$LWS$1(MapProtoEntries$LWS, map$LWS, []); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS$1(MapProtoSet$LWS, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneSerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = ReflectApply$LWS$1(SetProtoValues$LWS, set$LWS, []); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS$1(SetProtoAdd$LWS, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ReflectApply$LWS$1(ArrayProtoShift$LWS$1, queue$LWS, []); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = SEEN_OBJECTS_MAP$LWS.get(originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = getBrand$LWS(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS$1(originalValue$LWS);

          if (proto$LWS === ObjectProto$LWS$1 || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = ArrayCtor$LWS$1(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!isNearMembrane$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN$LWS: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER$LWS: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT$LWS: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING$LWS:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused15$LWS) {}

  SEEN_OBJECTS_MAP$LWS.clear();
  return result$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS$1(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS$1(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
} // Used by '@locker/near-membrane-base'

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const trackedLiveTargets$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS()); // This is used by packages/locker-core-engine/src/LockerFilter.js

const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS('@@lockerLiveValue');

function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0
/* TargetTraits.None */
) {
  if (targetTraits$LWS & 1
  /* TargetTraits.IsArray */
  || targetTraits$LWS & 2
  /* TargetTraits.IsArrayBufferView */
  || targetTraits$LWS & 64
  /* TargetTraits.Revoked */
  || target$LWS === null || target$LWS === undefined || target$LWS === ObjectProto$LWS$1 || target$LWS === RegExpProto$LWS) {
    return false;
  }

  if (typeof target$LWS === 'function') {
    try {
      return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS); // eslint-disable-next-line no-empty
    } catch (_unused16$LWS) {}

    return false;
  }

  if (typeof target$LWS === 'object') {
    try {
      if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused17$LWS) {}

    let constructor$LWS;

    try {
      ({
        constructor: constructor$LWS
      } = target$LWS);

      if (constructor$LWS === ObjectCtor$LWS$1) {
        // If the constructor, own or inherited, points to `Object`
        // then `target` is not likely a prototype object.
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused18$LWS) {}

    try {
      if (ReflectGetPrototypeOf$LWS$1(target$LWS) === null && ( // Ensure `target` is not an `Object.prototype` from an iframe.
      typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== target$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused19$LWS) {}

    if (targetTraits$LWS === 0
    /* TargetTraits.None */
    ) {
      try {
        if (ArrayIsArray$LWS$1(target$LWS)) {
          return true;
        }
      } catch (_unused20$LWS) {
        // The target is a revoked proxy.
        return false;
      }

      if (ArrayBufferIsView$LWS(target$LWS)) {
        return true;
      }
    } // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.


    try {
      if (ObjectHasOwn$LWS$1(target$LWS, 'lastIndex')) {
        ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, target$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused21$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).


    try {
      if ('byteLength' in target$LWS) {
        ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused22$LWS) {}
  }

  return false;
}

function trackTargetAsLive$LWS(target$LWS) {
  trackedLiveTargets$LWS.add(target$LWS);
  return target$LWS;
}

const {
  min: MathMin$LWS
} = Math;
const PREFIX_HEAD$LWS = 'LSKey-';
const PREFIX_TAIL$LWS = '$';

function getNamespacePrefix$LWS(namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
}

function isNamespacePrefixed$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [`${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`]);
}

function prefixNamespace$LWS(key$LWS, namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}${key$LWS}`;
}

function unprefixNamespace$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const prefix$LWS = `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
    return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [prefix$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS, key$LWS, [prefix$LWS.length]) : key$LWS;
  }

  return '';
}

const PromiseCtor$LWS = Promise;
const {
  catch: PromiseProtoCatch$LWS,
  then: PromiseProtoThen$LWS
} = PromiseCtor$LWS.prototype;
const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
const ProxyCtor$LWS = Proxy;
const {
  revocable: ProxyRevocable$LWS
} = ProxyCtor$LWS;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}
/*! version: 0.17.9 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
const selfDocument$LWS = document;
const {
  prototype: DocumentProto$LWS$1
} = Document; // Used by '@locker/near-membrane/dom'.
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS$1,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS$1;
const DocumentProtoBodyGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS$1, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'implementation');
const {
  prototype: ElementProto$LWS
} = Element; // Used by '@locker/near-membrane-dom'.
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  setAttribute: ElementProtoSetAttribute$LWS$1,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, 'namespaceURI');
const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS$1
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS$1,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS$1;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'firstChild'); // Used by '@locker/near-membrane-dom'.

ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'lastChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'ownerDocument');
const selfWindow$LWS = window;
const {
  setTimeout: WindowSetTimeout$LWS
} = selfWindow$LWS; // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  setInterval: WindowSetInterval$LWS
} = selfWindow$LWS;

const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = selfWindow$LWS; // istanbul ignore else

  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  } // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = PromiseResolve$LWS();
    promise$LWS = ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
    ReflectApply$LWS$1(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();

const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(selfWindow$LWS, 'document');
const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(selfWindow$LWS, 'frameElement');
const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(selfWindow$LWS, 'length');
const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS$1(selfWindow$LWS, 'location');

function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS$1(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      ReflectApply$LWS$1(WindowLocationGetter$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
}
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class Validator$LWS {
  constructor(globalObject$LWS, document$LWS = globalObject$LWS.document) {
    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, this._document, []);

    const {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    } = globalObject$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template']),
      right: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template'])
    };
  }

}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;

  if (ReflectApply$LWS$1(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}

const selfValidator$LWS = new Validator$LWS(selfWindow$LWS, selfDocument$LWS);
const documentToValidatorMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[selfDocument$LWS, selfValidator$LWS]]));

function getValidator$LWS(globalObject$LWS, document$LWS = globalObject$LWS == null ? void 0 : globalObject$LWS.document) {
  // Fast path validator lookup for top level window.
  if (globalObject$LWS === undefined || globalObject$LWS === selfWindow$LWS) {
    return selfValidator$LWS;
  } // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.


  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(globalObject$LWS, document$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }

  return validator$LWS;
}

const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'type');
const {
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS$1(DOMTokenList.prototype, 'value');
const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS$1(Event.prototype, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;
const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElement.prototype, 'protocol');
const {
  prototype: HTMLElementProto$LWS
} = HTMLElement;
const HTMLElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElementProto$LWS, 'dataset'); // Used by '@locker/near-membrane-dom'.

ObjectLookupOwnGetter$LWS$1(HTMLElementProto$LWS, 'style');
const {
  prototype: HTMLIFrameElementProto$LWS
} = HTMLIFrameElement; // Used by '@locker/near-membrane-dom'.

ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, 'contentWindow');
const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'src');
ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS$1(Request.prototype, 'url');
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS(`(?:^|\\W)${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
const topReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
const topWebpackReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');
const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExpCtor$LWS(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function applyUncompiledTransformations$LWS(sourceText$LWS) {
  const isWebpack$LWS = ReflectApply$LWS$1(RegExpProtoTest$LWS, webpackRequireNameRegExp$LWS, [sourceText$LWS]);
  let locationRegExp$LWS, topRegExp$LWS;

  if (isWebpack$LWS) {
    locationRegExp$LWS = locationReferencesWithWebPackRegExp$LWS;
    topRegExp$LWS = topWebpackReferencesRegExp$LWS;
  } else {
    locationRegExp$LWS = locationReferencesRegExp$LWS;
    topRegExp$LWS = topReferencesRegExp$LWS;
  }

  const transforms$LWS = []; // Input `sourceText` is non-compiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  const locationReplacer$LWS = (_match$LWS, assignmentOperator$LWS) => {
    transforms$LWS[0] = UNCOMPILED_LOCATION_NAME$LWS;
    return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
  };

  sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, locationReplacer$LWS]); // In non-compiled source text `window.top` is null when evaluated in a sandbox.
  // We perform a naive transformation to replace references of `window.top` to use
  // our internal sandbox helpers.

  const {
    length: length$LWS
  } = transforms$LWS;

  const topReplacer$LWS = () => {
    transforms$LWS[length$LWS] = UNCOMPILED_TOP_NAME$LWS;
    return UNCOMPILED_TOP_NAME$LWS;
  };

  sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, topReplacer$LWS]);
  return {
    code: sourceText$LWS,
    transforms: transforms$LWS
  };
}

function destructureHelpers$LWS(helpers$LWS) {
  const helperNamesCommaSeparated$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, helpers$LWS, [',']);
  return `const {${helperNamesCommaSeparated$LWS}} = ${SANDBOX_EVAL_CONTEXT_NAME$LWS};`;
}

function transformUncompiledSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }

  const {
    code: code$LWS,
    transforms: transforms$LWS
  } = applyUncompiledTransformations$LWS(sourceText$LWS);

  if (transforms$LWS.length === 0) {
    return sourceText$LWS;
  }

  const destructureSandboxEvalContextSnippet$LWS = destructureHelpers$LWS(transforms$LWS);
  const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, 'use strict');

  if (pragmaIndex$LWS === -1) {
    return `${destructureSandboxEvalContextSnippet$LWS}${code$LWS}`;
  } // The "use strict" pragma, including quotes, is 12 characters long.


  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12; // istanbul ignore else

  if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }

  return ReflectApply$LWS$1(StringProtoSlice$LWS, code$LWS, [0, afterPragmaIndex$LWS]) + destructureSandboxEvalContextSnippet$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS, code$LWS, [afterPragmaIndex$LWS]);
}

const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement.prototype, 'dataset');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL; // This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.js containing the directive and subsequently being
// ignored.
// istanbul ignore next

const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
/*! version: 0.17.9 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const URL_SCHEMES_LIST$LWS$1 = toSafeArray$LWS$1(['http:', 'https:']);
ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['a']); // @TODO W-7302311 Make paths and domains configurable
/*! version: 0.17.9 */

/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}
/* Add properties to a lookup table */

function addToSet(set, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;

  while (l--) {
    var element = array[l];

    if (typeof element === 'string') {
      var lcElement = transformCaseFunc(element);

      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}
/* Shallow clone an object */

function clone(object) {
  var newObject = create(null);
  var property;

  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */

function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);

    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.

var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.

var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
var text = freeze(['#text']);

var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */


var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  } // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.


  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';

  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html) {
        return html;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };
  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */


  DOMPurify.version = '2.4.0';
  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */

  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }

  var originalDocument = window.document;
  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.

  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');

    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};

  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */

  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
      ERB_EXPR$1 = ERB_EXPR,
      DATA_ATTR$1 = DATA_ATTR,
      ARIA_ATTR$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
  /* Allowed attribute names */

  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */

  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

  var FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

  var FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */

  var ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */

  var ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */

  var ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */

  var SAFE_FOR_TEMPLATES = false;
  /* Decide if document with <html>... should be returned */

  var WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */

  var SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */

  var FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */

  var RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */

  var RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */

  var RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */

  var SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (7.3.3)
   *   - DOM Tree Accessors (3.1.5)
   *   - Form Element Parent-Child Relations (4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
   *   - HTMLCollection (4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */

  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */

  var KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */

  var IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */

  var USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */

  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */

  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */

  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */

  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  /* Parsing of strict XHTML documents */

  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc;
  /* Keep a reference to config to pass to hooks */

  var CONFIG = null;
  /* Ideally, do not touch anything below this line */

  /* ______________________________________________ */

  var formElement = document.createElement('form');

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity


  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */


    if (!cfg || _typeof(cfg) !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */


    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
      return x;
    } : stringToLowerCase;
    /* Set configuration parameters */

    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
    cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
    cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

    RETURN_DOM = cfg.RETURN_DOM || false; // Default false

    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

    FORCE_BODY = cfg.FORCE_BODY || false; // Default false

    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

    IN_PLACE = cfg.IN_PLACE || false; // Default false

    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */


    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
      ALLOWED_ATTR = [];

      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */


    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */


    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    } // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.


    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.

  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */

  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */

  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.

    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      } // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.


      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      } // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.


      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      } // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points


      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      } // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.


      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      } // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace


      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    } // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.


    return false;
  };
  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */


  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });

    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };
  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */


  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */


  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc;
    var leadingWhitespace;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */

    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */


    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);

      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {// Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */


    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */


  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */


  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
  };
  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */


  var _isNode = function _isNode(object) {
    return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };
  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */


  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */


  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content;
    /* Execute a hook if present */

    _executeHook('beforeSanitizeElements', currentNode, null);
    /* Check if element is clobbered or can clobber */


    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Check if tagname contains Unicode */


    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Now let's check the element's type and name */


    var tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */

    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */


    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Mitigate a problem with templates inside select */


    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Remove element if anything forbids its presence */


    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }
      /* Keep content except for bad-listed elements */


      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);

      return true;
    }
    /* Check whether element has a valid namespace */


    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);

      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Sanitize element content to be template-safe */


    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
      content = stringReplace(content, ERB_EXPR$1, ' ');

      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity


  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */


    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */

    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };
  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */


  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName.indexOf('-') > 0;
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */


  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    /* Execute a hook if present */

    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;
    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */

    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;
      value = name === 'value' ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      /* Execute a hook if present */

      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */

      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Remove attribute */


      _removeAttribute(name, currentNode);
      /* Did the hooks approve of the attribute? */


      if (!hookEvent.keepAttr) {
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */


      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);

        continue;
      }
      /* Sanitize attribute content to be template-safe */


      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
        value = stringReplace(value, ERB_EXPR$1, ' ');
      }
      /* Is `value` valid for this attribute? */


      var lcTag = transformCaseFunc(currentNode.nodeName);

      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */


      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Handle attributes that require Trusted Types */


      if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              value = trustedTypesPolicy.createHTML(value);
              break;

            case 'TrustedScriptURL':
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */


      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeAttributes', currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */


  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode;

    var shadowIterator = _createIterator(fragment);
    /* Execute a hook if present */


    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);
      /* Sanitize tags and elements */


      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      /* Deep shadow DOM detected */


      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
      /* Check attributes, sanitize if necessary */


      _sanitizeAttributes(shadowNode);
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };
  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity


  DOMPurify.sanitize = function (dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */

    IS_EMPTY_INPUT = !dirty;

    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */


    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();

        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }
    /* Check we can run. Otherwise fall back or ignore */


    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }
    /* Assign config vars */


    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */


    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */

    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);

        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);

      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */


      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */

      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */


    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */


    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */


    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      /* Sanitize tags and elements */


      if (_sanitizeElements(currentNode)) {
        continue;
      }
      /* Shadow DOM detected, sanitize it */


      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      /* Check attributes, sanitize if necessary */


      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;
    /* If we sanitized `dirty` in-place, return it. */

    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */


    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */

    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */


    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */


  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);

    SET_CONFIG = true;
  };
  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */


  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */


  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */


  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */


  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */


  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */


  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const ariaAttributes$LWS = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-readonly', 'aria-dropeffect', 'aria-expanded', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-disabled', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'role', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS);
const CUSTOM_ELEMENT_HANDLING$LWS = {
  attributeNameCheck: /.+/,
  allowCustomizedBuiltInElements: false,
  // The regexp is based on the WHATWG spec:
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  // However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.
  tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
}; // A generic config in which the sanitizer attempts in place sanitization and
// returns node.

const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  // Add '#document-fragment' to ALLOWED_TAGS to avoid a forbidden root node
  // exception.
  // https://github.com/cure53/DOMPurify/issues/664
  ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, '#document-fragment'),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  IN_PLACE: true
}; // A config to use only svg tags in which the sanitizer returns a document
// fragment.

const NODE_SVG$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  ALLOWED_TAGS: shallowCloneArray$LWS(svgTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false
}; // A config to use only tags allowed for blob and file.

const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  ALLOWED_TAGS: ReflectApply$LWS$1(ArrayProtoFilter$LWS$1, allTags$LWS, [tag$LWS => tag$LWS !== 'iframe']),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  SANITIZE_DOM: false
};
const instances$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());

function sanitizer$LWS(config$LWS, hooksRegistry$LWS) {
  let dompurify$LWS = instances$LWS.get(config$LWS);

  if (dompurify$LWS === undefined) {
    dompurify$LWS = purify();
    dompurify$LWS.setConfig(config$LWS);

    for (const hookName$LWS in hooksRegistry$LWS) {
      // istanbul ignore else
      if (hooksRegistry$LWS) {
        dompurify$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
      }
    }

    instances$LWS.set(config$LWS, dompurify$LWS);
  }

  return dompurify$LWS;
}

const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS$1(['href', 'xlink:href']);
const SANITIZER_HOOKS_REGISTRY$LWS = {
  __proto__: null,
  uponSanitizeAttribute: sanitizeHrefAttributeHook$LWS
};
const htmlTemplate$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
const normalizerAnchor$LWS$1 = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['a']); // Queue for managing pending xhr requests.

const queue$LWS = toSafeSet$LWS(new SetCtor$LWS()); // A regexp to find all non lowercase alphanumeric.

const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;

function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (queue$LWS.has(normalizedHref$LWS.normalizedUrl)) {
    // Wait for request to finish, then update content.
    const interval$LWS = WindowSetInterval$LWS(() => {
      // istanbul ignore else
      if (!queue$LWS.has(normalizedHref$LWS.normalizedUrl)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(interval$LWS);
      }
    }, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}

function createUrlContainer$LWS(url$LWS) {
  const container$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['div']);
  ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['style', 'display:none']);
  ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['id', url$LWS]);
  const body$LWS = ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, document, []);
  ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, body$LWS, [container$LWS]);
  return container$LWS;
}

function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedUrl); // Put the URL we're fetching in a queue.

  queue$LWS.add(normalizedHref$LWS.normalizedUrl); // Initiate an XHR to fetch the resource.

  const xhr$LWS = new XhrCtor$LWS();
  ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
    const status$LWS = ReflectApply$LWS$1(XhrProtoStatusGetter$LWS, xhr$LWS, []); // istanbul ignore next: the following is well tested via integration-karma

    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS); // Look for the container again in case other requests have finished
      // earlier for the same URL.

      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = ReflectApply$LWS$1(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);

        if (el$LWS) {
          ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedHref$LWS.normalizedFragment]);
        }
      }

      ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [fragment$LWS]);
      queue$LWS.delete(normalizedHref$LWS.normalizedUrl);
    }
  }]);
  ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', normalizedHref$LWS.requestedUrl]);
  ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
}

function parseHref$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS$1, [url$LWS]);
  const href$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS$1, []);
  const protocol$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS$1, []);
  const {
    0: requestedUrl$LWS,
    1: requestedFragment$LWS
  } = ReflectApply$LWS$1(StringProtoSplit$LWS, href$LWS, ['#']); // RegExp.prototype[Symbol.replace] resets the lastIndex of global regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

  const loweredUrl$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, requestedUrl$LWS, []);
  const normalizedUrl$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, '']);
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedUrl$LWS}_${ReflectApply$LWS$1(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ''])}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedUrl: normalizedUrl$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedUrl: requestedUrl$LWS
  };
}

function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]); // istanbul ignore else

  if (el$LWS === null) {
    try {
      el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
      ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedFragment$LWS]);
    } catch (_unused$LWS) {// Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers
      // may have the same ids for SVG elements.
    }
  }
}

function blobSanitizer$LWS() {
  return sanitizer$LWS(STRING_BLOB_HTML$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
}

function svgSanitizer$LWS() {
  return sanitizer$LWS(NODE_SVG$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
}

function sanitize$LWS(dirty$LWS) {
  ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [dirty$LWS]);
  const content$LWS = ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
  const sanitizer$1$LWS = sanitizer$LWS(NODE_ALL_IN_PLACE$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
  sanitizer$1$LWS.sanitize(content$LWS);
  return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
}

function sanitizeDocument$LWS(doc$LWS) {
  const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, doc$LWS, []);
  const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
  const docImpl$LWS = ReflectApply$LWS$1(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
  const newDoc$LWS = ReflectApply$LWS$1(DOMImplementationProtoCreateDocument$LWS, docImpl$LWS, [NAMESPACE_XHTML$LWS, 'html']);
  const newDocEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, newDoc$LWS, []);
  ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, newDocEl$LWS, [sanitize$LWS(content$LWS)]);
  return newDoc$LWS;
} // Sanitize a URL representing a SVG href attribute value.


function sanitizeHrefAttributeHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;

  if (attrValue$LWS && ReflectApply$LWS$1(StringProtoToUpperCase$LWS, ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === 'USE' && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }

  return data$LWS;
}

function sanitizeSvgHref$LWS(url$LWS) {
  const urlAsString$LWS = toString$LWS(url$LWS);

  if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, urlAsString$LWS, ['#'])) {
    return url$LWS;
  }

  const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS); // Sanitize only for supported URL_SCHEMES_LIST.

  if (URL_SCHEMES_LIST$LWS$1.includes(normalizedHref$LWS.protocol)) {
    const container$LWS = ReflectApply$LWS$1(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedUrl]); // Have we sanitized this URL already?

    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    } // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.


    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedUrl}`;
  }

  return url$LWS;
}

function createSvgContainer$LWS(ownerDoc$LWS) {
  return ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, ownerDoc$LWS, [NAMESPACE_SVG$LWS, 'svg']);
}

function sanitizeSvgInnerHtml$LWS(stringOrSvg$LWS, dirty$LWS = '') {
  const ownerDoc$LWS = typeof stringOrSvg$LWS === 'string' ? document : ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, stringOrSvg$LWS, []);
  let container$LWS;

  if (typeof stringOrSvg$LWS === 'string') {
    dirty$LWS = stringOrSvg$LWS;
    container$LWS = createSvgContainer$LWS(ownerDoc$LWS);
  } else {
    const closestSvg$LWS = ReflectApply$LWS$1(ElementProtoClosest$LWS, stringOrSvg$LWS, ['svg']);
    container$LWS = closestSvg$LWS ? ReflectApply$LWS$1(NodeProtoCloneNode$LWS, closestSvg$LWS, [false]) : createSvgContainer$LWS(ownerDoc$LWS);
  }

  const comment$LWS = ReflectApply$LWS$1(DocumentProtoCreateComment$LWS, ownerDoc$LWS, ['']);
  ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [comment$LWS]);
  const outerHTML$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, container$LWS, []);
  const replacedOuterHTML$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, outerHTML$LWS, ['<!---->', dirty$LWS]);
  const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(replacedOuterHTML$LWS);
  const firstChild$LWS = ReflectApply$LWS$1(NodeProtoFirstChildGetter$LWS, fragment$LWS, []);
  return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
}

function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const sanitizer$LWS = svgSanitizer$LWS();
  return sanitizer$LWS.sanitize(dirty$LWS);
}
/*! version: 0.17.9 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS('@@lockerDebugMode'); // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore else: not avoidable via tests

if (LOCKER_UNMINIFIED_FLAG$LWS) {
  // We passed the phase one gate so we know our code is unminified and we can
  // install Locker's custom devtools formatter.
  let lockerDebugModeSymbolFlag$LWS = true;
  const MAX_ARRAY_DISPLAY$LWS = 100;
  const MAX_OBJECT_DISPLAY$LWS = 5;
  const MAX_STRING_DISPLAY$LWS = 100;
  const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
  const headerCSSText$LWS = 'display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;';
  const bodyItemStyleObject$LWS = {
    style: 'margin-left:11px; margin-bottom: 3px;'
  };
  const bodyStyleObject$LWS = {
    style: 'display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;'
  };
  const keyEnumerableStringStyleObject$LWS = {
    style: 'color: #9d288c; font-weight: bold'
  };
  const keyNonEnumerableOrSymbolStyleObject$LWS = {
    style: 'color: #b17ab0'
  };
  const primitiveBlueColorStyleObject$LWS = {
    style: 'color: #16239f'
  };
  const primitiveGreenColorStyleObject$LWS = {
    style: 'color: #236d25'
  };
  const primitiveGreyColorStyleObject$LWS = {
    style: 'color: #606367'
  };
  const primitiveOrangeColorStyleObject$LWS = {
    style: 'color: #b82619'
  }; // istanbul ignore next: currently unreachable via tests

  const formatValue$LWS = function formatValue$LWS(__value$LWS) {
    if (__value$LWS === null || __value$LWS === undefined) {
      return ['span', primitiveGreyColorStyleObject$LWS, `${__value$LWS}`];
    }

    if (typeof __value$LWS === 'boolean') {
      return ['span', primitiveBlueColorStyleObject$LWS, __value$LWS];
    }

    if (typeof __value$LWS === 'number') {
      return NumberIsFinite$LWS(__value$LWS) ? ['span', primitiveBlueColorStyleObject$LWS, __value$LWS] : ['span', primitiveBlueColorStyleObject$LWS, `${__value$LWS >= 0 ? '' : '-'}Infinity`];
    }

    if (typeof __value$LWS === 'string') {
      let _string$LWS = __value$LWS;
      const {
        length: _length$LWS
      } = _string$LWS;

      if (_length$LWS > MAX_STRING_DISPLAY$LWS) {
        const firstChunk$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS, _string$LWS, [0, MID_STRING_DISPLAY$LWS]);
        const lastChunk$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS, _string$LWS, [_length$LWS - MID_STRING_DISPLAY$LWS - 1, _length$LWS]);
        _string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
      } // @TODO: Default single quotes on main header.
      //       Double quotes on body.


      return ['span', primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(_string$LWS)];
    }

    if (ArrayIsArray$LWS$1(__value$LWS)) {
      return ['span', {}, `Array(${__value$LWS.length})`];
    }

    if (isObject$LWS(__value$LWS)) {
      return ['span', {}, `{${CHAR_ELLIPSIS$LWS}}`];
    } // Symbol will be coerced to a string.


    return ['span', primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(__value$LWS)];
  }; // istanbul ignore next: currently unreachable via tests


  const formatHeader$LWS = function formatHeader$LWS(object$LWS, config$LWS) {
    const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
    const formattedHeader$LWS = [];
    let formattedHeaderOffset$LWS = 0;

    if (isChildElement$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
    }

    const brand$LWS = ReflectApply$LWS$1(ObjectProtoToString$LWS, object$LWS, []);
    let _keys$LWS = ObjectKeys$LWS(object$LWS);

    if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
      if (!ReflectApply$LWS$1(ArrayProtoIncludes$LWS$1, _keys$LWS, ['description'])) {
        ReflectApply$LWS$1(ArrayProtoUnshift$LWS$1, _keys$LWS, ['description']);
      }
    } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
      const {
        length: _length$LWS
      } = object$LWS;
      _keys$LWS = ReflectApply$LWS$1(ArrayProtoFilter$LWS$1, _keys$LWS, [__key$LWS => {
        const _possibleIndex$LWS = typeof __key$LWS === 'string' ? +__key$LWS : -1;
        return _possibleIndex$LWS < 0 || _possibleIndex$LWS >= _length$LWS || !NumberIsInteger$LWS(_possibleIndex$LWS);
      }]);
    }

    const {
      length: keysLength$LWS
    } = _keys$LWS;

    if (ArrayIsArray$LWS$1(object$LWS)) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', isChildElement$LWS ? primitiveGreyColorStyleObject$LWS : {}, `(${object$LWS.length}) [`];

      for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_ARRAY_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
        const __key$LWS = _keys$LWS[_i$LWS];
        const __value$LWS = object$LWS[__key$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, _i$LWS ? ', ' : ''];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
      }

      if (keysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }

      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ']'];
      return formattedHeader$LWS;
    }

    let boxedHeaderEntry$LWS;
    let headerOpening$LWS = '{'; // eslint-disable-next-line default-case

    switch (brand$LWS) {
      case TO_STRING_BRAND_BIG_INT$LWS:
      case TO_STRING_BRAND_BOOLEAN$LWS:
      case TO_STRING_BRAND_NUMBER$LWS:
      case TO_STRING_BRAND_STRING$LWS:
      case TO_STRING_BRAND_SYMBOL$LWS:
        {
          let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;

          if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
            colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
          } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
            colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
          }

          headerOpening$LWS = `${ReflectApply$LWS$1(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
          boxedHeaderEntry$LWS = ['span', colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS))}`];
          break;
        }
    }

    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, headerOpening$LWS];

    if (boxedHeaderEntry$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;

      if (keysLength$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ', '];
      }
    }

    for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_OBJECT_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
      const __key$LWS = _keys$LWS[_i$LWS];
      const __value$LWS = object$LWS[__key$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, _i$LWS ? ', ' : ''];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, __key$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
    }

    if (keysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
    }

    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, '}'];
    return formattedHeader$LWS;
  }; // istanbul ignore next: currently unreachable via tests


  const formatBody$LWS = function formatBody$LWS(object$LWS) {
    const _keys$LWS = ObjectKeys$LWS(object$LWS); // @TODO: Arrays are broken into groups of 100.

    const ownKeys$LWS = ReflectOwnKeys$LWS$1(object$LWS);

    if (!ArrayIsArray$LWS$1(object$LWS)) {
      ReflectApply$LWS$1(ArrayProtoSort$LWS$1, ownKeys$LWS, []);
    }

    const formattedBody$LWS = [];
    let formattedBodyOffset$LWS = 0;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[_i$LWS];
      const __value$LWS = object$LWS[ownKey$LWS];

      if (isObject$LWS(__value$LWS)) {
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', {}, ['object', {
          object: __value$LWS,
          config: {
            childKey: StringCtor$LWS(ownKey$LWS),
            isChildElement: true
          }
        }]];
      } else {
        let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;

        if (typeof ownKey$LWS === 'symbol' || !ReflectApply$LWS$1(ArrayProtoIncludes$LWS$1, _keys$LWS, [ownKey$LWS])) {
          currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
        }

        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', bodyItemStyleObject$LWS, ['span', currentKeyStyle$LWS, StringCtor$LWS(ownKey$LWS)], ['span', {}, ': '], formatValue$LWS(__value$LWS)];
      }
    }

    return formattedBody$LWS;
  };

  let {
    devtoolsFormatters: devtoolsFormatters$LWS
  } = window;

  if (!ArrayIsArray$LWS$1(devtoolsFormatters$LWS)) {
    devtoolsFormatters$LWS = [];
    ReflectDefineProperty$LWS(window, 'devtoolsFormatters', {
      __proto__: null,
      configurable: true,
      value: devtoolsFormatters$LWS,
      writable: true
    });
  } // Append our custom formatter to the array of devtools formatters.
  // istanbul ignore next: currently unreachable via tests


  devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
    // istanbul ignore next: currently unreachable via tests
    header(object$LWS, config$LWS) {
      if (lockerDebugModeSymbolFlag$LWS) {
        // We passed the second phase gate so we know that the user has
        // opted-in to custom devtools formatters. Close the gate and
        // define the @@lockerDebugMode symbol on window.
        lockerDebugModeSymbolFlag$LWS = false;
        ReflectDefineProperty$LWS(window, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
          __proto__: null,
          configurable: true,
          value: true,
          writable: true
        });
      }

      if (!isNearMembrane$LWS(object$LWS)) {
        return null;
      }

      const headerDiv$LWS = ['div', {
        style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? '' : 'font-style: italic;'}`
      }];
      ReflectApply$LWS$1(ArrayProtoPush$LWS$1, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
      return ['div', {}, headerDiv$LWS];
    },

    // istanbul ignore next: currently unreachable via tests
    hasBody() {
      return true;
    },

    // istanbul ignore next: currently unreachable via tests
    body(object$LWS) {
      const bodyDiv$LWS = ['div', bodyStyleObject$LWS];
      ReflectApply$LWS$1(ArrayProtoPush$LWS$1, bodyDiv$LWS, formatBody$LWS(object$LWS));
      return bodyDiv$LWS;
    }

  };
}


const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar']; // Allow only alphanumeric, '-', '+', and '.' characters.

const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;

function isMIMETypeAllowed$LWS(mimeType$LWS) {
  // avoid MIME types which try to escape using special characters
  // Reason: W-4896359
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
    for (let i$LWS = 0, {
      length: length$LWS
    } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
        return true;
      }
    }
  }

  return false;
}

const DISALLOWED_ENDPOINTS_LIST$LWS = ['/aura', '/webruntime'];
const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
const TRUSTED_DOMAINS_REG_EXP$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/;
const URL_SCHEMES_LIST$LWS = toSafeArray$LWS$1(['http:', 'https:']);
const normalizerAnchor$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['a']); // @TODO W-7302311 Make paths and domains configurable

function isValidURL$LWS(parsedURL$LWS) {
  const loweredPathname$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);

  for (let i$LWS = 0, {
    length: length$LWS
  } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS; i$LWS += 1) {
    if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
      return false;
    }
  }

  return true;
}

function isValidURLScheme$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return URL_SCHEMES_LIST$LWS.includes(ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []));
}

function parseURL$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [sanitizeURLString$LWS(url$LWS)]);
  return {
    normalizedURL: ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []),
    hostname: ReflectApply$LWS$1(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []),
    pathname: WindowDecodeURIComponent$LWS(ReflectApply$LWS$1(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS, []))
  };
}

function sanitizeURLForElement$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return sanitizeURLString$LWS(ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []));
}

function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : ReflectApply$LWS$1(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, '']);
}



const CustomElementRegistryBlockedProperties$LWS = ['define'];
const documentToSandboxAttributeDistortionRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const recordToAttributeDistortionFactories$LWS = toSafeMap$LWS(new MapCtor$LWS());

function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS); // istanbul ignore if: currently unreachable via tests

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS]; // istanbul ignore if: currently unreachable via tests

  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attrName$LWS, [])];

  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }

  const mapIterator$LWS = elementCtorMap$LWS.entries();

  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function createAttributeDistortionFactories$LWS(record$LWS) {
  const attributeFactories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS); // istanbul ignore if: currently unreachable via tests

  if (attributeFactories$LWS === undefined) {
    return [];
  }

  recordToAttributeDistortionFactories$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS);

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxAttributeDistortionRegistry$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }

  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  const {
    length: length$LWS
  } = attributeFactories$LWS;
  const factories$LWS = Array(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const attributeFactory$LWS = attributeFactories$LWS[i$LWS];

    factories$LWS[i$LWS] = () => {
      attributeFactory$LWS(attributeDistortionRegistry$LWS);
      return null;
    };
  }

  return factories$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}

function registerElementSetDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let attributeFactories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS);

  if (attributeFactories$LWS === undefined) {
    attributeFactories$LWS = [];
    recordToAttributeDistortionFactories$LWS.set(record$LWS, attributeFactories$LWS);
  }

  const loweredAttributeName$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attributeName$LWS, []);

  attributeFactories$LWS[attributeFactories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];

    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }

    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = toSafeMap$LWS(new MapCtor$LWS());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }

    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
  };
}

function initDistortionAttrValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS
  }
}) {
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');
  return function distortionAttrValueSetter$LWS(record$LWS) {
    return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
      const ownerElement$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore else: needs default platform behavior test

      if (ownerElement$LWS) {
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
        /* istanbul ignore if: coverage missing, needs investigation */

        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerElement$LWS, [val$LWS]);
          return;
        }
      }

      ReflectApply$LWS$1(originalAttrValueSetter$LWS, this, [val$LWS]);
    }];
  };
}

function initDistortionAuraUtilGlobalEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: globalObject$LWS
}) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval; // istanbul ignore else: external is the default sandbox type for coverage runs

  if (typeof originalGlobalEval$LWS !== 'function') {
    return alwaysNull$LWS;
  } // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  return function distortionAuraUtilGlobalEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
    return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
      let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;

      if (typeof descriptor$LWS === 'string') {
        const split$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, descriptor$LWS, ['://']);
        const {
          length: length$LWS
        } = split$LWS;
        const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
        wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, ['.', '/'])}` : `/components/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, [':', '/'])}.js`);
      }

      return sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageDelete$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageHas$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy2$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageHas$LWS({
    key: key$LWS
  }) {
    return [originalHas$LWS, function has$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$LWS$1(originalHas$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageKeys$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy3$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageKeys$LWS({
    key: key$LWS
  }) {
    return [originalKeys$LWS, function keys$LWS() {
      const keysResultPromise$LWS = ReflectApply$LWS$1(originalKeys$LWS, this, []);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, keysResultPromise$LWS, [result$LWS => {
        const sandboxedCacheNames$LWS = [];

        for (let i$LWS = 0, j$LWS = 0, {
          length: length$LWS
        } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cacheName$LWS = result$LWS[i$LWS];

          if (isNamespacePrefixed$LWS(cacheName$LWS, key$LWS)) {
            sandboxedCacheNames$LWS[j$LWS++] = unprefixNamespace$LWS(cacheName$LWS, key$LWS);
          }
        }

        return sandboxedCacheNames$LWS;
      }]);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageMatch$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy4$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageMatch$LWS({
    key: key$LWS
  }) {
    return [originalMatch$LWS, function match$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // Let the native method handle missing parameters.

      if (!length$LWS) {
        return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
      } // Next we check `length` is at least 2, which means options are present.


      const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the
      // `options.cacheName` value. The value of `options.cacheName` must
      // also be safely convertible to a string.

      if (isObjectLike$LWS(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
        const {
          cacheName: cacheName$LWS
        } = matchOptions$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
          clonedOptions$LWS.cacheName = prefixNamespace$LWS(cacheName$LWS, key$LWS);
          args$LWS[1] = clonedOptions$LWS;
          return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
        }
      }

      return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCacheStorageOpen$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy5$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.


  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCacheStorageOpen$LWS({
    key: key$LWS
  }) {
    return [originalOpen$LWS, function open$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;

        if (isConvertibleToString$LWS(cacheName$LWS)) {
          args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
    }];
  };
}

const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */

function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = prefixNamespace$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookie$LWS(cookieEntry$LWS, key$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!isNamespacePrefixed$LWS(cookieEntry$LWS, key$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key.


  const prefix$LWS = getNamespacePrefix$LWS(key$LWS);
  const {
    length: prefixLength$LWS
  } = prefix$LWS;
  const pos$LWS = cookieEntry$LWS.length > prefixLength$LWS && cookieEntry$LWS[prefixLength$LWS] === '=' ? prefixLength$LWS + 1 : prefixLength$LWS;
  return ReflectApply$LWS$1(StringProtoSlice$LWS, cookieEntry$LWS, [pos$LWS]);
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreDelete$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp$LWS;

  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }

      return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreGet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp2$LWS;

  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreGet$LWS({
    key: key$LWS
  }) {
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }

      const getResultPromise$LWS = ReflectApply$LWS$1(originalGet$LWS, this, args$LWS);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, getResultPromise$LWS, [cookieListItem$LWS => {
        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;

          if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
            return cookieListItem$LWS;
          }
        }

        return null;
      }]);
    }];
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreGetAll$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp3$LWS;

  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreGetAll$LWS({
    key: key$LWS
  }) {
    return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
      }

      const getAllResultPromise$LWS = ReflectApply$LWS$1(originalGetAll$LWS, this, args$LWS);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, getAllResultPromise$LWS, [result$LWS => {
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;

        for (let i$LWS = 0, {
          length: length$LWS
        } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cookieListItem$LWS = result$LWS[i$LWS];

          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;

            if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
              sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
            }
          }
        }

        return sandboxedCookies$LWS;
      }]);
    }];
  };
}

const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;

  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
}

function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }

  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
} // istanbul ignore next: only available in secure context


function onchange$LWS() {
  throw new LockerSecurityError$LWS('Cannot set cookieStore.onchange.');
} // istanbul ignore next: only available in secure context


function initDistortionCookieStoreOnChange$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  const originalOnChangeSetter$LWS = ObjectLookupOwnSetter$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionMapEntry$LWS = [originalOnChangeSetter$LWS, onchange$LWS];
  return function distortionCookieStoreOnChange$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, CookieStore$LWS, 'change');
    return distortionMapEntry$LWS;
  };
}
/* istanbul ignore next: only available in secure context */


function initDistortionCookieStoreSet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp4$LWS;

  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCookieStoreSet$LWS({
    key: key$LWS
  }) {
    return [originalSet$LWS, function set$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;

      if (length$LWS > 1) {
        args$LWS[0] = prefixNamespace$LWS(args$LWS[0], key$LWS);
      } else if (length$LWS) {
        const {
          0: details$LWS
        } = args$LWS;

        if (isObjectLike$LWS(details$LWS)) {
          const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
          clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
          args$LWS[0] = clonedDetails$LWS;
        }
      }

      return ReflectApply$LWS$1(originalSet$LWS, this, args$LWS);
    }];
  };
}

function initDistortionCSSStyleRuleStyleGetter$LWS({
  globalObject: {
    CSSStyleRule: CSSStyleRule$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(CSSStyleRule$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
  }];
  return function distortionCSSStyleRuleStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionCustomElementRegistryGet$LWS({
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS
  }
}) {
  var _CustomElementRegistr$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalGet$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  return function distortionCustomElementRegistryGet$LWS({
    key: key$LWS
  }) {
    const loweredNsPrefix$LWS = `${ReflectApply$LWS$1(StringProtoToLowerCase$LWS, key$LWS, [])}-`;
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length) {
        const sanitizedName$LWS = toString$LWS(args$LWS[0]);
        const loweredName$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, sanitizedName$LWS, []);

        if (!ReflectApply$LWS$1(StringProtoStartsWith$LWS, loweredName$LWS, [loweredNsPrefix$LWS])) {
          return undefined;
        }

        args$LWS[0] = sanitizedName$LWS;
      }

      return ReflectApply$LWS$1(originalGet$LWS, this, args$LWS);
    }];
  };
}

function initDistortionDocumentCookieGetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS$1(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieGetter$LWS, function get$LWS() {
      const documentCookieValue$LWS = ReflectApply$LWS$1(DocumentProtoCookieGetter$LWS, this, []);
      const cookies$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);

        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }

      return ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
    }];
  };
}

function initDistortionDocumentCookieSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
      const cookieEntries$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
      let {
        0: newCookieEntry$LWS
      } = cookieEntries$LWS;

      if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
        newCookieEntry$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS, newCookieEntry$LWS, [1]);
      }

      cookieEntries$LWS[0] = prefixNamespace$LWS(newCookieEntry$LWS, key$LWS);
      const cookie$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
      ReflectApply$LWS$1(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
    }];
  };
}

function domain$LWS() {
  throw new LockerSecurityError$LWS('Cannot set document.domain.');
}

function initDistortionDocumentDomainSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');
  const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
  return function distortionDocumentDomainSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$m$LWS
} = selfValidator$LWS;

function initDistortionDocumentExecCommand$LWS({
  globalObject: {
    Document: {
      prototype: {
        execCommand: originalExecCommand$LWS
      }
    },
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS$1(Document.prototype, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'isContentEditable');
  return function distortionDocumentExecCommand$LWS({
    type: type$LWS
  }) {
    return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
      if (args$LWS.length > 2) {
        const {
          2: unsanitizedValue$LWS
        } = args$LWS; // istanbul ignore else: needs default platform behavior test

        if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
          const command$LWS = toString$LWS(args$LWS[0]); // istanbul ignore else: LWS does not test for all possible commands

          if (ReflectApply$LWS$1(StringProtoToLowerCase$LWS, command$LWS, []) === 'inserthtml') {
            // istanbul ignore else: external is the default sandbox type for coverage runs
            if (type$LWS === 0
            /* SandboxType.External */
            ) {
              const activeElement$LWS = ReflectApply$LWS$1(originalActiveElement$LWS, this, []);

              if (isSharedElement$m$LWS(activeElement$LWS) && ReflectApply$LWS$1(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, activeElement$LWS, [])}.`);
              }
            }

            args$LWS[0] = command$LWS;
            args$LWS[2] = sanitize$LWS(unsanitizedValue$LWS);
          }
        }
      }

      return ReflectApply$LWS$1(originalExecCommand$LWS, this, args$LWS);
    }];
  };
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    const windowFeatures$LWS = toString$LWS(sanitizedArgs$LWS[2]);
    let loweredWindowFeatures$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, windowFeatures$LWS, []); // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

    if (ReflectApply$LWS$1(RegExpProtoTest$LWS, noopenerRegExp$LWS, [windowFeatures$LWS])) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      loweredWindowFeatures$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredWindowFeatures$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
    }

    sanitizedArgs$LWS[2] = loweredWindowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function initDistortionDocumentOpen$LWS({
  globalObject: {
    Document: {
      prototype: {
        open: originalDocumentOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias
      // for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, args$LWS);
  }];
  return function distortionDocumentOpen$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$l$LWS
} = selfValidator$LWS;

function initDistortionDocumentReplaceChildren$LWS({
  globalObject: {
    Document: {
      prototype: {
        replaceChildren: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check
    // if its `head` property is a shared element. This will allow
    // magenta window documents to call replaceChildren successfully.
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$l$LWS(ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this, []))) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionDocumentReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionDOMParserParseFromString$LWS({
  globalObject: {
    DOMParser: {
      prototype: {
        parseFromString: originalParseFromString$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with
    // exactly two arguments. If it receives one argument, it will fail.
    // Some implementations will also fail if it receives more than two
    // arguments. Since any call that does not have at least two arguments
    // will fail no matter what, we only need to expend effort to sanitize
    // when we know that the operation is definitely NOT going to fail.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = toString$LWS(args$LWS[0]);
      const mimeType$LWS = toString$LWS(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? sanitizeSvgInnerHtml$LWS(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : sanitize$LWS(string$LWS);
    }

    return ReflectApply$LWS$1(originalParseFromString$LWS, this, args$LWS);
  }];
  return function distortionDOMParserParseFromString$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$k$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
} = selfValidator$LWS;

function initDistortionElementAfter$LWS({
  globalObject: {
    Element: {
      prototype: {
        after: originalAfter$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$k$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$LWS$1(originalAfter$LWS, this, args$LWS);
  }];
  return function distortionElementAfter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$j$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
} = selfValidator$LWS;

function initDistortionElementAppend$LWS({
  globalObject: {
    Element: {
      prototype: {
        append: originalAppend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$j$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number
      // of arguments which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared
        // element child which is limited to script and link, an
        // exception is thrown.

        if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$LWS$1(originalAppend$LWS, this, args$LWS);
  }];
  return function distortionElementAppend$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementAttachShadow$LWS({
  globalObject: {
    Element: {
      prototype: {
        attachShadow: originalAttachShadow$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit
        // because attachShadow() accepts inherited shadowRootInit
        // properties.


        const shadowRootInit$LWS = ObjectAssign$LWS$1({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment
        // of mode to avoid complications with inherited
        // non-configurable/non-writable mode properties.

        const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$LWS$1(originalShadowRootInit$LWS);
        ReflectSetPrototypeOf$LWS$1(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return ReflectApply$LWS$1(originalAttachShadow$LWS, this, args$LWS);
  }];
  return function distortionElementAttachShadow$LWS() {
    return distortionEntry$LWS;
  };
}

const namedNodeMapToElementRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementRegistry$LWS.set(attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementRegistry$LWS.get(nodeNameMap$LWS); // istanbul ignore else: nothing to do if there's no element

  if (element$LWS) {
    const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: nothing to do if there's no distortion

    if (distortion$LWS) {
      const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
      return ReflectApply$LWS$1(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  } // istanbul ignore next: needs default platform behavior test


  return ReflectApply$LWS$1(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function initDistortionElementAttributesGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'attributes');
  const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
    const attrs$LWS = ReflectApply$LWS$1(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }];
  return function distortionElementAttributesGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$i$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
} = selfValidator$LWS;

function initDistortionElementBefore$LWS({
  globalObject: {
    Element: {
      prototype: {
        before: originalBefore$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$i$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // istanbul ignore else: needs default platform behavior test

        if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$LWS$1(originalBefore$LWS, this, args$LWS);
  }];
  return function distortionElementBefore$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$h$LWS
} = selfValidator$LWS;

function initDistortionElementInnerHTMLSetter$LWS({
  globalObject: {
    Element: Element$LWS,
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'innerHTML');
  const distortionEntry$LWS = [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
    const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;

    if (!isOwnerXMLDocument$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$h$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }

      value$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS);
    }

    ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [value$LWS]);
  }];
  return function distortionElementInnerHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$g$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
} = selfValidator$LWS;

function initDistortionElementInsertAdjacentElement$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentElement: originalInsertAdjacentElement$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$g$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
    }

    return ReflectApply$LWS$1(originalInsertAdjacentElement$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentElement$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$f$LWS
} = selfValidator$LWS;

function initDistortionElementInsertAdjacentHTML$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentHTML: originalInsertAdjacentHTML$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$f$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}`);
    } // istanbul ignore else: needs default platform behavior test


    if (args$LWS.length > 1) {
      args$LWS[1] = sanitize$LWS(args$LWS[1]);
    }

    ReflectApply$LWS$1(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentHTML$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$e$LWS
} = selfValidator$LWS;

function initDistortionElementOuterHTMLSetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML');
  const distortionEntry$LWS = [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$e$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$LWS$1(originalOuterHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }];
  return function distortionElementOuterHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$d$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
} = selfValidator$LWS;

function initDistortionElementPrepend$LWS({
  globalObject: {
    Element: {
      prototype: {
        prepend: originalPrepend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$d$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary
      // number of arguments which can be comprised of Nodes and
      // DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared
        // element child, which is limited to script and link, an
        // exception is thrown.

        if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          toString$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }

    return ReflectApply$LWS$1(originalPrepend$LWS, this, args$LWS);
  }];
  return function distortionElementPrepend$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$c$LWS
} = selfValidator$LWS;

function initDistortionElementRemove$LWS({
  globalObject: {
    Element: {
      prototype: {
        remove: originalRemove$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$c$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$LWS$1(originalRemove$LWS, this, []);
  }];
  return function distortionElementRemove$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$b$LWS
} = selfValidator$LWS;

function initDistortionElementReplaceChildren$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceChildren: originalReplaceChildren$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$b$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    return ReflectApply$LWS$1(originalReplaceChildren$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$a$LWS
} = selfValidator$LWS;

function initDistortionElementReplaceWith$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceWith: originalReplaceWith$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$a$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    return ReflectApply$LWS$1(originalReplaceWith$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceWith$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementSetAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttribute$LWS(record$LWS) {
    return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
      if (args$LWS.length > 1) {
        const attrName$LWS = toString$LWS(args$LWS[0]);
        const attrValue$LWS = toString$LWS(args$LWS[1]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          return;
        } // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".


        args$LWS[0] = attrName$LWS;
        args$LWS[1] = attrValue$LWS;
      }

      ReflectApply$LWS$1(originalSetAttribute$LWS, this, args$LWS);
    }];
  };
}

function initDistortionElementSetAttributeNode$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNode: originalSetAttributeNode$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNode$LWS(record$LWS) {
    return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      } // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test


      if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      }

      const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

        if (oldAttr$LWS) {
          // Disconnect old attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

        if (newAttr$LWS) {
          // Remove distorted attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }

        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

          ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [attr$LWS]);
        }

        return undefined;
      }

      return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
    }];
  };
}

function initDistortionElementSetAttributeNodeNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNodeNS: originalSetAttributeNodeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
    return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
      } // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test


      if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }

      const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

        if (oldAttr$LWS) {
          // Disconnect the old attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }

        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

        if (newAttr$LWS) {
          // Remove the distorted attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }

        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
        }

        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

          ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
        }

        return null;
      }

      return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
    }];
  };
}

function initDistortionElementSetAttributeNS$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttributeNS: originalSetAttributeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNS$LWS(record$LWS) {
    return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
      // istanbul ignore next: needs default platform behavior test
      if (args$LWS.length < 3) {
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
        return;
      }

      let {
        0: attrNamespace$LWS
      } = args$LWS;

      if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
        attrNamespace$LWS = toString$LWS(attrNamespace$LWS);
      }

      const attrName$LWS = toString$LWS(args$LWS[1]);
      const attrValue$LWS = toString$LWS(args$LWS[2]);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        return;
      } // istanbul ignore next: needs default platform behavior test
      // eslint-disable-next-line no-lone-blocks


      {
        // This is in a block to avoid requiring an
        // "istanbul ignore next" for all for lines.
        // We could avoid this entirely by testing the default
        // platform behavior.
        args$LWS[0] = attrNamespace$LWS; // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".

        args$LWS[1] = attrName$LWS;
        args$LWS[2] = attrValue$LWS;
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
      }
    }];
  };
}

function initDistortionElementShadowRootGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'shadowRoot');
  const distortionEntry$LWS = [originalShadowRootGetter$LWS, alwaysNull$LWS];
  return function distortionElementShadowRootGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionElementToggleAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        hasAttribute: ElementProtoHasAttribute$LWS,
        toggleAttribute: originalToggleAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementToggleAttribute$LWS(record$LWS) {
    return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (length$LWS > 0) {
        const attrName$LWS = toString$LWS(args$LWS[0]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely,
          // if the distortion throws.

          ReflectApply$LWS$1(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to
          // return true | false, based on the presence or absence
          // of this attribute.

          return ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
        } // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        // istanbul ignore next: needs default platform behavior test


        args$LWS[0] = attrName$LWS;
      } // istanbul ignore next: needs default platform behavior test


      return ReflectApply$LWS$1(originalToggleAttribute$LWS, this, args$LWS);
    }];
  };
}

function initDistortionEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    eval: originalEval$LWS
  }
}) {
  return function distortionEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalEval$LWS, sourceText$LWS => sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(toString$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS)];
  };
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function composedPath$LWS() {
  return createDistortedComposedPath$LWS(this);
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = ReflectApply$LWS$1(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$LWS$1(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = ReflectApply$LWS$1(ArrayProtoIndexOf$LWS$1, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }

  return distortedComposedPath$LWS;
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function initDistortionEventComposedPath$LWS({
  globalObject: {
    Event: {
      prototype: {
        composedPath: originalComposedPath$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalComposedPath$LWS, composedPath$LWS];
  return function distortionEventComposedPath$LWS() {
    return distortionEntry$LWS;
  };
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function path$LWS() {
  return createDistortedComposedPath$LWS(this);
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function initDistortionEventPathGetter$LWS({
  globalObject: {
    Event: Event$LWS
  }
}) {
  const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS$1(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalPathGetter$LWS, path$LWS];
  return function distortionEventPathGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionEventTargetAddEventListener$LWS({
  globalObject: {
    EventTarget: {
      prototype: {
        addEventListener: originalAddEventListener$LWS
      }
    }
  }
}) {
  return function distortionEventTargetAddEventListener$LWS(record$LWS) {
    function addEventListener$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS; // Ensure that we fallback to the default platform behavior which
      // should fail if less than 2 arguments are provided.
      // istanbul ignore else: needs default platform behavior test

      if (length$LWS > 1) {
        const eventName$LWS = toString$LWS(args$LWS[0]);

        if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
          let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
          const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(this.constructor, 'name'); // istanbul ignore else: needs default platform behavior test

          if (safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
            const {
              value: name$LWS
            } = safeDesc$LWS; // istanbul ignore else: needs default platform behavior test

            if (typeof name$LWS === 'string') {
              exceptionMessage$LWS += ` to ${name$LWS} object`;
            }
          }

          throw new LockerSecurityError$LWS(`${exceptionMessage$LWS}.`);
        }

        args$LWS[0] = eventName$LWS;
      }

      return ReflectApply$LWS$1(originalAddEventListener$LWS, this, args$LWS);
    }

    return [originalAddEventListener$LWS, addEventListener$LWS];
  };
}

function initDistortionFunction$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    Function: originalFunction$LWS
  }
}) {
  return function distortionFunction$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalFunction$LWS, function Function$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;

      if (length$LWS) {
        const lastIndex$LWS = length$LWS - 1;
        args$LWS[lastIndex$LWS] = transformUncompiledSourceText$LWS(toString$LWS(args$LWS[lastIndex$LWS]));
      } // NOTE: Function constructor and eval are controlled by the same CSP rules,
      // which means we can rely on eval to fulfill the behavior of the Function
      // constructor.


      const fn$LWS = sandboxEvaluator$LWS(`(...args) => Function(...args)`, UNCOMPILED_CONTEXT$LWS);
      return ReflectApply$LWS$1(fn$LWS, this, args$LWS);
    }];
  };
}

function initDistortionHistoryPushState$LWS({
  globalObject: {
    History: {
      prototype: {
        pushState: originalPushState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
  }];
  return function distortionHistoryPushState$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHistoryReplaceState$LWS({
  globalObject: {
    History: {
      prototype: {
        replaceState: originalReplaceState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
  }];
  return function distortionHistoryReplaceState$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLElementDatasetGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionHTMLElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$9$LWS
} = selfValidator$LWS;

function initDistortionHTMLElementInnerTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$9$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$LWS$1(originalInnerTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementInnerTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$8$LWS
} = selfValidator$LWS; // The outerText property is non-standard, so the descriptor could be undefined,
// like in the case of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility

function initDistortionHTMLElementOuterTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$8$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }

    ReflectApply$LWS$1(originalOuterTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementOuterTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLElementStyleGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
  }];
  return function distortionHTMLElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function src$LWS(value$LWS) {
  const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

  if (!isValidURLScheme$LWS(urlString$LWS)) {
    throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
  }

  ReflectApply$LWS$1(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
}

function initDistortionHTMLIFrameElementSrcSetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');
  const distortionMapEntry$LWS = [originalSrcSetter$LWS, src$LWS];
  return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return distortionMapEntry$LWS;
  };
}

const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !ReflectApply$LWS$1(RegExpProtoTest$LWS, importRegExp$LWS, [value$LWS]);
}

function initDistortionHTMLLinkElementRelSetter$LWS({
  globalObject: {
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const valueAsString$LWS = toString$LWS(value$LWS);

    if (isValidRelValue$LWS(valueAsString$LWS)) {
      ReflectApply$LWS$1(originalRelSetter$LWS, this, [valueAsString$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
  return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', NAMESPACE_DEFAULT$LWS, rel$LWS);
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLLinkElementRelListSetter$LWS({
  globalObject: {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');
  const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ?
    /* istanbul ignore next: needs default platform behavior test */
    ReflectApply$LWS$1(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toString$LWS(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS$1(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }];
  return function distortionHTMLLinkElementRelListSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionHTMLObjectElementDataSetter$LWS({
  globalObject: {
    HTMLObjectElement: HTMLObjectElement$LWS
  }
}) {
  const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, 'data');

  function data$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLObjectElement.data supports http://, https:// schemes and relative urls.');
    }

    const parsedURL$LWS = parseURL$LWS(urlString$LWS);

    if (!isValidURL$LWS(parsedURL$LWS)) {
      throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }

    ReflectApply$LWS$1(originalDataSetter$LWS, this, [urlString$LWS]);
  }

  const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
  return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', NAMESPACE_DEFAULT$LWS, data$LWS);
    return distortionEntry$LWS;
  };
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = ReflectApply$LWS$1(HTMLElementProtoDatasetGetter$LWS, el$LWS, []);
  const distortedSrc$LWS = ObjectLookupOwnValue$LWS(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function initDistortionHTMLScriptElementSrcGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLScriptElement$LWS.prototype, 'src');
  const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS() {
    return getDatasetSrcValue$LWS(this) || ReflectApply$LWS$1(originalSrcGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const BLOB_SCRIPT_OPTIONS$LWS = {
  __proto__: null,
  type: 'text/javascript'
};
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_PAYLOAD_TOKEN$LWS = '$payload$';
const SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}("${SCRIPT_PAYLOAD_TOKEN$LWS}")`;
const SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}()`;
const seenNodesThatSetTextContent$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());

function defineEvaluatorProperty$LWS(host$LWS, callback$LWS) {
  if (!ReflectDefineProperty$LWS(host$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter source as "[native code]".
    get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
      ReflectDeleteProperty$LWS$1(host$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
      const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, host$LWS, []);
      const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []); // We don't need to use something like `WindowLocationGetter()`
      // because the 'location' property is non-configurable.

      const context$LWS = {
        [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
        [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
      };
      return (...args$LWS) => {
        callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS, args$LWS);
      };
    }, [])
  })) {
    // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
    throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, host$LWS, [])}`);
  }
}

function defineSrcEvaluatorProperty$LWS(host$LWS, sandboxEvaluator$LWS) {
  // prettier-ignore
  defineEvaluatorProperty$LWS(host$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS, {
    0: encodedPayload$LWS
  }) => {
    sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(WindowDecodeURIComponent$LWS(toString$LWS(encodedPayload$LWS))), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function defineTextContentEvaluatorProperty$LWS(host$LWS, textContent$LWS, sandboxEvaluator$LWS) {
  // The textContent of a script element is only evaluated on the first set.
  // Subsequent sets change the textContent value but are not evaluated.
  if (seenNodesThatSetTextContent$LWS.has(host$LWS)) {
    return false;
  }

  seenNodesThatSetTextContent$LWS.add(host$LWS); // prettier-ignore

  defineEvaluatorProperty$LWS(host$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
    sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(textContent$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function getSrcEvaluatorHookSourceText$LWS(sourceText$LWS) {
  // Creates a blob URL to invoke the evaluator hook with encoded source text.
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([ReflectApply$LWS$1(StringProtoReplace$LWS, SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS, [SCRIPT_PAYLOAD_TOKEN$LWS, WindowEncodeURIComponent$LWS(sourceText$LWS)])], BLOB_SCRIPT_OPTIONS$LWS));
}

const getTextContentEvaluatorHookSourceText$LWS = () => SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS;

const documentToPropertyDescriptorRegistryMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());

function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
  return function initDistortionBlockedAttribute$LWS() {
    const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
    const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`; // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.

    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
      }
    };
    return function distortionBlockedAttribute$LWS(record$LWS) {
      registerElementSetDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, distortion$LWS);
      return null;
    };
  };
}

function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalGet$LWS = ObjectLookupOwnGetter$LWS$1(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalGet$LWS, // eslint-disable-next-line prefer-arrow-callback
  function get$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function getThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function getThrowerDistortionFactoryInitializer$LWS() {
    return getThrowerDistortionFactory$LWS;
  };
}

function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalSet$LWS, // eslint-disable-next-line prefer-arrow-callback
  function set$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function setThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function setThrowerDistortionFactoryInitializer$LWS() {
    return setThrowerDistortionFactory$LWS;
  };
}

function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const {
    [key$LWS]: originalValue$LWS
  } = proto$LWS;
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalValue$LWS, // eslint-disable-next-line prefer-arrow-callback
  function value$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];

  function valueThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }

  return function valueThrowerDistortionFactoryInitializer$LWS() {
    return valueThrowerDistortionFactory$LWS;
  };
}

function createBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
  }

  return factoryInitializers$LWS;
}

function createBlockedPropertyDistortionFactoryInitializers$LWS({
  document: document$LWS
}, proto$LWS, properties$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  let descRegistryMap$LWS = documentToPropertyDescriptorRegistryMap$LWS.get(document$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (descRegistryMap$LWS === undefined) {
    descRegistryMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    documentToPropertyDescriptorRegistryMap$LWS.set(document$LWS, descRegistryMap$LWS);
  }

  let descRegistry$LWS = descRegistryMap$LWS.get(proto$LWS); // istanbul ignore else: need a test for this on the same document but different namespace

  if (descRegistry$LWS === undefined) {
    descRegistry$LWS = {
      __proto__: null
    };
    descRegistryMap$LWS.set(proto$LWS, descRegistry$LWS);
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = properties$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = properties$LWS[i$LWS];
    let safeDesc$LWS = descRegistry$LWS[prop$LWS];

    if (safeDesc$LWS === undefined) {
      var _ReflectGetOwnPropert$LWS;

      safeDesc$LWS = (_ReflectGetOwnPropert$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS)) != null ? _ReflectGetOwnPropert$LWS : null;

      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      }

      descRegistry$LWS[prop$LWS] = safeDesc$LWS;
    }

    if (safeDesc$LWS) {
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS; // istanbul ignore else

        if (getter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {}
        // because prettier won't allow a multi-line comment between
        // "else" and "if", which is where the istanbul ignore directive
        // must go to be effective.
        // istanbul ignore else: currently unreachable via tests
        if (typeof value$LWS === 'function') {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }

  return factoryInitializers$LWS;
}

function createScriptDistortion$LWS({
  sandboxEvaluator: sandboxEvaluator$LWS
}, attributeName$LWS, datasetGetter$LWS) {
  const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`; // Use a computed property to dynamically set the distortion function name
  // without using `Reflect.defineProperty()`.

  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](value$LWS) {
      const originalValue$LWS = value$LWS;
      const elementNamespaceURI$LWS = ReflectApply$LWS$1(ElementProtoNamespaceURIGetter$LWS, this, []);
      const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;

      if (value$LWS === '') {
        ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, value$LWS]);
        return;
      } // Normalize the URL.


      ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [value$LWS]);
      value$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []); // Create a dataset attribute to expose the undistorted attribute value.

      const dataset$LWS = ReflectApply$LWS$1(datasetGetter$LWS, this, []);
      dataset$LWS[`distorted${capitalizeFirstChar$LWS(attributeName$LWS)}`] = originalValue$LWS; // Create XHR.

      const hostname$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
      const xhr$LWS = new XhrCtor$LWS(); // istanbul ignore if: currently unreachable via tests

      if (ReflectApply$LWS$1(RegExpProtoTest$LWS, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS])) {
        ReflectApply$LWS$1(XhrProtoWithCredentialsSetter$LWS, xhr$LWS, [true]);
      }

      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
        const status$LWS = ReflectApply$LWS$1(XhrProtoStatusGetter$LWS, xhr$LWS, []);

        if (status$LWS === 200) {
          if (defineSrcEvaluatorProperty$LWS(this, sandboxEvaluator$LWS)) {
            const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []); // Set and run the src evaluator hook.

            ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, getSrcEvaluatorHookSourceText$LWS(responseText$LWS)]);
          }
        } else {
          // The following if statement is enclosed in a dedicated
          // else {} because prettier won't allow a multi-line
          // comment between "else" and "if", which is where the
          // istanbul ignore directive must go to be effective.
          // istanbul ignore else: cannot produce codes beyond 200, 404 in tests
          if (status$LWS === 404) {
            ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found']);
          }
        }
      }]);
      ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', value$LWS]);
      ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
    }

  };
  return distortion$LWS;
}

function initDistortionHTMLScriptElementSrcSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLScriptElement$LWS.prototype, 'src');
  return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
    const src$LWS = createScriptDistortion$LWS(record$LWS, 'src', HTMLElementProtoDatasetGetter$LWS);
    registerElementSetDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return [originalSrcSetter$LWS, src$LWS];
  };
}

function initDistortionIDBObjectStoreAdd$LWS({
  globalObject: {
    IDBObjectStore: {
      prototype: {
        add: originalAdd$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
  }];
  return function distortionIDBObjectStoreAdd$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionIDBObjectStorePut$LWS({
  globalObject: {
    IDBObjectStore: {
      prototype: {
        put: originalPut$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
  }];
  return function distortionIDBObjectStorePut$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNamedNodeMapSetNamedItem$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItem: originalSetNamedItem$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
    return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
      }

      return ReflectApply$LWS$1(originalSetNamedItem$LWS, this, args$LWS);
    }];
  };
}

function initDistortionNamedNodeMapSetNamedItemNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItemNS: originalSetNamedItemNS$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
    return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
      }

      return ReflectApply$LWS$1(originalSetNamedItemNS$LWS, this, args$LWS);
    }];
  };
}

function initDistortionNavigatorSendBeacon$LWS({
  globalObject: {
    Navigator: {
      prototype: {
        sendBeacon: originalSendBeacon$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(args$LWS[0]));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return ReflectApply$LWS$1(originalSendBeacon$LWS, this, args$LWS);
  }];
  return function distortionNavigatorSendBeacon$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNavigatorServiceWorkerGetter$LWS({
  globalObject: {
    Navigator: Navigator$LWS
  }
}) {
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Navigator$LWS.prototype, 'serviceWorker'); // istanbul ignore if: needs default platform behavior test

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, noop$LWS$1];
  return function distortionNavigatorServiceWorkerGetter$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$7$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
} = selfValidator$LWS;

function initDistortionNodeInsertBefore$LWS({
  globalObject: {
    Node: {
      prototype: {
        insertBefore: originalInsertBefore$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$7$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])} into ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])},`);
      }
    }

    return ReflectApply$LWS$1(originalInsertBefore$LWS, this, args$LWS);
  }];
  return function distortionNodeInsertBefore$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionNodeValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS
  }
}) {
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');
  return function distortionNodeValueSetter$LWS(record$LWS) {
    return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the nodeValue property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

        if (ownerEl$LWS === null) {
          ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
          return;
        }

        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [value$LWS]);
          return;
        }
      } // istanbul ignore next: needs default platform behavior test


      ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
    }];
  };
}

const {
  isSharedElement: isSharedElement$6$LWS
} = selfValidator$LWS;

function initDistortionNodeRemoveChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        removeChild: originalRemoveChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception
    // is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$6$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS$1(originalRemoveChild$LWS, this, args$LWS);
  }];
  return function distortionNodeRemoveChild$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$5$LWS
} = selfValidator$LWS;

function initDistortionNodeReplaceChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        replaceChild: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments.
    // If the "old element" argument is a valid shared element, an
    // exception is thrown.
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$5$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionNodeReplaceChild$LWS() {
    return distortionEntry$LWS;
  };
} // IMPORTANT! This validator MUST use the top "window" global object, and not
// the provided "globalObject" because magenta objects (arbitrary user-code
// created global objects) must be allowed to interact with their OWN <html>,
// <head> and <body> (within the iframe content window). Using the provided
// "globalObject" here would result in receiving a validator bound to the
// magenta global object, which would erroneously prevent code from interacting
// with that document's <html>, <head> and <body>.


const {
  isSharedElement: isSharedElement$4$LWS
} = selfValidator$LWS;

function initDistortionNodeTextContentSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalTextContentSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'textContent');
  return function distortionNodeTextContentSetter$LWS(record$LWS) {
    const {
      sandboxEvaluator: sandboxEvaluator$LWS
    } = record$LWS;
    return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
      const valueAsString$LWS = toString$LWS(value$LWS); // There are two existence of the attribute textContent, one on
      // Attr and one on Node. This first if statement is checking to
      // figure out which distortion should be applied. The instanceof
      // operator tests to see if the current global object, this,
      // is of the type Attr, while also taking inheritance into
      // consideration.
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the textContent property.
      // istanbul ignore else: needs default platform behavior test

      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

        if (ownerEl$LWS === null) {
          ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          return;
        }

        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
          return;
        }
      }

      if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        if (defineTextContentEvaluatorProperty$LWS(this, valueAsString$LWS, (sourceText$LWS, context$LWS, globalObject$LWS, document$LWS) => {
          // Set the textContent immediately after the
          // evaluator hook fires to overwrite the evaluator
          // hook source text. Subsequent sets change the
          // textContent value but are not evaluated.
          ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          sandboxEvaluator$LWS(sourceText$LWS, context$LWS, globalObject$LWS, document$LWS);
        })) {
          // Set and run the textContent evaluator hook.
          ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [getTextContentEvaluatorHookSourceText$LWS()]);
          return;
        }
      } // istanbul ignore else: needs default platform behavior test
      else if (isSharedElement$4$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set textContent of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])} elements.`);
      }

      ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
    }];
  };
}

function initDistortionNotificationCtor$LWS({
  globalObject: {
    Notification: originalNotificationCtor$LWS
  }
}) {
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalNotificationCtor$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = partialStructuredClone$LWS(args$LWS[1]);
    }

    return ReflectApply$LWS$1(originalNotificationCtor$LWS, this, args$LWS);
  }];
  return function distortionNotificationCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionRangeCreateContextualFragment$LWS({
  globalObject: {
    Range: {
      prototype: {
        createContextualFragment: originalCreateContextualFragment$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = sanitize$LWS(tagString$LWS);
      }
    }

    return ReflectApply$LWS$1(originalCreateContextualFragment$LWS, this, args$LWS);
  }];
  return function distortionRangeCreateContextualFragment$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$3$LWS
} = selfValidator$LWS;

function initDistortionRangeDeleteContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        deleteContents: originalDeleteContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$3$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS$1(originalDeleteContents$LWS, this, args$LWS);
  }];
  return function distortionRangeDeleteContents$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$2$LWS
} = selfValidator$LWS;

function initDistortionRangeExtractContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        extractContents: originalExtractContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$2$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS$1(originalExtractContents$LWS, this, args$LWS);
  }];
  return function distortionRangeExtractContents$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$1$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
} = selfValidator$LWS;

function initDistortionRangeInsertNode$LWS({
  globalObject: {
    Range: {
      prototype: {
        insertNode: originalInsertNode$LWS
      }
    }
  }
}) {
  const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Range.prototype, 'commonAncestorContainer');
  const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const commonAncestorContainer$LWS = ReflectApply$LWS$1(originalCommonAncestorContainerGetter$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$1$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS$1(originalInsertNode$LWS, this, args$LWS);
  }];
  return function distortionRangeInsertNode$LWS() {
    return distortionEntry$LWS;
  };
}

const {
  isSharedElement: isSharedElement$LWS
} = selfValidator$LWS;

function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
  return function initDistortionContentWindowGetter$LWS({
    globalObject: {
      Range: {
        // @ts-ignore: Prevent index type error.
        prototype: {
          [methodName$LWS]: originalMethod$LWS
        }
      }
    }
  }) {
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [methodName$LWS]: distortion$LWS
    } = {
      [methodName$LWS](...args$LWS) {
        if (args$LWS.length) {
          const {
            0: node$LWS
          } = args$LWS; // istanbul ignore else: needs default platform behavior test

          if (isSharedElement$LWS(node$LWS)) {
            throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}.`);
          }
        }

        return ReflectApply$LWS$1(originalMethod$LWS, this, args$LWS);
      }

    };
    const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
    return function distortionContentWindowGetter$LWS() {
      return distortionEntry$LWS;
    };
  };
}

const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEnd');
const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNode');
const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNodeContents');
const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndAfter');
const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndBefore');
const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStart');
const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartAfter');
const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartBefore');
const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('surroundContents');

function initDistortionServiceWorkerContainerProto$LWS({
  globalObject: {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionServiceWorkerContainerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionShadowRootInnerHTMLSetter$LWS({
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');
  const distortionEntry$LWS = [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
    ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }];
  return function distortionShadowRootInnerHTMLSetter$LWS() {
    return distortionEntry$LWS;
  };
}

function mode$LWS() {
  return 'closed';
}

function initDistortionShadowRootModeGetter$LWS({
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalModeGetter$LWS = ObjectLookupOwnGetter$LWS$1(ShadowRoot$LWS.prototype, 'mode');
  const distortionEntry$LWS = [originalModeGetter$LWS, mode$LWS];
  return function distortionShadowRootModeGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function SharedWorker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}

function initDistortionSharedWorkerCtor$LWS({
  globalObject: {
    SharedWorker: originalSharedWorkerCtor$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
  return function distortionSharedWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionSharedWorkerProto$LWS({
  globalObject: {
    SharedWorker: SharedWorker$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof SharedWorker$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionSharedWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [storageRootKey$LWS])) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = ArrayCtor$LWS$1(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = ReflectApply$LWS$1(StringProtoReplace$LWS, key$LWS, [storageRootKey$LWS, '']);
  }

  return keys$LWS;
}

const storageToMetaMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS); // istanbul ignore if: currently unreachable via tests

  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(storageTarget$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(storageTarget$LWS, {
    // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
    get(target$LWS, key$LWS, receiver$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$LWS$1(storage$LWS, keyForNamespace$LWS)) {
        return ReflectGet$LWS(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
      const safeDesc$LWS = unsafePartialDesc$LWS;
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);

      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDefineProperty$LWS(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDeleteProperty$LWS$1(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      let safeDesc$LWS;

      if (typeof key$LWS === 'symbol') {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } else {
        const {
          storage: storage$LWS,
          storageRootKey: storageRootKey$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, keyForNamespace$LWS);
      }

      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      }

      return safeDesc$LWS;
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },

    // istanbul ignore next: suspicious gap, currently unreachable via tests
    has(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }

      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$LWS$1(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return ReflectHas$LWS(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
  return proxy$LWS;
}

class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new LockerSecurityError$LWS('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return ReflectApply$LWS$1(StringProtoReplace$LWS, resolvedKey$LWS, [storageRootKey$LWS, '']);
    }

    return ReflectApply$LWS$1(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    return ReflectApply$LWS$1(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
      args$LWS[1] = toString$LWS(args$LWS[1]);
    }

    ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const proxy$LWS = createStorageProxy$LWS({
    __proto__: PatchedStorage$LWS.prototype
  });
  trackTargetAsLive$LWS(proxy$LWS);
  storageToMetaMap$LWS.set(proxy$LWS, {
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  });
  return proxy$LWS;
}

const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(PatchedStorageProto$LWS, 'length');

function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
  return function initDistortionStorageFactory$LWS({
    globalObject: globalObject$LWS
  }) {
    // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.
    let originalStorageObject$LWS;

    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS]; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {} // istanbul ignore if: currently unreachable via tests


    if (!isObject$LWS(originalStorageObject$LWS)) {
      return alwaysNull$LWS;
    }

    return function distortionStorageFactory$LWS({
      key: key$LWS
    }) {
      return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, getStorageRootKey$LWS(key$LWS))];
    };
  };
}

function initDistortionStorageLength$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(Storage$LWS.prototype, 'length');
  const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
  return function distortionStorageLength$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageGetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        getItem: originalStorageGetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageSetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        setItem: originalStorageSetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageKey$LWS({
  globalObject: {
    Storage: {
      prototype: {
        key: originalStorageKey$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
  return function distortionStorageKey$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageRemoveItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        removeItem: originalStorageRemoveItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
  return function distortionStorageRemoveItem$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorageClear$LWS({
  globalObject: {
    Storage: {
      prototype: {
        clear: originalStorageClear$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
  return function distortionStorageClear$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionStorage$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
  return function distortionStorage$LWS() {
    return distortionEntry$LWS;
  };
}

const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS('localStorage');
const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS('sessionStorage');

function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);

        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);

          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }

    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, function attributeName$LWS(value$LWS) {
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'from');
        distortAttribute$LWS(this, 'to');
        distortAttribute$LWS(this, 'values');
      }
    });
    return null;
  };
}

function initDistortionSVGAnimateElementFromAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function from$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', NAMESPACE_DEFAULT$LWS, from$LWS);
    return null;
  };
}

function initDistortionSVGAnimateElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    return null;
  };
}

function initDistortionSVGAnimateElementValuesAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, valuesSplit$LWS, [';']);
    }

    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', NAMESPACE_DEFAULT$LWS, values$LWS);
    return null;
  };
}

function initDistortionSVGElementDatasetGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackTargetAsLive$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionSVGElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionSVGScriptElementHrefAttribute$LWS({
  globalObject: {
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  return function distortionSVGScriptElementHrefAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'href', SVGElementProtoDatasetGetter$LWS));
    registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href', SVGElementProtoDatasetGetter$LWS));
    return null;
  };
}

function initDistortionSVGSetElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]); // istanbul ignore else: needs default platform behavior test

        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS); // istanbul ignore else: needs default platform behavior test

          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }

    function attributeName$LWS(value$LWS) {
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'to');
      }
    }

    registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
    return null;
  };
}

function initDistortionSVGSetElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
    registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    return null;
  };
}

function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactoryInitializer$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS,
          setAttributeNS: originalSetAttributeNS$LWS
        }
      },
      SVGUseElement: SVGUseElement$LWS
    }
  }) {
    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
      /* istanbul ignore next: needs default platform behavior test */
      value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }

    return function distortionHrefAttributeFactory$LWS(record$LWS) {
      registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);

      if (attributeName$LWS === 'href') {
        const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
          const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
          /* istanbul ignore next: needs default platform behavior test */
          value$LWS : sanitizeSvgHref$LWS(value$LWS);
          ReflectApply$LWS$1(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
        };

        registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
      }

      return null;
    };
  };
}

const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('href');
const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('xlink:href');

function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
  globalObject: {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  }
}) {
  var _TrustedTypePolicyFac$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator


  const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null ? void 0 : (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalCreatePolicy$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] :
    /* istanbul ignore next: needs default platform behavior test */
    undefined; // istanbul ignore else: needs default platform behavior test

    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS$1(originalCreatePolicy$LWS, this, args$LWS);
  }];
  return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
    return distortionEntry$LWS;
  };
}

const HTML_MIME_TYPES_LIST$LWS = toSafeArray$LWS$1(['text/html', 'image/svg+xml', 'text/xml']);

function initDistortionURLCreateObjectURL$LWS({
  document: document$LWS,
  globalObject: globalObject$LWS,
  globalObject: {
    MediaSource: MediaSource$LWS,
    URL: {
      createObjectURL: originalCreateObjectURL$LWS
    }
  }
}) {
  // IMPORTANT! This validator MUST use the record's global object to create
  // a validator and not rely on the `selfValidator` because the validator
  // needs to be bound to the global object of the magenta object (arbitrary
  // user-code created global objects).
  const {
    isEqualDomString: isEqualDomString$LWS
  } = getValidator$LWS(globalObject$LWS, document$LWS);
  const distortionEntry$LWS = [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [blobObject$LWS]);

    if ( // MediaSource may not be defined in some browsers.
    // https://caniuse.com/mdn-api_mediasource
    MediaSource$LWS && // MediaSource does not share the same prototype as Blob or File.
    // It can still be used with `createObjectURL()` however we need
    // to treat it separately. MediaSource does not accept plain text
    // input as Blob or File and does not have a MIME type.
    blobObject$LWS instanceof MediaSource$LWS) {
      return outURL$LWS;
    }

    const blobType$LWS = ReflectApply$LWS$1(BlobProtoTypeGetter$LWS, blobObject$LWS, []);

    if (blobType$LWS === '') {
      // Browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      const plainTextBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, undefined, 'text/plain']);
      return ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
    }

    const loweredBlobType$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, blobType$LWS, []);

    if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
      const blobSize$LWS = ReflectApply$LWS$1(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
      const normalizedBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
      URLRevokeObjectURL$LWS(outURL$LWS);
      outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new XhrCtor$LWS();
      ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', outURL$LWS, false]);
      ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
      const sanitizer$LWS = blobSanitizer$LWS();
      const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS(`Cannot 'createObjectURL' using a unsecure ${toSafeTemplateStringValue$LWS(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
      return outURL$LWS;
    }

    URLRevokeObjectURL$LWS(outURL$LWS);
    throw new LockerSecurityError$LWS('Unsupported MIME type.');
  }];
  return function distortionURLCreateObjectURL$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowFetch$LWS({
  globalObject: {
    fetch: originalFetch$LWS
  }
}) {
  const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(ReflectApply$LWS$1(RequestProtoURLGetter$LWS, url$LWS, []));
      } else {
        parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (!isValidURL$LWS(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
      }
    }

    return ReflectApply$LWS$1(originalFetch$LWS, this, args$LWS);
  }];
  return function distortionWindowFetch$LWS() {
    return distortionEntry$LWS;
  };
}
/* eslint-disable class-methods-use-this, max-classes-per-file */
// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target


class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }

  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }

  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }

  isExtensible(_target$LWS) {
    return true;
  }

  ownKeys(_target$LWS) {
    return [];
  }

  preventExtensions(_target$LWS) {
    return true;
  }

  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }

  setPrototypeOf(_target$LWS) {
    return false;
  }

}

ReflectSetPrototypeOf$LWS$1(BaseFrameHandler$LWS.prototype, null);
ObjectFreeze$LWS$1(BaseFrameHandler$LWS.prototype);

class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

ObjectFreeze$LWS$1(ShadowFramesPrototypeHandler$LWS.prototype);

function initDistortionWindowFramesGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'frames'); // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const createFramesProxy$LWS = () => {
    const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS$1(globalObject$LWS);
    const WindowProperties$LWS = ReflectGetPrototypeOf$LWS$1(WindowPrototype$LWS); // Wrap `WindowLengthGetter` in bound function to obscure the getter
    // source as "[native code]".

    const framesLengthGetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]); // Wrap `noop` in bound function to obscure the setter source as
    // "[native code]".

    const framesLengthSetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, noop$LWS$1, []);

    const getFrameByIndexKey$LWS = key$LWS => {
      const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;

      if (possibleIndex$LWS > -1 && NumberIsInteger$LWS(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, [])) {
        const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);

        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }

      return undefined;
    };

    const getFrameByNameKey$LWS = key$LWS => {
      if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
      !ObjectHasOwn$LWS$1(globalObject$LWS, key$LWS) && // ...Or its prototype.
      !ObjectHasOwn$LWS$1(WindowPrototype$LWS, key$LWS)) {
        const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);

        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }

      return undefined;
    };

    const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);

    class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getValueByKey$LWS(key$LWS);
        return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : // window.frames.length
        // window.frames[n]
        // window.frames['n']
        value$LWS;
      }

      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        if (key$LWS === 'length') {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            get: framesLengthGetter$LWS,
            set: framesLengthSetter$LWS
          };
        }

        const value$LWS = getFrameByIndexKey$LWS(key$LWS);

        if (value$LWS) {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }

        return undefined;
      } // istanbul ignore next: suspicious gap, currently unreachable via tests


      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
      }

      ownKeys() {
        const {
          length: length$LWS
        } = globalObject$LWS;
        const keys$LWS = ArrayCtor$LWS$1(length$LWS + 1);

        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          keys$LWS[i$LWS] = `${i$LWS}`;
        }

        keys$LWS[length$LWS] = 'length';
        return keys$LWS;
      }

    }

    ObjectFreeze$LWS$1(ShadowFrameHandler$LWS.prototype);

    class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) :
        /* istanbul ignore next: needs default platform behavior test */
        value$LWS;
      }

      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);

        if (value$LWS === undefined) {
          return value$LWS;
        }

        return {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: value$LWS,
          writable: false
        };
      } // istanbul ignore next: suspicious gap, currently unreachable via tests


      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
      }

      ownKeys() {
        const keys$LWS = [];
        let keysOffset$LWS = 0;
        const descMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
        ReflectSetPrototypeOf$LWS$1(descMap$LWS, null);

        for (const key$LWS in descMap$LWS) {
          // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
          if (typeof key$LWS === 'string') {
            const unsafeDesc$LWS = descMap$LWS[key$LWS];

            if (ObjectHasOwn$LWS$1(unsafeDesc$LWS, 'value') && isWindow$LWS(unsafeDesc$LWS.value)) {
              keys$LWS[keysOffset$LWS++] = key$LWS;
            }
          }
        }

        return keys$LWS;
      }

    }

    ObjectFreeze$LWS$1(ShadowWindowPropertiesHandler$LWS.prototype); // In order to preserve window.frames === window.frames, create a
    // shadow target object, to be used with the proxy object that is
    // returned by accesses to window.frames.

    const shadowFrames$LWS = {};
    const shadowFramesPrototype$LWS = {};
    const shadowWindowProperties$LWS = {};
    const shadowFramesHandler$LWS = ObjectFreeze$LWS$1(new ShadowFrameHandler$LWS());
    const shadowFramesPrototypeHandler$LWS = ObjectFreeze$LWS$1(new ShadowFramesPrototypeHandler$LWS());
    const shadowWindowPropertiesHandler$LWS = ObjectFreeze$LWS$1(new ShadowWindowPropertiesHandler$LWS());
    const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
    const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
    ReflectSetPrototypeOf$LWS$1(shadowFrames$LWS, framesPrototypeProxy$LWS);
    ReflectSetPrototypeOf$LWS$1(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
    return new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
  };

  let framesProxy$LWS;
  const distortionEntry$LWS = [originalWindowFramesGetter$LWS, // eslint-disable-next-line prefer-arrow-callback
  function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      framesProxy$LWS = createFramesProxy$LWS();
    }

    return framesProxy$LWS;
  }];
  return function distortionWindowFramesGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowGetComputedStyle$LWS({
  globalObject: {
    getComputedStyle: originalGetComputedStyle$LWS
  }
}) {
  const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
    return trackTargetAsLive$LWS(ReflectApply$LWS$1(originalGetComputedStyle$LWS, this, args$LWS));
  }];
  return function distortionWindowGetComputedStyle$LWS() {
    return distortionEntry$LWS;
  };
}

function length$LWS() {
  return 0;
}

function initDistortionWindowLengthGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'length'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalLengthGetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
  return function distortionWindowLengthGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function onstorage$LWS() {
  throw new LockerSecurityError$LWS('Cannot set window.onstorage.');
}

function initDistortionWindowOnstorage$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  const originalOnstorageSetter$LWS = ObjectLookupOwnSetter$LWS(globalObject$LWS, 'onstorage'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionMapEntry$LWS = [originalOnstorageSetter$LWS, onstorage$LWS];
  return function distortionWindowOnstorage$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, Window$LWS, 'storage');
    return distortionMapEntry$LWS;
  };
}

function initDistortionWindowOpen$LWS({
  globalObject: {
    open: originalWindowOpen$LWS
  }
}) {
  const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    return ReflectApply$LWS$1(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
  }];
  return function distortionWindowOpen$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowPostMessage$LWS({
  globalObject: {
    postMessage: originalPostMessage$LWS
  }
}) {
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
  }];
  return function distortionWindowPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWindowSetInterval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setInterval: originalSetInterval$LWS
  }
}) {
  return function distortionWndowSetInterval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;

        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toString$LWS(callback$LWS); // Defer transforming source text asynchronously.

          let transformedSourceText$LWS; // Replace callback parameter.

          args$LWS[0] = () => {
            if (transformedSourceText$LWS === undefined) {
              transformedSourceText$LWS = transformUncompiledSourceText$LWS(sourceText$LWS);
            }

            sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
          };
        }
      }

      return ReflectApply$LWS$1(originalSetInterval$LWS, this, args$LWS);
    }];
  };
}

function initDistortionWindowSetTimeout$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setTimeout: originalSetTimeout$LWS
  }
}) {
  return function distortionWindowSetTimeout$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;

        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

          args$LWS[0] = () => {
            // Defer transforming source text asynchronously.
            sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
          };
        }
      }

      return ReflectApply$LWS$1(originalSetTimeout$LWS, this, args$LWS);
    }];
  };
}

function initDistortionWindowStructuredClone$LWS({
  // @ts-ignore: Prevent property existence error.
  globalObject: {
    structuredClone: originalStructuredClone$LWS
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalStructuredClone$LWS !== 'function') {
    return alwaysNull$LWS;
  }

  const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
  }];
  return function distortionWindowStructuredClone$LWS() {
    return distortionEntry$LWS;
  };
}

function Worker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}

function initDistortionWorkerCtor$LWS({
  globalObject: {
    Worker: originalWorkerCtor$LWS
  }
}) {
  const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
  return function distortionWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionWorkerProto$LWS({
  globalObject: {
    Worker: {
      prototype: originalPrototype$LWS
    }
  }
}) {
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestOpen$LWS({
  globalObject: {
    XMLHttpRequest: {
      prototype: {
        open: originalOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
  }];
  return function distortionXMLHttpRequestOpen$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestResponseGetter$LWS({
  globalObject: {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'response');
  const distortionEntry$LWS = [originalResponseGetter$LWS, function response$LWS() {
    const rawResponse$LWS = ReflectApply$LWS$1(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS) :
    /* istanbul ignore next: needs default platform behavior test */
    rawResponse$LWS;
  }];
  return function distortionXMLHttpRequestResponseGetter$LWS() {
    return distortionEntry$LWS;
  };
}

function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
  globalObject: {
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'responseXML');
  const distortionEntry$LWS = [originalResponseXMLGetter$LWS, function responseXML$LWS() {
    const rawResponseXML$LWS = ReflectApply$LWS$1(originalResponseXMLGetter$LWS, this, []);
    return sanitizeDocument$LWS(rawResponseXML$LWS);
  }];
  return function distortionXMLHttpRequestResponseXMLGetter$LWS() {
    return distortionEntry$LWS;
  };
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const internalDistortionFactoryInitializers$LWS = [// CSSStyleRule
initDistortionCSSStyleRuleStyleGetter$LWS, // Document
initDistortionDocumentDomainSetter$LWS, initDistortionDocumentExecCommand$LWS, initDistortionDocumentOpen$LWS, // DOMParser
initDistortionDOMParserParseFromString$LWS, // Element
initDistortionElementAttachShadow$LWS, initDistortionElementAttributesGetter$LWS, initDistortionElementInnerHTMLSetter$LWS, initDistortionElementOuterHTMLSetter$LWS, initDistortionElementInsertAdjacentHTML$LWS, initDistortionElementRemove$LWS, initDistortionElementReplaceChildren$LWS, initDistortionElementReplaceWith$LWS, // Event
initDistortionEventComposedPath$LWS, initDistortionEventPathGetter$LWS, // Function
initDistortionFunction$LWS, // History
initDistortionHistoryPushState$LWS, initDistortionHistoryReplaceState$LWS, // HTMLElement
initDistortionHTMLElementDatasetGetter$LWS, initDistortionHTMLElementInnerTextSetter$LWS, initDistortionHTMLElementOuterTextSetter$LWS, initDistortionHTMLElementStyleGetter$LWS, // HTMLIFrameElement
initDistortionHTMLIFrameElementSrcSetter$LWS, // HTMLLinkElement
initDistortionHTMLLinkElementRelSetter$LWS, initDistortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
initDistortionHTMLObjectElementDataSetter$LWS, // HTMLScriptElement
initDistortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
initDistortionIDBObjectStoreAdd$LWS, initDistortionIDBObjectStorePut$LWS, // Navigator
initDistortionNavigatorSendBeacon$LWS, initDistortionNavigatorServiceWorkerGetter$LWS, // Node
initDistortionNodeRemoveChild$LWS, initDistortionNodeReplaceChild$LWS, // Notification
initDistortionNotificationCtor$LWS, // Range
initDistortionRangeCreateContextualFragment$LWS, initDistortionRangeDeleteContents$LWS, initDistortionRangeExtractContents$LWS, initDistortionRangeInsertNode$LWS, initDistortionRangeSelectNode$LWS, initDistortionRangeSelectNodeContents$LWS, initDistortionRangeSetEnd$LWS, initDistortionRangeSetEndAfter$LWS, initDistortionRangeSetEndBefore$LWS, initDistortionRangeSetStart$LWS, initDistortionRangeSetStartAfter$LWS, initDistortionRangeSetStartBefore$LWS, initDistortionRangeSurroundContents$LWS, // ServiceWorkerContainer
initDistortionServiceWorkerContainerProto$LWS, // ShadowRoot
initDistortionShadowRootInnerHTMLSetter$LWS, initDistortionShadowRootModeGetter$LWS, // SharedWorker
initDistortionSharedWorkerCtor$LWS, initDistortionSharedWorkerProto$LWS, // Storage
initDistortionStorageLength$LWS, initDistortionStorageGetItem$LWS, initDistortionStorageSetItem$LWS, initDistortionStorageKey$LWS, initDistortionStorageRemoveItem$LWS, initDistortionStorageClear$LWS, initDistortionStorage$LWS, // SVGAnimateElement
initDistortionSVGAnimateElementFromAttribute$LWS, initDistortionSVGAnimateElementToAttribute$LWS, initDistortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
initDistortionSVGElementDatasetGetter$LWS, // SVGSetElement
initDistortionSVGSetElementToAttribute$LWS, // SVGUseElement
initDistortionSVGUseElementHrefAttribute$LWS, initDistortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
initDistortionURLCreateObjectURL$LWS, // Window
initDistortionWindowFetch$LWS, initDistortionWindowFramesGetter$LWS, initDistortionWindowGetComputedStyle$LWS, initDistortionWindowLengthGetter$LWS, initDistortionWindowOpen$LWS, initDistortionWindowPostMessage$LWS, initDistortionWindowStructuredClone$LWS, // Worker
initDistortionWorkerCtor$LWS, initDistortionWorkerProto$LWS, // XHR
initDistortionXMLHttpRequestOpen$LWS, initDistortionXMLHttpRequestResponseGetter$LWS, initDistortionXMLHttpRequestResponseXMLGetter$LWS];
const internalKeyedDistortionFactoryInitializers$LWS = [// Attr
initDistortionAttrValueSetter$LWS, // Aura
initDistortionAuraUtilGlobalEval$LWS, // CacheStorage
initDistortionCacheStorageDelete$LWS, initDistortionCacheStorageHas$LWS, initDistortionCacheStorageKeys$LWS, initDistortionCacheStorageMatch$LWS, initDistortionCacheStorageOpen$LWS, // CookieStore
initDistortionCookieStoreDelete$LWS, initDistortionCookieStoreGet$LWS, initDistortionCookieStoreGetAll$LWS, initDistortionCookieStoreOnChange$LWS, initDistortionCookieStoreSet$LWS, // Document
initDistortionDocumentCookieGetter$LWS, initDistortionDocumentCookieSetter$LWS, initDistortionDocumentReplaceChildren$LWS, // CustomElementRegistry
initDistortionCustomElementRegistryGet$LWS, // Element
initDistortionElementSetAttribute$LWS, initDistortionElementSetAttributeNode$LWS, initDistortionElementSetAttributeNodeNS$LWS, initDistortionElementSetAttributeNS$LWS, initDistortionElementToggleAttribute$LWS, // EventTarget
initDistortionEventTargetAddEventListener$LWS, // HTMLScriptElement,
initDistortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
initDistortionNamedNodeMapSetNamedItem$LWS, initDistortionNamedNodeMapSetNamedItemNS$LWS, // Node
initDistortionNodeValueSetter$LWS, initDistortionNodeTextContentSetter$LWS, // Storage
initDistortionLocalStorage$LWS, initDistortionSessionStorage$LWS, // SVGAnimationElement
initDistortionSVGAnimateElementAttributeNameAttribute$LWS, // SVGScriptElement
initDistortionSVGScriptElementHrefAttribute$LWS, // SVGSetElement
initDistortionSVGSetElementAttributeNameAttribute$LWS, // Window
initDistortionWindowOnstorage$LWS, initDistortionWindowSetInterval$LWS, initDistortionWindowSetTimeout$LWS];
const externalDistortionFactoryInitializers$LWS = ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, [// Element
initDistortionElementAfter$LWS, initDistortionElementAppend$LWS, initDistortionElementBefore$LWS, initDistortionElementInsertAdjacentElement$LWS, initDistortionElementPrepend$LWS, initDistortionElementShadowRootGetter$LWS, // Node
// The initDistortionNodeAppendChild distortion is temporarily disabled
// until W-10409618 is resolved..
// initDistortionNodeAppendChild,
initDistortionNodeInsertBefore$LWS]);
const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
const evaluationDistortionFactoryInitializers$LWS = [// eval
initDistortionEval$LWS];
const opaqueDistortionFactoryInitializers$LWS = [// Window
initDistortionWindowPostMessage$LWS];
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument']; // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];

const {
  apply: ReflectApply$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn$LWS(object$LWS, __key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [__key$LWS]);
};

function ObjectLookupOwnGetter$LWS(object$LWS, __key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, __key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [__key$LWS]);
}

const {
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = Symbol;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  filter: ArrayProtoFilter$LWS,
  find: ArrayProtoFind$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  shift: ArrayProtoShift$LWS,
  slice: ArrayProtoSlice$LWS,
  some: ArrayProtoSome$LWS,
  sort: ArrayProtoSort$LWS,
  splice: ArrayProtoSplice$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  unshift: ArrayProtoUnshift$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  push: ArrayProtoPush$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;

function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}

const ErrorCtor$LWS = Error;
const TypeErrorCtor$LWS = TypeError;

function noop$LWS() {// No operation performed.
}

const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  has: WeakMapProtoHas$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;

function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}
/**
 * This file contains an exportable (portable) function `init()` used to initialize
 * one side of a membrane on any realm. The only prerequisite is the ability to
 * evaluate the sourceText of the `init()` function there. Once evaluated, the
 * function will return a set of values that can be used to wire up the side of
 * the membrane with another existing `init()` function from another realm, in
 * which case they will exchange callable functions that are required to connect
 * the two realms via the membrane.
 *
 * About the mechanics of the membrane, there are few important considerations:
 *
 * 1. Pointers are the way to pass reference to object and functions.
 * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed
 *    to represent the absence of a value.
 * 3. The realm that owns the object or function is responsible for projecting
 *    the proxy onto the other side (via callablePushTarget), which returns a
 *    Pointer that can be used by the realm to pass the reference to the same
 *    proxy over and over again.
 * 4. The realm that owns the proxy (after the other side projects it into it)
 *    will hold a Pointer alongside the proxy to signal what original object or
 *    function should the foreign operation operates, it is always the first
 *    argument of the foreign callable for proxies, and the other side can use
 *    it via `selectedTarget!`.
 */


const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS()); // istanbul ignore next

function createMembraneMarshall$LWS(_globalObject$LWS) {
  var _ReflectApply$LWS, _ref$LWS, _ref2$LWS;
  /* eslint-disable prefer-object-spread */


  const ArrayCtor$LWS = Array;
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const ErrorCtor$LWS = Error;
  const NumberCtor$LWS = Number;
  const ObjectCtor$LWS = Object;
  const ProxyCtor$LWS = Proxy;
  const ReflectRef$LWS = Reflect;
  const RegExpCtor$LWS = RegExp;
  const StringCtor$LWS = String;
  const SymbolCtor$LWS = Symbol;
  const TypeErrorCtor$LWS = TypeError; // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow

  const WeakMapCtor$LWS = WeakMap;
  const {
    for: SymbolFor$LWS,
    toStringTag: SymbolToStringTag$LWS
  } = SymbolCtor$LWS;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = ReflectRef$LWS;
  const {
    assign: ObjectAssign$LWS,
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS,
    getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    isFrozen: ObjectIsFrozen$LWS,
    isSealed: ObjectIsSealed$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS,
    seal: ObjectSeal$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
    propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __defineGetter__: ObjectProtoDefineGetter$LWS,
    __defineSetter__: ObjectProtoDefineSetter$LWS,
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : (object$LWS, __key$LWS) => ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [__key$LWS]);
  const IS_IN_SHADOW_REALM$LWS = typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerDebugMode') : undefined;
  const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembraneSerializedValue') : undefined;
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = !IS_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembrane') : undefined;
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue'); // The default stack trace limit in Chrome is 10.
  // Set to 20 to account for stack trace filtering.

  const LOCKER_STACK_TRACE_LIMIT$LWS = 20; // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime.

  const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
  /* $LWS */
  1}`.includes('*'); // Indicate whether debug support is available.

  const LOCKER_DEBUGGABLE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS && !IS_IN_SHADOW_REALM$LWS; // BigInt is not supported in Safari 13.1.
  // https://caniuse.com/bigint

  const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : undefined; // Minification safe reference to the private `BoundaryProxyHandler`
  // 'serializedValue' property name.

  let MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS; // Minification safe references to the private `BoundaryProxyHandler`
  // 'apply' and 'construct' trap variant's property names.

  let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
  const {
    isArray: isArrayOrThrowForRevoked$LWS
  } = ArrayCtor$LWS;
  const {
    includes: ArrayProtoIncludes$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    slice: ArrayProtoSlice$LWS
  } = ArrayCtor$LWS.prototype;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;
  const {
    toString: ErrorProtoToString$LWS
  } = ErrorCtor$LWS.prototype;
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  const {
    isInteger: NumberIsInteger$LWS
  } = NumberCtor$LWS;
  const {
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS.prototype;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS,
    toString: RegExProtoToString$LWS
  } = RegExpProto$LWS; // Edge 15 does not support RegExp.prototype.flags.
  // https://caniuse.com/mdn-javascript_builtins_regexp_flags

  const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['flags'])) != null ? _ReflectApply$LWS : function flags$LWS() {
    const _string$LWS = ReflectApply$LWS(RegExProtoToString$LWS, this, []);
    return ReflectApply$LWS(RegExpProtoExec$LWS, FLAGS_REG_EXP$LWS, [_string$LWS])[0];
  } : undefined;
  const RegExpProtoSourceGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['source']);
  const {
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringCtor$LWS.prototype;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS.prototype;
  const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, // eslint-disable-next-line no-proto
  Uint8Array.prototype.__proto__, ['length']);
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    has: WeakMapProtoHas$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  const consoleObject$LWS = !IS_IN_SHADOW_REALM$LWS && typeof console === 'object' && console !== null ? console : undefined;
  const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
  const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : undefined;
  const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = _globalObject$LWS != null ? _globalObject$LWS : // Support for globalThis was added in Chrome 71.
  // https://caniuse.com/mdn-javascript_builtins_globalthisfor
  typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2$LWS : // However, environments like Android emulators are running Chrome 69.
  // eslint-disable-next-line no-restricted-globals
  typeof self !== 'undefined' ? self : undefined) != null ? _ref$LWS : ( // See https://mathiasbynens.be/notes/globalthis for more details.
  ReflectDefineProperty$LWS(ObjectProto$LWS, 'globalThis', {
    __proto__: null,
    configurable: true,

    get() {
      ReflectDeleteProperty$LWS(ObjectProto$LWS, 'globalThis'); // Safari 12 on iOS 12.1 has a `this` of `undefined` so we
      // fallback to `self`.
      // eslint-disable-next-line no-restricted-globals

      return this != null ? this : self;
    }

  }), globalThis); // Install flags to ensure things are installed once per realm.

  let installedErrorPrepareStackTraceFlag$LWS = false;
  let installedPropertyDescriptorMethodWrappersFlag$LWS = false;

  function alwaysFalse$LWS() {
    return false;
  }

  const installErrorPrepareStackTrace$LWS = LOCKER_UNMINIFIED_FLAG$LWS ? () => {
    if (installedErrorPrepareStackTraceFlag$LWS) {
      return;
    }

    installedErrorPrepareStackTraceFlag$LWS = true; // Feature detect the V8 stack trace API.
    // https://v8.dev/docs/stack-trace-api

    const CallSite$LWS = (() => {
      try {
        var _callSites$$LWS;

        ErrorCtor$LWS.prepareStackTrace = (_error$LWS, callSites) => callSites;

        const callSites = new ErrorCtor$LWS().stack;
        ReflectDeleteProperty$LWS(ErrorCtor$LWS, 'prepareStackTrace');
        return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : undefined; // eslint-disable-next-line no-empty
      } catch (__unused$LWS) {}

      return undefined;
    })();

    if (typeof CallSite$LWS !== 'function') {
      return;
    }

    const {
      getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
      getFunctionName: CallSiteProtoGetFunctionName$LWS,
      toString: CallSiteProtoToString$LWS
    } = CallSite$LWS.prototype; // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.

    const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS(`${// Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.
    ReflectApply$LWS(StringProtoReplace$LWS, LOCKER_IDENTIFIER_MARKER$LWS, [/[\\^$.*+?()[\]{}|]/g, '\\$&']) // Function name references in call sites also contain
    // the name of the class they belong to,
    // e.g. myClassName.myFunctionName.
    }(?=\\.|$)`);

    const formatStackTrace = function formatStackTrace(error, callSites) {
      // Based on V8's default stack trace formatting:
      // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371
      let stackTrace$LWS = '';

      try {
        stackTrace$LWS = ReflectApply$LWS(ErrorProtoToString$LWS, error, []);
      } catch (_unused2$LWS) {
        stackTrace$LWS = '<error>';
      }

      let consecutive$LWS = false;

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = callSites; _i$LWS < _length$LWS; _i$LWS += 1) {
        const callSite$LWS = callSites[_i$LWS];
        const funcName$LWS = ReflectApply$LWS(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
        let isMarked$LWS = false;

        if (typeof funcName$LWS === 'string' && funcName$LWS !== 'eval' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
          isMarked$LWS = true;
        }

        if (!isMarked$LWS) {
          const evalOrigin$LWS = ReflectApply$LWS(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);

          if (typeof evalOrigin$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
            isMarked$LWS = true;
          }
        } // Only write a single LWS entry per consecutive LWS stacks.


        if (isMarked$LWS) {
          if (!consecutive$LWS) {
            consecutive$LWS = true;
            stackTrace$LWS += '\n    at LWS';
          }

          continue;
        } else {
          consecutive$LWS = false;
        }

        try {
          stackTrace$LWS += `\n    at ${ReflectApply$LWS(CallSiteProtoToString$LWS, callSite$LWS, [])}`; // eslint-disable-next-line no-empty
        } catch (_unused3$LWS) {}
      }

      return stackTrace$LWS;
    };

    try {
      // Error.prepareStackTrace cannot be a bound or proxy wrapped
      // function, so to obscure its source we wrap the call to
      // formatStackTrace().
      ErrorCtor$LWS.prepareStackTrace = function prepareStackTrace(error, callSites) {
        return formatStackTrace(error, callSites);
      }; // eslint-disable-next-line no-empty

    } catch (_unused4$LWS) {}

    try {
      const {
        stackTraceLimit: stackTraceLimit$LWS
      } = ErrorCtor$LWS;

      if (typeof stackTraceLimit$LWS !== 'number' || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
        ErrorCtor$LWS.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
      } // eslint-disable-next-line no-empty

    } catch (_unused5$LWS) {}
  } : noop$LWS;

  function noop$LWS() {// No-operation.
  }

  const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? bigIntObject$LWS => // Section 21.2.3 Properties of the BigInt Prototype Object
  // https://tc39.es/ecma262/#thisbigintvalue
  // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
  //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
  ReflectApply$LWS(BigIntProtoValueOf$LWS, bigIntObject$LWS, []) : noop$LWS;
  const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? booleanObject$LWS => // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  ReflectApply$LWS(BooleanProtoValueOf$LWS, booleanObject$LWS, []) : noop$LWS;
  const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? numberObject$LWS => // 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  ReflectApply$LWS(NumberProtoValueOf$LWS, numberObject$LWS, []) : noop$LWS;
  const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? __value$LWS => {
    // 22.2.5.12 get RegExp.prototype.source
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (__value$LWS !== RegExpProto$LWS) {
      const source$LWS = ReflectApply$LWS(RegExpProtoSourceGetter$LWS, __value$LWS, []);
      return JSONStringify$LWS({
        __proto__: null,
        flags: ReflectApply$LWS(RegExpProtoFlagsGetter$LWS, __value$LWS, []),
        source: source$LWS
      });
    }

    return undefined;
  } : noop$LWS;
  const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? stringObject$LWS => // 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  ReflectApply$LWS(StringProtoValueOf$LWS, stringObject$LWS, []) : noop$LWS;
  const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? symbolObject$LWS => // 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  ReflectApply$LWS(SymbolProtoValueOf$LWS, symbolObject$LWS, []) : noop$LWS;
  const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []);

    switch (brand$LWS) {
      // The brand checks below represent boxed primitives of
      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
      // which are not remapped or reflective.
      case '[object Boolean]':
        return serializeBooleanObject$LWS(__target$LWS);

      case '[object Number]':
        return serializeNumberObject$LWS(__target$LWS);

      case '[object RegExp]':
        return serializeRegExp$LWS(__target$LWS);

      case '[object String]':
        return serializeStringObject$LWS(__target$LWS);

      case '[object Object]':
        try {
          // Symbol.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
          return serializeSymbolObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
        } catch (_unused6$LWS) {}

        if (SUPPORTS_BIG_INT$LWS) {
          // BigInt.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
          try {
            return serializeBigIntObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
          } catch (_unused7$LWS) {}
        }

      // eslint-disable-next-line no-fallthrough

      default:
        return undefined;
    }
  } : noop$LWS;
  const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
    // The serialization attempts below represent boxed primitives of
    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
    // which are not remapped or reflective.
    try {
      // Symbol.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
      return serializeSymbolObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}

    if (SUPPORTS_BIG_INT$LWS) {
      // BigInt.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
      try {
        return serializeBigIntObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
      } catch (_unused9$LWS) {}
    }

    try {
      return serializeBooleanObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused10$LWS) {}

    try {
      return serializeNumberObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused11$LWS) {}

    try {
      return serializeRegExp$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}

    try {
      return serializeStringObject$LWS(__target$LWS); // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}

    return undefined;
  } : noop$LWS;

  function toSafeTemplateStringValue$LWS(__value$LWS) {
    if (typeof __value$LWS === 'string') {
      return __value$LWS;
    }

    try {
      if (typeof __value$LWS === 'object' && __value$LWS !== null) {
        const _result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __value$LWS, []);
        return _result$LWS === '[object Symbol]' ? ReflectApply$LWS(SymbolProtoToString$LWS, __value$LWS, []) : _result$LWS;
      }

      if (typeof __value$LWS === 'function') {
        return ReflectApply$LWS(FunctionProtoToString$LWS, __value$LWS, []);
      } // Attempt to coerce `value` to a string with the String() constructor.
      // Section 22.1.1.1 String ( value )
      // https://tc39.es/ecma262/#sec-string-constructor-string-value


      return StringCtor$LWS(__value$LWS); // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}

    return '[Object Unknown]';
  } // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }

  return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, options$LWS) {
    if (IS_IN_SHADOW_REALM$LWS) {
      options$LWS = undefined;
    }

    const {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS // eslint-disable-next-line prefer-object-spread

    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    !IS_IN_SHADOW_REALM$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
    const arityToApplyTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const arityToConstructTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const localProxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const proxyTargetToPointerMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
    let foreignCallablePushErrorTarget$LWS;
    let foreignCallablePushTarget$LWS;
    let foreignCallableApply$LWS;
    let foreignCallableConstruct$LWS;
    let foreignCallableDefineProperty$LWS;
    let foreignCallableDeleteProperty$LWS;
    let foreignCallableGet$LWS;
    let foreignCallableGetOwnPropertyDescriptor$LWS;
    let foreignCallableGetPrototypeOf$LWS;
    let foreignCallableHas$LWS;
    let foreignCallableIsExtensible$LWS;
    let foreignCallableOwnKeys$LWS;
    let foreignCallablePreventExtensions$LWS;
    let foreignCallableSet$LWS;
    let foreignCallableSetPrototypeOf$LWS;
    let foreignCallableDebugInfo$LWS;
    let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableGetTargetIntegrityTraits$LWS;
    let foreignCallableGetToStringTagOfTarget$LWS;
    let foreignCallableGetTypedArrayIndexedValue$LWS;
    let foreignCallableInstallErrorPrepareStackTrace$LWS;
    let foreignCallableIsTargetLive$LWS;
    let foreignCallableIsTargetRevoked$LWS;
    let foreignCallableSerializeTarget$LWS;
    let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
    let nearMembraneSymbolFlag$LWS = false;
    let lastProxyTrapCalled$LWS = 0;
    let selectedTarget$LWS;
    const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, __key$LWS, state$LWS) => {
      state$LWS[__key$LWS] = false;
      const foreignTargetPointer$LWS = getTransferablePointer$LWS(__target$LWS);
      let _safeDesc$LWS;

      try {
        foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        });
      } catch (error) {
        var _selectedTarget$LWS;

        const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }

      if (_safeDesc$LWS) {
        ReflectDefineProperty$LWS(__target$LWS, __key$LWS, _safeDesc$LWS);
      } else {
        ReflectDeleteProperty$LWS(__target$LWS, __key$LWS);
      }
    } : noop$LWS;
    let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
      try {
        if (ObjectHasOwn$LWS(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
          checkDebugMode$LWS = () => true;

          installErrorPrepareStackTrace$LWS();
          foreignCallableInstallErrorPrepareStackTrace$LWS();
        }
      } catch (_unused15$LWS) {
        checkDebugMode$LWS = alwaysFalse$LWS;
      }

      return false;
    } : alwaysFalse$LWS;

    function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget');
      }

      let protoPointerOrNull$LWS;

      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
          const descriptors$LWS = {};

          for (let _i$LWS = 0, {
            length: _length$LWS
          } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
            const __key$LWS = descriptorTuples$LWS[_i$LWS];
            descriptors$LWS[__key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], // configurable
            descriptorTuples$LWS[_i$LWS + 2], // enumerable
            descriptorTuples$LWS[_i$LWS + 3], // writable
            descriptorTuples$LWS[_i$LWS + 4], // valuePointer
            descriptorTuples$LWS[_i$LWS + 5], // getterPointer
            descriptorTuples$LWS[_i$LWS + 6] // setterPointer
            );
          } // Use `ObjectDefineProperties()` instead of individual
          // `ReflectDefineProperty()` calls for better performance.


          ObjectDefineProperties$LWS(shadowTarget$LWS, descriptors$LWS);
        });
      } catch (error) {
        var _selectedTarget2$LWS;

        const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _proto$LWS;

      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        _proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _proto$LWS = null;
      }

      ReflectSetPrototypeOf$LWS(shadowTarget$LWS, _proto$LWS);

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }
    }

    function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}()`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrap$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 0) {
          var _arityToApplyOrConstr$LWS;

          return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS);
        } catch (error) {
          var _selectedTarget3$LWS;

          const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(1)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForOneOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 1) {
          var _arityToApplyOrConstr2$LWS;

          return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS);
        } catch (error) {
          var _selectedTarget4$LWS;

          const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(2)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 2) {
          var _arityToApplyOrConstr3$LWS;

          return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS);
        } catch (error) {
          var _selectedTarget5$LWS;

          const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(3)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 3) {
          var _arityToApplyOrConstr4$LWS;

          return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS);
        } catch (error) {
          var _selectedTarget6$LWS;

          const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(4)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 4) {
          var _arityToApplyOrConstr5$LWS;

          return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS, // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS);
        } catch (error) {
          var _selectedTarget7$LWS;

          const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const activityName$LWS = `Reflect.${isApplyTrap$LWS ? 'apply' : 'construct'}(5)`;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? arityToApplyTrapNameRegistry$LWS : arityToConstructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;

        if (_length$LWS !== 5) {
          var _arityToApplyOrConstr6$LWS;

          return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }

        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS);
        } // @ts-ignore: Prevent private property access error.


        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;

        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS,
            4: arg4$LWS
          } = _args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS, // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS, // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS, // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS, // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS, // Inline getTransferableValue().
          typeof arg4$LWS === 'object' && arg4$LWS !== null || typeof arg4$LWS === 'function' ? getTransferablePointer$LWS(arg4$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg4$LWS === 'undefined' ? undefined : arg4$LWS);
        } catch (error) {
          var _selectedTarget8$LWS;

          const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1
      /* ProxyHandlerTraps.Apply */
      ;
      const nativeMethodName$LWS = isApplyTrap$LWS ? 'apply' : 'construct';
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS; // @ts-ignore: Prevent private property access error.

        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: _length$LWS
        } = _args$LWS;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(`Reflect.${nativeMethodName$LWS}(${_length$LWS})`);
        }

        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let combinedOffset$LWS = 2;
        const combinedArgs$LWS = new ArrayCtor$LWS(_length$LWS + combinedOffset$LWS);
        combinedArgs$LWS[0] = foreignTargetPointer$LWS;
        let pointerOrPrimitive$LWS;

        try {
          combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS;

          for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
            const arg$LWS = _args$LWS[_i$LWS]; // Inlining `getTransferableValue()`.

            combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === 'object' && arg$LWS !== null || typeof arg$LWS === 'function' ? getTransferablePointer$LWS(arg$LWS) : // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg$LWS === 'undefined' ? undefined : arg$LWS;
          }

          pointerOrPrimitive$LWS = ReflectApply$LWS(foreignCallableApplyOrConstruct$LWS, undefined, combinedArgs$LWS);
        } catch (error) {
          var _selectedTarget9$LWS;

          const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _result$LWS;

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      };
    }

    function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
      const _safeDesc$LWS = {
        __proto__: null
      };

      if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.configurable = configurable$LWS;
      }

      if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.enumerable = enumerable$LWS;
      }

      if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        _safeDesc$LWS.writable = writable$LWS;
      }

      if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof getterPointerOrPrimitive$LWS === 'function') {
          getterPointerOrPrimitive$LWS();
          _safeDesc$LWS.get = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.get = undefined;
        }
      }

      if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof setterPointerOrPrimitive$LWS === 'function') {
          setterPointerOrPrimitive$LWS();
          _safeDesc$LWS.set = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.set = undefined;
        }
      }

      if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof valuePointerOrPrimitive$LWS === 'function') {
          valuePointerOrPrimitive$LWS();
          _safeDesc$LWS.value = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
        }
      }

      return _safeDesc$LWS;
    }

    function createPointer$LWS(originalTarget$LWS) {
      const pointer$LWS = () => {
        // assert: selectedTarget is undefined
        selectedTarget$LWS = originalTarget$LWS;
      };

      return pointer$LWS;
    }

    const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? __target$LWS => {
      let state$LWS = localProxyTargetToLazyPropertyDescriptorStateMap$LWS.get(__target$LWS);

      if (state$LWS === undefined) {
        const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS));

        if (typeof statePointerOrUndefined$LWS === 'function') {
          statePointerOrUndefined$LWS();
          state$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;

          if (state$LWS) {
            localProxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
          }
        }
      }

      return state$LWS;
    } : noop$LWS;

    function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
      let proxyPointer$LWS = proxyTargetToPointerMap$LWS.get(originalTarget$LWS);

      if (proxyPointer$LWS) {
        return proxyPointer$LWS;
      }

      let distortionTarget$LWS;

      if (distortionCallback$LWS) {
        distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS); // If a distortion entry is found, it must be a valid proxy target.

        if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
          throw new TypeErrorCtor$LWS(`Invalid distortion ${toSafeTemplateStringValue$LWS(originalTarget$LWS)}.`);
        }
      } else {
        distortionTarget$LWS = originalTarget$LWS;
      }

      let isPossiblyRevoked$LWS = true;
      let targetFunctionArity$LWS = 0;
      let targetFunctionName$LWS = '';
      let targetTypedArrayLength$LWS = 0;
      let targetTraits$LWS = 16
      /* TargetTraits.IsObject */
      ;

      if (typeof distortionTarget$LWS === 'function') {
        isPossiblyRevoked$LWS = false;
        targetFunctionArity$LWS = 0;
        targetTraits$LWS = 4
        /* TargetTraits.IsFunction */
        ;

        try {
          // Detect arrow functions.
          if (!('prototype' in distortionTarget$LWS)) {
            targetTraits$LWS |= 8
            /* TargetTraits.IsArrowFunction */
            ;
          }

          const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'length');

          if (safeLengthDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeLengthDesc$LWS, null);
            const {
              value: safeLengthDescValue$LWS
            } = safeLengthDesc$LWS;

            if (typeof safeLengthDescValue$LWS === 'number') {
              targetFunctionArity$LWS = safeLengthDescValue$LWS;
            }
          }

          const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'name') : undefined;
          if (safeNameDesc$LWS) ;
        } catch (_unused16$LWS) {
          isPossiblyRevoked$LWS = true;
        }
      } else if (ArrayBufferIsView$LWS(distortionTarget$LWS)) {
        isPossiblyRevoked$LWS = false;
        targetTraits$LWS = 2
        /* TargetTraits.IsArrayBufferView */
        ;

        try {
          targetTypedArrayLength$LWS = ReflectApply$LWS(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
          targetTraits$LWS |= 32
          /* TargetTraits.IsTypedArray */
          ; // eslint-disable-next-line no-empty
        } catch (_unused17$LWS) {
          // Could be a DataView object or a revoked proxy.
          isPossiblyRevoked$LWS = true;
        }
      }

      if (isPossiblyRevoked$LWS) {
        try {
          if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
            targetTraits$LWS = 1
            /* TargetTraits.IsArray */
            ;
          }
        } catch (_unused18$LWS) {
          targetTraits$LWS = 64
          /* TargetTraits.Revoked */
          ;
        }
      }

      proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS); // The WeakMap is populated with the original target rather then the
      // distorted one while the pointer always uses the distorted one.
      // TODO: This mechanism poses another issue, which is that the return
      // value of selectedTarget! can never be used to call across the
      // membrane because that will cause a wrapping around the potential
      // distorted value instead of the original value. This is not fatal,
      // but implies that for every distorted value where are two proxies
      // that are not ===, which is weird. Guaranteeing this is not easy
      // because it means auditing the code.

      proxyTargetToPointerMap$LWS.set(originalTarget$LWS, proxyPointer$LWS);
      return proxyPointer$LWS;
    }

    const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? unforgeableGlobalThisKeys$LWS => {
      if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
        return;
      }

      installedPropertyDescriptorMethodWrappersFlag$LWS = true; // We wrap property descriptor methods to activate lazy
      // descriptors and/or workaround browser bugs. The following
      // methods are wrapped:
      //   Object.getOwnPropertyDescriptors()
      //   Object.getOwnPropertyDescriptor()
      //   Reflect.defineProperty()
      //   Reflect.getOwnPropertyDescriptor()
      //   Object.prototype.__defineGetter__()
      //   Object.prototype.__defineSetter__()
      //   Object.prototype.__lookupGetter__()
      //   Object.prototype.__lookupSetter__()
      //
      // Chromium based browsers have a bug that nulls the result
      // of `window` getters in detached iframes when the property
      // descriptor of `window.window` is retrieved.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
      //
      // Methods may be poisoned when they interact with the `window`
      // object and retrieve property descriptors, like 'window',
      // that contain the `window` object itself. The following
      // built-in methods are susceptible to this issue:
      //     console.log(window);
      //     Object.getOwnPropertyDescriptors(window);
      //     Object.getOwnPropertyDescriptor(window, 'window');
      //     Reflect.getOwnPropertyDescriptor(window, 'window');
      //     window.__lookupGetter__('window');
      //     window.__lookupSetter__('window');
      //
      // We side step issues with `console` by mapping it to the
      // primary realm's `console`. Since we're already wrapping
      // property descriptor methods to activate lazy descriptors
      // we use the wrapper to workaround the `window` getter
      // nulling bug.

      const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0; // Lazily populated by `getUnforgeableGlobalThisGetter()`;

      const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
        __proto__: null
      } : undefined;
      const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? {
        configurable: false,
        enumerable: ReflectApply$LWS(ObjectProtoPropertyIsEnumerable$LWS, __target$LWS, [__key$LWS]),
        get: getUnforgeableGlobalThisGetter$LWS(__key$LWS),
        set: undefined
      } : ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS) : undefined;
      const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? __key$LWS => {
        let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[__key$LWS];

        if (globalThisGetter$LWS === undefined) {
          // Wrap `unboundGlobalThisGetter` in bound function
          // to obscure the getter source as "[native code]".
          globalThisGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS, unboundGlobalThisGetter$LWS, []); // Preserve identity continuity of getters.

          keyToGlobalThisGetterRegistry$LWS[__key$LWS] = globalThisGetter$LWS;
        }

        return globalThisGetter$LWS;
      } : undefined;
      const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(__key$LWS) : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, __target$LWS, [__key$LWS]) : undefined;
      const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, __target$LWS, [__key$LWS]) : undefined;
      const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : undefined;

      const wrapDefineAccessOrProperty$LWS = originalFunc$LWS => {
        const {
          length: originalFuncLength$LWS
        } = originalFunc$LWS; // `__defineGetter__()` and `__defineSetter__()` have
        // function lengths of 2 while `Reflect.defineProperty()`
        // has a function length of 3.

        const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
        return new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
            if (_args$LWS.length >= originalFuncLength$LWS) {
              const __target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : _args$LWS[0];

              if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
                const __key$LWS = useThisArgAsTarget$LWS ? _args$LWS[0] : _args$LWS[1];
                const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

                if (state$LWS != null && state$LWS[__key$LWS]) {
                  // Activate the descriptor by triggering
                  // its getter.
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  __target$LWS[__key$LWS];
                }
              }
            }

            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }

        });
      };

      const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          if (_args$LWS.length && (typeof thisArg$LWS === 'object' && thisArg$LWS !== null || typeof thisArg$LWS === 'function')) {
            const {
              0: __key$LWS
            } = _args$LWS;
            const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);

            if (state$LWS != null && state$LWS[__key$LWS]) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              thisArg$LWS[__key$LWS];
            }

            if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
              return lookupFixedAccessor$LWS(thisArg$LWS, __key$LWS);
            }
          }

          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
        }

      });

      const wrapGetOwnPropertyDescriptor$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          if (_args$LWS.length > 1) {
            const {
              0: __target$LWS,
              1: __key$LWS
            } = _args$LWS;

            if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
              const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

              if (state$LWS != null && state$LWS[__key$LWS]) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                __target$LWS[__key$LWS];
              }

              if (shouldFixChromeBug$LWS && __target$LWS === globalThisRef$LWS) {
                return getFixedDescriptor$LWS(__target$LWS, __key$LWS);
              }
            }
          }

          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
        }

      });

      const wrapGetOwnPropertyDescriptors$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
          const __target$LWS = _args$LWS.length ? _args$LWS[0] : undefined;

          if (!(typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function')) {
            // Defer to native method to throw exception.
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }

          const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
          const isFixingChromeBug$LWS = __target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
          const unsafeDescMap$LWS = isFixingChromeBug$LWS ? // Create an empty property descriptor map
          // to populate with curated descriptors.
          {} : // Since this is not a global object it is
          // safe to use the native method.
          ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, _args$LWS);

          if (!isFixingChromeBug$LWS && state$LWS === undefined) {
            // Exit early if the target is not a global
            // object and there are no lazy descriptors.
            return unsafeDescMap$LWS;
          }

          const ownKeys$LWS = ReflectOwnKeys$LWS(isFixingChromeBug$LWS ? __target$LWS : unsafeDescMap$LWS);

          for (let _i$LWS = 0, {
            length: _length$LWS
          } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
            const ownKey$LWS = ownKeys$LWS[_i$LWS];
            const isLazyProp$LWS = !!(state$LWS != null && state$LWS[ownKey$LWS]);

            if (isLazyProp$LWS) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              __target$LWS[ownKey$LWS];
            }

            if (isLazyProp$LWS || isFixingChromeBug$LWS) {
              const _unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(__target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, ownKey$LWS); // Update the descriptor map entry.

              if (_unsafeDesc$LWS) {
                unsafeDescMap$LWS[ownKey$LWS] = _unsafeDesc$LWS;
              } else if (!isFixingChromeBug$LWS) {
                ReflectDeleteProperty$LWS(unsafeDescMap$LWS, ownKey$LWS);
              }
            }
          }

          return unsafeDescMap$LWS;
        }

      });

      try {
        ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS); // eslint-disable-next-line no-empty
      } catch (_unused19$LWS) {}

      try {
        ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS); // eslint-disable-next-line no-empty
      } catch (_unused20$LWS) {}

      try {
        ObjectCtor$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS); // eslint-disable-next-line no-empty
      } catch (_unused21$LWS) {}

      try {
        ObjectCtor$LWS.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS); // eslint-disable-next-line no-empty
      } catch (_unused22$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused23$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused24$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS, lookupFixedGetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused25$LWS) {}

      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS, lookupFixedSetter$LWS); // eslint-disable-next-line no-empty
      } catch (_unused26$LWS) {}
    } : noop$LWS;

    function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('lookupForeignDescriptor');
      }

      let protoPointerOrNull$LWS;
      let _safeDesc$LWS;

      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
          _safeDesc$LWS = {
            __proto__: null,
            foreign: true
          };

          if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.configurable = configurable$LWS;
          }

          if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.enumerable = enumerable$LWS;
          }

          if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            _safeDesc$LWS.writable = writable$LWS;
          }

          if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof getterPointerOrPrimitive$LWS === 'function') {
              getterPointerOrPrimitive$LWS();
              _safeDesc$LWS.get = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.get = undefined;
            }
          }

          if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof setterPointerOrPrimitive$LWS === 'function') {
              setterPointerOrPrimitive$LWS();
              _safeDesc$LWS.set = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.set = undefined;
            }
          }

          if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof valuePointerOrPrimitive$LWS === 'function') {
              valuePointerOrPrimitive$LWS();
              _safeDesc$LWS.value = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
            }
          }

          if (configurable$LWS === false) {
            // Update the descriptor to non-configurable on
            // the shadow target.
            ReflectDefineProperty$LWS(shadowTarget$LWS, __key$LWS, _safeDesc$LWS);
          }
        });
      } catch (error) {
        var _selectedTarget10$LWS;

        const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      if (_safeDesc$LWS === undefined) {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;

        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }

        while (currentObject$LWS) {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(currentObject$LWS, __key$LWS);

          if (_safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
            break;
          }

          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }

        if (_safeDesc$LWS) {
          var _ref3$LWS;

          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: localValue$LWS
          } = _safeDesc$LWS;
          const possibleProxy$LWS = (_ref3$LWS = _getter$LWS != null ? _getter$LWS : _setter$LWS) != null ? _ref3$LWS : localValue$LWS;
          _safeDesc$LWS.foreign = (typeof possibleProxy$LWS === 'object' && possibleProxy$LWS !== null || typeof possibleProxy$LWS === 'function') && proxyTargetToPointerMap$LWS.get(possibleProxy$LWS) !== undefined;
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _safeDesc$LWS;
    }

    function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
      const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS); // Following the specification steps for
      // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).
      // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor

      if (_safeDesc$LWS) {
        if ('get' in _safeDesc$LWS || 'set' in _safeDesc$LWS) {
          const {
            set: _setter$LWS
          } = _safeDesc$LWS;

          if (_setter$LWS) {
            if (_safeDesc$LWS.foreign) {
              foreignCallableApply$LWS(getTransferablePointer$LWS(_setter$LWS), // Inline getTransferableValue().
              typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof __receiver$LWS === 'undefined' ? undefined : __receiver$LWS, // Inline getTransferableValue().
              typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof __value$LWS === 'undefined' ? undefined : __value$LWS);
            } else {
              // Even though the setter function exists, we can't
              // use `ReflectSet()` because there might be a
              // distortion for that setter function, in which
              // case we must resolve the local setter and call
              // it instead.
              ReflectApply$LWS(_setter$LWS, __receiver$LWS, [__value$LWS]);
            } // If there is a setter, it either throw or we can assume
            // the value was set.


            return true;
          }

          return false;
        }

        if (_safeDesc$LWS.writable === false) {
          return false;
        }
      } // Exit early if receiver is not object like.


      if (!(typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function')) {
        return false;
      }

      const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__receiver$LWS, __key$LWS);

      if (safeReceiverDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeReceiverDesc$LWS, null); // Exit early for accessor descriptors or non-writable data
        // descriptors.

        if ('get' in safeReceiverDesc$LWS || 'set' in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
          return false;
        } // Setting the descriptor with only a value entry should not
        // affect existing descriptor traits.


        ReflectDefineProperty$LWS(__receiver$LWS, __key$LWS, {
          __proto__: null,
          value: __value$LWS
        });
        return true;
      } // `ReflectDefineProperty()` and `ReflectSet()` both are expected
      // to return `false` when attempting to add a new property if the
      // receiver is not extensible.


      return ReflectDefineProperty$LWS(__receiver$LWS, __key$LWS, {
        __proto__: null,
        configurable: true,
        enumerable: true,
        value: __value$LWS,
        writable: true
      });
    }

    function pushErrorAcrossBoundary$LWS(error) {
      if (LOCKER_DEBUGGABLE_FLAG$LWS) {
        checkDebugMode$LWS();
      } // Inline getTransferableValue().


      if (typeof error === 'object' && error !== null || typeof error === 'function') {
        const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
        foreignErrorPointer$LWS();
      }

      return error;
    }

    function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
      const {
        proxy: _proxy$LWS
      } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      proxyTargetToPointerMap$LWS.set(_proxy$LWS, foreignTargetPointer$LWS);
      return createPointer$LWS(_proxy$LWS);
    }

    const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, state$LWS) => {
      localProxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
      foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS), getTransferablePointer$LWS(state$LWS));
    } : noop$LWS;

    class BoundaryProxyHandler$LWS {
      constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        let shadowTarget$LWS;
        const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1
        /* TargetTraits.IsArray */
        ;
        const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4
        /* TargetTraits.IsFunction */
        ;

        if (isForeignTargetFunction$LWS) {
          // This shadow target is never invoked. It's needed to avoid
          // proxy trap invariants. Because it's not invoked the code
          // does not need to be instrumented for code coverage.
          //
          // istanbul ignore next
          shadowTarget$LWS = foreignTargetTraits$LWS & 8
          /* TargetTraits.IsArrowFunction */
          ? () => {} : function () {};
        } else if (isForeignTargetArray$LWS) {
          shadowTarget$LWS = [];
        } else {
          shadowTarget$LWS = {};
        }

        const {
          proxy: _proxy$LWS,
          revoke: revoke$LWS
        } = ProxyRevocable$LWS(shadowTarget$LWS, this);
        this.foreignTargetPointer = foreignTargetPointer$LWS;
        this.foreignTargetTraits = foreignTargetTraits$LWS;
        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS; // Define in the BoundaryProxyHandler constructor so it is bound
        // to the BoundaryProxyHandler instance.

        this.nonConfigurableDescriptorCallback = (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          // Update the descriptor to non-configurable on the shadow
          // target.
          ReflectDefineProperty$LWS(this.shadowTarget, __key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
        };

        this.proxy = _proxy$LWS;
        this.revoke = revoke$LWS;
        this.serializedValue = undefined;
        this.shadowTarget = shadowTarget$LWS;
        this.staticToStringTag = 'Object'; // Define traps.

        if (isForeignTargetFunction$LWS) {
          var _arityToApplyTrapName$LWS, _arityToConstructTrap$LWS;

          this.apply = this[(_arityToApplyTrapName$LWS = arityToApplyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _arityToApplyTrapName$LWS : arityToApplyTrapNameRegistry$LWS.n];
          this.construct = this[(_arityToConstructTrap$LWS = arityToConstructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _arityToConstructTrap$LWS : arityToConstructTrapNameRegistry$LWS.n];
        }

        this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
        this.get = foreignTargetTraits$LWS & 32
        /* TargetTraits.IsTypedArray */
        ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
        this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
        this.set = BoundaryProxyHandler$LWS.defaultSetTrap;

        if (foreignTargetTraits$LWS & 64
        /* TargetTraits.Revoked */
        ) {
          // Future optimization: Hoping proxies with frozen handlers
          // can be faster.
          ObjectFreeze$LWS(this);
          this.revoke();
        } else if (IS_IN_SHADOW_REALM$LWS) {
          if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2
          /* TargetTraits.IsArrayBufferView */
          ) {
            this.makeProxyLive();
          }
        } else {
          if (foreignTargetTraits$LWS & 16
          /* TargetTraits.IsObject */
          ) {
            // Lazily define serializedValue.
            let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
            const {
              serializedValue: serializedValue$LWS
            } = this;

            if (MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS === undefined) {
              // A minification safe way to get the 'serializedValue'
              // property name.
              ({
                0: MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS
              } = ObjectKeys$LWS({
                serializedValue: serializedValue$LWS
              }));
            }

            ReflectApply$LWS(ObjectProtoDefineGetter$LWS, this, [MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME$LWS, () => {
              if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
                cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
              }

              return cachedSerializedValue$LWS;
            }]);
          } // Future optimization: Hoping proxies with frozen handlers
          // can be faster. If local mutations are not trapped, then
          // freezing the handler is ok because it is not expecting to
          // change in the future.


          ObjectFreeze$LWS(this);
        }
      } // Internal shadow realm side utilities:


      makeProxyLive() {
        // Replace pending traps with live traps that can work with the
        // target without taking snapshots.
        this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
        this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
        this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap; // Future optimization: Hoping proxies with frozen handlers can
        // be faster.

        ObjectFreeze$LWS(this);
      }

      makeProxyStatic() {
        // Reset all traps except apply and construct for static proxies
        // since the proxy target is the shadow target and all operations
        // are going to be applied to it rather than the real target.
        this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
        this.get = BoundaryProxyHandler$LWS.staticGetTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
        this.has = BoundaryProxyHandler$LWS.staticHasTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
        this.set = BoundaryProxyHandler$LWS.staticSetTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          shadowTarget: shadowTarget$LWS
        } = this; // We don't wrap `foreignCallableGetTargetIntegrityTraits()`
        // in a try-catch because it cannot throw.

        const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS);

        if (targetIntegrityTraits$LWS & 8
        /* TargetIntegrityTraits.Revoked */
        ) {
          // Future optimization: Hoping proxies with frozen
          // handlers can be faster.
          ObjectFreeze$LWS(this); // the target is a revoked proxy, in which case we revoke
          // this proxy as well.

          this.revoke();
          return;
        } // A proxy can revoke itself when traps are triggered and break
        // the membrane, therefore we need protection.


        try {
          copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
        } catch (_unused27$LWS) {
          // We don't wrap `foreignCallableIsTargetRevoked()` in a
          // try-catch because it cannot throw.
          if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS)) {
            // Future optimization: Hoping proxies with frozen
            // handlers can be faster.
            ObjectFreeze$LWS(this);
            this.revoke();
            return;
          }
        }

        if (foreignTargetTraits$LWS & 16
        /* TargetTraits.IsObject */
        && !(SymbolToStringTag$LWS in shadowTarget$LWS)) {
          let toStringTag$LWS = 'Object';

          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS); // eslint-disable-next-line no-empty
          } catch (_unused28$LWS) {}

          this.staticToStringTag = toStringTag$LWS;
        } // Preserve the semantics of the target.


        if (targetIntegrityTraits$LWS & 4
        /* TargetIntegrityTraits.IsFrozen */
        ) {
          ObjectFreeze$LWS(shadowTarget$LWS);
        } else {
          if (targetIntegrityTraits$LWS & 2
          /* TargetIntegrityTraits.IsSealed */
          ) {
            ObjectSeal$LWS(shadowTarget$LWS);
          } else if (targetIntegrityTraits$LWS & 1
          /* TargetIntegrityTraits.IsNotExtensible */
          ) {
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }

          if (LOCKER_UNMINIFIED_FLAG$LWS) {
            // We don't wrap `foreignCallableDebugInfo()` in a try-catch
            // because it cannot throw.
            foreignCallableDebugInfo$LWS('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer$LWS);
          }
        } // Future optimization: Hoping proxies with frozen handlers can
        // be faster.


        ObjectFreeze$LWS(this);
      } // Passthru traps:


      static passthruDefinePropertyTrap(_shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
        lastProxyTrapCalled$LWS = 4
        /* ProxyHandlerTraps.DefineProperty */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.defineProperty');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
        } = this;
        const safePartialDesc$LWS = _unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS(safePartialDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = safePartialDesc$LWS;
        const valuePointer$LWS = 'value' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const getterPointer$LWS = 'get' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const setterPointer$LWS = 'set' in safePartialDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, __key$LWS, 'configurable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, nonConfigurableDescriptorCallback$LWS);
        } catch (error) {
          var _selectedTarget11$LWS;

          const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruDeletePropertyTrap(_shadowTarget$LWS, __key$LWS) {
        lastProxyTrapCalled$LWS = 8
        /* ProxyHandlerTraps.DeleteProperty */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.deleteProperty');
        }

        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, __key$LWS);
        } catch (error) {
          var _selectedTarget12$LWS;

          const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 64
        /* ProxyHandlerTraps.GetPrototypeOf */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.getPrototypeOf');
        }

        let protoPointerOrNull$LWS;

        try {
          protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
        } catch (error) {
          var _selectedTarget13$LWS;

          const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        let _proto$LWS;

        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          _proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _proto$LWS = null;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _proto$LWS;
      }

      static passthruIsExtensibleTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 256
        /* ProxyHandlerTraps.IsExtensible */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.isExtensible');
        }

        const {
          shadowTarget: shadowTarget$LWS
        } = this;
        let _result$LWS = false; // Check if already locked.

        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;

          try {
            _result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget14$LWS;

            const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          }

          if (!_result$LWS) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruOwnKeysTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 512
        /* ProxyHandlerTraps.OwnKeys */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.ownKeys');
        }

        let ownKeys$LWS;

        try {
          foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (..._args$LWS) => {
            ownKeys$LWS = _args$LWS;
          });
        } catch (error) {
          var _selectedTarget15$LWS;

          const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return ownKeys$LWS || [];
      }

      static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, __key$LWS) {
        lastProxyTrapCalled$LWS = 32
        /* ProxyHandlerTraps.GetOwnPropertyDescriptor */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.getOwnPropertyDescriptor');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let _safeDesc$LWS;

        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);

            if (_safeDesc$LWS.configurable === false) {
              // Update the descriptor to non-configurable on
              // the shadow target.
              ReflectDefineProperty$LWS(shadowTarget$LWS, __key$LWS, _safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget16$LWS;

          const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _safeDesc$LWS;
      }

      static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 1024
        /* ProxyHandlerTraps.PreventExtensions */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.preventExtensions');
        }

        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let _result$LWS = true;

        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          let resultEnum$LWS = 0
          /* PreventExtensionsResult.None */
          ;

          try {
            resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget17$LWS;

            const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          } // If the target is a proxy it might reject the
          // preventExtension call, in which case we should not
          // attempt to lock down the shadow target.


          if (!(resultEnum$LWS & 1
          /* PreventExtensionsResult.Extensible */
          )) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }

          _result$LWS = !(resultEnum$LWS & 2
          /* PreventExtensionsResult.False */
          );
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruSetPrototypeOfTrap(_shadowTarget$LWS, _proto$LWS) {
        lastProxyTrapCalled$LWS = 4096
        /* ProxyHandlerTraps.SetPrototypeOf */
        ;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS('Reflect.setPrototypeOf');
        }

        const transferableProto$LWS = _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
        let _result$LWS = false;

        try {
          _result$LWS = foreignCallableSetPrototypeOf$LWS(this.foreignTargetPointer, transferableProto$LWS);
        } catch (error) {
          var _selectedTarget18$LWS;

          const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

      static passthruSetTrap(_shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048
        /* ProxyHandlerTraps.Set */
        ;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          proxy: _proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this; // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot

        if (typeof __value$LWS === 'undefined') {
          __value$LWS = undefined;
        }

        if (typeof __receiver$LWS === 'undefined') {
          __receiver$LWS = _proxy$LWS;
        }

        const isFastPath$LWS = _proxy$LWS === __receiver$LWS;
        let activity$LWS;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(isFastPath$LWS ? 'Reflect.set' : 'passthruForeignTraversedSet');
        }

        let _result$LWS = false;

        try {
          _result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, __key$LWS, // Inline getTransferableValue().
          typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS, LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
        } catch (error) {
          var _selectedTarget19$LWS;

          const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }

        return _result$LWS;
      }

    } // Logic implementation of all traps.
    // Hybrid traps:
    // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):


    BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridGetTrap');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: _proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);
      let _result$LWS;

      if (_safeDesc$LWS) {
        const {
          get: _getter$LWS,
          value: localValue$LWS
        } = _safeDesc$LWS;

        if (_getter$LWS) {
          if (_safeDesc$LWS.foreign) {
            const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
            const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
            typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
            let pointerOrPrimitive$LWS;

            try {
              pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
            } catch (error) {
              var _selectedTarget20$LWS;

              const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
              selectedTarget$LWS = undefined;

              if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                activity$LWS.error(errorToThrow$LWS);
              }

              throw errorToThrow$LWS;
            }

            if (typeof pointerOrPrimitive$LWS === 'function') {
              pointerOrPrimitive$LWS();
              _result$LWS = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              _result$LWS = pointerOrPrimitive$LWS;
            }
          } else {
            // Even though the getter function exists,
            // we can't use `ReflectGet()` because there
            // might be a distortion for that getter function,
            // in which case we must resolve the local getter
            // and call it instead.
            _result$LWS = ReflectApply$LWS(_getter$LWS, __receiver$LWS, []);
          }
        } else {
          _result$LWS = localValue$LWS;
        }
      } else {
        const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
        typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
        let pointerOrPrimitive$LWS;

        try {
          pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
        } catch (error) {
          var _selectedTarget21$LWS;

          const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }

        if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16
        /* TargetTraits.IsObject */
        ) {
          let toStringTag$LWS;

          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget22$LWS;

            const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
            selectedTarget$LWS = undefined;

            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }

            throw errorToThrow$LWS;
          } // The default language toStringTag is "Object". If we
          // receive "Object" we return `undefined` to let the
          // language resolve it naturally without projecting a
          // value.


          if (toStringTag$LWS !== 'Object') {
            _result$LWS = toStringTag$LWS;
          }
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridGetTrapForTypedArray');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
        proxy: _proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      const _possibleIndex$LWS = typeof __key$LWS === 'string' ? +__key$LWS : -1;
      let _result$LWS;

      if (_possibleIndex$LWS > -1 && _possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS(_possibleIndex$LWS)) {
        try {
          _result$LWS = foreignCallableGetTypedArrayIndexedValue$LWS(foreignTargetPointer$LWS, __key$LWS);
        } catch (error) {
          var _selectedTarget23$LWS;

          const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
          selectedTarget$LWS = undefined;

          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }

          throw errorToThrow$LWS;
        }
      } else {
        const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);

        if (_safeDesc$LWS) {
          const {
            get: _getter$LWS,
            value: localValue$LWS
          } = _safeDesc$LWS;

          if (_getter$LWS) {
            if (_safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
              const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : // Inline getTransferableValue().
              typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
              let pointerOrPrimitive$LWS;

              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget24$LWS;

                const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
                selectedTarget$LWS = undefined;

                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                  activity$LWS.error(errorToThrow$LWS);
                }

                throw errorToThrow$LWS;
              }

              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                _result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                _result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              _result$LWS = ReflectApply$LWS(_getter$LWS, __receiver$LWS, []);
            }
          } else {
            _result$LWS = localValue$LWS;
          }
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS) {
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('hybridHasTrap');
      }

      let trueOrProtoPointerOrNull$LWS;

      try {
        trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, __key$LWS);
      } catch (error) {
        var _selectedTarget25$LWS;

        const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _result$LWS = false;

      if (trueOrProtoPointerOrNull$LWS === true) {
        _result$LWS = true;
      } else {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;

        if (typeof trueOrProtoPointerOrNull$LWS === 'function') {
          trueOrProtoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }

        while (currentObject$LWS) {
          if (ObjectHasOwn$LWS(currentObject$LWS, __key$LWS)) {
            _result$LWS = true;
            break;
          }

          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.passthruGetTrap = !IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      // Only allow accessing near-membrane symbol values if the
      // BoundaryProxyHandler.has trap has been called immediately
      // before and the symbol does not exist.
      nearMembraneSymbolFlag$LWS && (nearMembraneSymbolFlag$LWS = lastProxyTrapCalled$LWS === 128
      /* ProxyHandlerTraps.Has */
      );
      lastProxyTrapCalled$LWS = 16
      /* ProxyHandlerTraps.Get */
      ;

      if (nearMembraneSymbolFlag$LWS) {
        // Exit without performing a [[Get]] for near-membrane
        // symbols because we know when the nearMembraneSymbolFlag
        // is on that there is no shadowed symbol value.
        if (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS) {
          return true;
        }

        if (__key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS) {
          return this.serializedValue;
        }
      }

      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('Reflect.get');
      }

      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: _proxy$LWS
      } = this;

      if (typeof __receiver$LWS === 'undefined') {
        __receiver$LWS = _proxy$LWS;
      }

      const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS : // Inline getTransferableValue().
      typeof __receiver$LWS === 'object' && __receiver$LWS !== null || typeof __receiver$LWS === 'function' ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
      let pointerOrPrimitive$LWS;

      try {
        pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
      } catch (error) {
        var _selectedTarget26$LWS;

        const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      }

      let _result$LWS;

      if (typeof pointerOrPrimitive$LWS === 'function') {
        pointerOrPrimitive$LWS();
        _result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _result$LWS = pointerOrPrimitive$LWS;
      }

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.passthruHasTrap = !IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, __key$LWS) {
      lastProxyTrapCalled$LWS = 128
      /* ProxyHandlerTraps.Has */
      ;
      let activity$LWS;

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS('Reflect.has');
      }

      let _result$LWS;

      try {
        _result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, __key$LWS);
      } catch (error) {
        var _selectedTarget27$LWS;

        const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
        selectedTarget$LWS = undefined;

        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error(errorToThrow$LWS);
        }

        throw errorToThrow$LWS;
      } // The near-membrane symbol flag is on if the symbol does not
      // exist on the object or its [[Prototype]].


      nearMembraneSymbolFlag$LWS = !_result$LWS && (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS);

      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.stop();
      }

      return _result$LWS;
    } : alwaysFalse$LWS; // Pending traps:

    BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.defineProperty(shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.deleteProperty(shadowTarget$LWS, __key$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.preventExtensions(shadowTarget$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, _proto$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.setPrototypeOf(shadowTarget$LWS, _proto$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }

      return this.set(shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
    } : alwaysFalse$LWS; //  Static traps:

    BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS : noop$LWS;
    BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS : () => null;
    BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, __key$LWS, __receiver$LWS) {
      const {
        foreignTargetTraits: foreignTargetTraits$LWS,
        staticToStringTag: staticToStringTag$LWS
      } = this;
      const _result$LWS = ReflectGet$LWS(shadowTarget$LWS, __key$LWS, __receiver$LWS);

      if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16
      /* TargetTraits.IsObject */
      && // The default language toStringTag is "Object". If we
      // receive "Object" we return `undefined` to let the
      // language resolve it naturally without projecting a
      // value.
      staticToStringTag$LWS !== 'Object' && !(__key$LWS in shadowTarget$LWS)) {
        return staticToStringTag$LWS;
      }

      return _result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS : () => [];
    BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS : alwaysFalse$LWS; // Default traps:
    // Pending traps are needed for the shadow realm side of the membrane
    // to avoid leaking mutation operations on the primary realm side.

    BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
    BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
    BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
    BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
    BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
    BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
    BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
    BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
    BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
    BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
    BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap; // Export callable hooks to a foreign realm.

    foreignCallableHooksCallback$LWS( // globalThisPointer
    // When crossing, should be mapped to the foreign globalThis
    createPointer$LWS(globalThisRef$LWS), // getSelectedTarget
    !IS_IN_SHADOW_REALM$LWS ? () => {
      const _result$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      return _result$LWS;
    } : noop$LWS, // getTransferableValue
    __value$LWS => {
      if (typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function') {
        return getTransferablePointer$LWS(__value$LWS);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      return typeof __value$LWS === 'undefined' ? undefined : __value$LWS;
    }, // callableGetPropertyValuePointer: this callable function allows
    // the foreign realm to access a linkable pointer for a property value.
    // In order to do that, the foreign side must provide a pointer and
    // a key access the value in order to produce a pointer
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const __value$LWS = __target$LWS == null ? void 0 : __target$LWS[__key$LWS]; // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot

      return createPointer$LWS(typeof __value$LWS === 'undefined' ? undefined : __value$LWS);
    }, // callableEvaluate
    IS_IN_SHADOW_REALM$LWS ? _sourceText$LWS => {
      let _result$LWS;

      try {
        _result$LWS = localEval$LWS(_sourceText$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : _result$LWS;
    } : noop$LWS, // callableLinkPointers: this callable function allows the foreign
    // realm to define a linkage between two values across the membrane.
    (targetPointer$LWS, newPointer$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
        proxyTargetToPointerMap$LWS.set(__target$LWS, newPointer$LWS);
      }
    }, // callablePushErrorTarget
    LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
      const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);

      const pointerWrapper$LWS = () => {
        checkDebugMode$LWS();
        return pointer$LWS();
      };

      return pointerWrapper$LWS;
    } : pushTarget$LWS, // callablePushTarget: This function can be used by a foreign realm
    // to install a proxy into this realm that correspond to an object
    // from the foreign realm. It returns a Pointer that can be used by
    // the foreign realm to pass back a reference to this realm when
    // passing arguments or returning from a foreign callable invocation.
    // This function is extremely important to understand the mechanics
    // of this membrane.
    pushTarget$LWS, // callableApply
    (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ..._args$LWS) => {
      targetPointer$LWS();
      const func$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let thisArg$LWS;

      if (typeof thisArgPointerOrUndefined$LWS === 'function') {
        thisArgPointerOrUndefined$LWS();
        thisArg$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _args$LWS[_i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, _args$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableConstruct
    (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ..._args$LWS) => {
      targetPointer$LWS();
      const constructor$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let newTarget$LWS;

      if (typeof newTargetPointerOrUndefined$LWS === 'function') {
        newTargetPointerOrUndefined$LWS();
        newTarget$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          _args$LWS[_i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectConstruct$LWS(constructor$LWS, _args$LWS, newTarget$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      return typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function' ? getTransferablePointer$LWS(_result$LWS) : // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableDefineProperty
    (targetPointer$LWS, __key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
      let _result$LWS = false;

      try {
        _result$LWS = ReflectDefineProperty$LWS(__target$LWS, __key$LWS, safePartialDesc$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_result$LWS && configurable$LWS === false) {
        let _safeDesc$LWS;

        try {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }

        if (_safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);

          if (_safeDesc$LWS.configurable === false) {
            const {
              get: _getter$LWS,
              set: _setter$LWS,
              value: __value$LWS
            } = _safeDesc$LWS;
            foreignCallableNonConfigurableDescriptorCallback$LWS(__key$LWS, false, // configurable
            'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
            typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
          }
        }
      }

      return _result$LWS;
    }, // callableDeleteProperty
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return ReflectDeleteProperty$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableGet
    (targetPointer$LWS, targetTraits$LWS, __key$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let __receiver$LWS;

      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        __receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? __target$LWS : receiverPointerOrPrimitive$LWS;
      }

      let _result$LWS;

      try {
        _result$LWS = ReflectGet$LWS(__target$LWS, __key$LWS, __receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Inline getTransferableValue().


      if (typeof _result$LWS === 'object' && _result$LWS !== null || typeof _result$LWS === 'function') {
        return getTransferablePointer$LWS(_result$LWS);
      }

      if (_result$LWS === undefined && __key$LWS === SymbolToStringTag$LWS && targetTraits$LWS & 16
      /* TargetTraits.IsObject */
      ) {
        try {
          if (!(__key$LWS in __target$LWS)) {
            // Section 19.1.3.6 Object.prototype.toString()
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []); // The default language toStringTag is "Object". If
            // we receive "[object Object]" we return `undefined`
            // to let the language resolve it naturally without
            // projecting a value.

            if (brand$LWS !== '[object Object]') {
              _result$LWS = ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
            }
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      return typeof _result$LWS === 'undefined' ? undefined : _result$LWS;
    }, // callableGetOwnPropertyDescriptor
    (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _safeDesc$LWS;

      try {
        _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(__key$LWS, 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
      }
    }, // callableGetPrototypeOf
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableHas
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return __key$LWS in __target$LWS;
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableIsExtensible
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return ReflectIsExtensible$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableOwnKeys
    (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let ownKeys$LWS;

      try {
        ownKeys$LWS = ReflectOwnKeys$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      ReflectApply$LWS(foreignCallableKeysCallback$LWS, undefined, ownKeys$LWS);
    }, // callablePreventExtensions
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _result$LWS = 2
      /* PreventExtensionsResult.False */
      ;

      try {
        if (ReflectPreventExtensions$LWS(__target$LWS)) {
          _result$LWS = 4
          /* PreventExtensionsResult.True */
          ;
        } else if (ReflectIsExtensible$LWS(__target$LWS)) {
          _result$LWS |= 1
          /* PreventExtensionsResult.Extensible */
          ;
        }
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      return _result$LWS;
    }, // callableSet
    (targetPointer$LWS, __key$LWS, valuePointerOrPrimitive$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let __value$LWS;

      if (typeof valuePointerOrPrimitive$LWS === 'function') {
        valuePointerOrPrimitive$LWS();
        __value$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __value$LWS = valuePointerOrPrimitive$LWS;
      }

      let __receiver$LWS;

      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        __receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? __target$LWS : receiverPointerOrPrimitive$LWS;
      }

      try {
        return ReflectSet$LWS(__target$LWS, __key$LWS, __value$LWS, __receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableSetPrototypeOf
    (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        _proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        _proto$LWS = null;
      }

      try {
        return ReflectSetPrototypeOf$LWS(__target$LWS, _proto$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableDebugInfo
    LOCKER_DEBUGGABLE_FLAG$LWS ? (..._args$LWS) => {
      if (checkDebugMode$LWS()) {
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];

          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            _args$LWS[_i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }

        try {
          ReflectApply$LWS(consoleInfo$LWS, consoleObject$LWS, _args$LWS); // eslint-disable-next-line no-empty
        } catch (_unused29$LWS) {}
      }
    } : noop$LWS, // callableDefineProperties
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
        // We don't use `ObjectDefineProperties()` here because it
        // will throw an exception if it fails to define one of its
        // properties.
        ReflectDefineProperty$LWS(__target$LWS, descriptorTuples$LWS[_i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], // configurable
        descriptorTuples$LWS[_i$LWS + 2], // enumerable
        descriptorTuples$LWS[_i$LWS + 3], // writable
        descriptorTuples$LWS[_i$LWS + 4], // valuePointer
        descriptorTuples$LWS[_i$LWS + 5], // getterPointer
        descriptorTuples$LWS[_i$LWS + 6] // setterPointer
        ));
      }
    } : noop$LWS, // callableGetLazyPropertyDescriptorStateByTarget
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // We don't wrap the weak map `get()` call in a try-catch
      // because we know `target` is an object.

      const state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(__target$LWS);
      return state$LWS ? getTransferablePointer$LWS(state$LWS) : state$LWS;
    } : noop$LWS, // callableGetTargetIntegrityTraits
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // A target may be a proxy that is revoked or throws in its
      // "isExtensible" trap.

      try {
        if (!ReflectIsExtensible$LWS(__target$LWS)) {
          if (ObjectIsFrozen$LWS(__target$LWS)) {
            return 4
            /* TargetIntegrityTraits.IsFrozen */
            & 2
            /* TargetIntegrityTraits.IsSealed */
            & 1
            /* TargetIntegrityTraits.IsNotExtensible */
            ;
          }

          if (ObjectIsSealed$LWS(__target$LWS)) {
            return 2
            /* TargetIntegrityTraits.IsSealed */
            & 1
            /* TargetIntegrityTraits.IsNotExtensible */
            ;
          }

          return 1
          /* TargetIntegrityTraits.IsNotExtensible */
          ;
        }
      } catch (_unused30$LWS) {
        try {
          isArrayOrThrowForRevoked$LWS(__target$LWS);
        } catch (_unused31$LWS) {
          return 8
          /* TargetIntegrityTraits.Revoked */
          ;
        }
      }

      return 0
      /* TargetIntegrityTraits.None */
      ;
    } : () => 0
    /* TargetIntegrityTraits.None */
    , // callableGetToStringTagOfTarget
    targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        // Section 19.1.3.6 Object.prototype.toString()
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, __target$LWS, []);
        return brand$LWS === '[object Object]' ? 'Object' : ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    }, // callableGetTypedArrayIndexedValue
    !IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, _index$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return __target$LWS[_index$LWS];
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    } : noop$LWS, // callableInstallErrorPrepareStackTrace
    installErrorPrepareStackTrace$LWS, // callableInstallLazyPropertyDescriptors
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const sliceIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS]);
      let ownKeys$LWS;
      let unforgeableGlobalThisKeys$LWS;

      if (sliceIndex$LWS === -1) {
        ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      } else {
        ownKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
        unforgeableGlobalThisKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
      }

      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);

      if (state$LWS === undefined) {
        state$LWS = {
          __proto__: null
        };
        setLazyPropertyDescriptorStateByTarget$LWS(__target$LWS, state$LWS);
      }

      for (let _i$LWS = 0, {
        length: _length$LWS
      } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        state$LWS[ownKey$LWS] = true;
        ReflectDefineProperty$LWS(__target$LWS, ownKey$LWS, // The role of this descriptor is to serve as a
        // bouncer. When either a getter or a setter is
        // invoked the descriptor will be replaced with
        // the descriptor from the foreign side and the
        // get/set operation will carry on from there.
        {
          __proto__: null,
          // We DO explicitly set configurability in the
          // off chance that the property doesn't exist.
          configurable: true,

          // We DON'T explicitly set enumerability to
          // defer to the enumerability of the existing
          // property. In the off chance the property
          // doesn't exist the property will be defined
          // as non-enumerable.
          get() {
            activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, state$LWS);
            return __target$LWS[ownKey$LWS];
          },

          set(__value$LWS) {
            activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, state$LWS);
            ReflectSet$LWS(__target$LWS, ownKey$LWS, __value$LWS);
          }

        });
      }

      installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
    } : noop$LWS, // callableIsTargetLive
    !IS_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return liveTargetCallback$LWS(__target$LWS, targetTraits$LWS); // eslint-disable-next-line no-empty
      } catch (_unused32$LWS) {}

      return false;
    } : alwaysFalse$LWS, // callableIsTargetRevoked
    !IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        isArrayOrThrowForRevoked$LWS(__target$LWS);
        return false; //  eslint-disable-next-line no-empty
      } catch (_unused33$LWS) {}

      return true;
    } : alwaysFalse$LWS, // callableSerializeTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;

      try {
        return SymbolToStringTag$LWS in __target$LWS ? serializeTargetByTrialAndError$LWS(__target$LWS) : // Fast path.
        serializeTargetByBrand$LWS(__target$LWS); // eslint-disable-next-line no-empty
      } catch (_unused34$LWS) {}

      return undefined;
    } : noop$LWS, // callableSetLazyPropertyDescriptorStateByTarget
    !IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      statePointer$LWS();
      const state$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined; // We don't wrap the weak map `set()` call in a try-catch
      // because we know `target` is an object.

      proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, state$LWS);
    } : noop$LWS, // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors
    (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let unsafeDescMap$LWS;

      try {
        unsafeDescMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeDescMap$LWS);
      const {
        length: _length$LWS
      } = ownKeys$LWS;
      const descriptorTuples$LWS = new ArrayCtor$LWS(_length$LWS * 7);

      for (let _i$LWS = 0, _j$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        const _safeDesc$LWS = unsafeDescMap$LWS[ownKey$LWS];
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        descriptorTuples$LWS[_j$LWS] = ownKey$LWS;
        descriptorTuples$LWS[_j$LWS + 1] = 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 2] = 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 3] = 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 4] = 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 5] = 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[_j$LWS + 6] = 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }

      ReflectApply$LWS(foreignCallableDescriptorsCallback$LWS, undefined, descriptorTuples$LWS);
      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableBatchGetPrototypeOfWhenHasNoOwnProperty
    (targetPointer$LWS, __key$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _proto$LWS;

      try {
        if (ObjectHasOwn$LWS(__target$LWS, __key$LWS)) {
          return true;
        }

        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    }, // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor
    (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const __target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let _safeDesc$LWS;

      try {
        _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(__target$LWS, __key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }

      if (_safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(_safeDesc$LWS, null);
        const {
          get: _getter$LWS,
          set: _setter$LWS,
          value: __value$LWS
        } = _safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(__key$LWS, 'configurable' in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof __value$LWS === 'object' && __value$LWS !== null || typeof __value$LWS === 'function' ? getTransferablePointer$LWS(__value$LWS) : // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof __value$LWS === 'undefined' ? undefined : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _getter$LWS === 'function' ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in _safeDesc$LWS ? // Inline getTransferableValue().
        typeof _setter$LWS === 'function' ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
        return undefined;
      }

      let _proto$LWS;

      try {
        _proto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      } // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot


      if (typeof _proto$LWS === 'undefined') {
        return null;
      }

      return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
    });
    let foreignCallablesHooked$LWS = false;
    return (...hooks$LWS) => {
      if (foreignCallablesHooked$LWS) {
        return;
      }

      foreignCallablesHooked$LWS = true;
      ({
        // 0: globalThisPointer,
        // 1: getSelectedTarget,
        // 2: getTransferableValue,
        // 3: callableGetPropertyValuePointer,
        // 4: callableEvaluate,
        // 5: callableLinkPointers,
        6: foreignCallablePushErrorTarget$LWS,
        7: foreignCallablePushTarget$LWS,
        8: foreignCallableApply$LWS,
        9: foreignCallableConstruct$LWS,
        10: foreignCallableDefineProperty$LWS,
        11: foreignCallableDeleteProperty$LWS,
        12: foreignCallableGet$LWS,
        13: foreignCallableGetOwnPropertyDescriptor$LWS,
        14: foreignCallableGetPrototypeOf$LWS,
        15: foreignCallableHas$LWS,
        16: foreignCallableIsExtensible$LWS,
        17: foreignCallableOwnKeys$LWS,
        18: foreignCallablePreventExtensions$LWS,
        19: foreignCallableSet$LWS,
        20: foreignCallableSetPrototypeOf$LWS,
        21: foreignCallableDebugInfo$LWS,
        // 22: callableDefineProperties,
        23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: foreignCallableGetTargetIntegrityTraits$LWS,
        25: foreignCallableGetToStringTagOfTarget$LWS,
        26: foreignCallableGetTypedArrayIndexedValue$LWS,
        27: foreignCallableInstallErrorPrepareStackTrace$LWS,
        // 28: callableInstallLazyPropertyDescriptors,
        29: foreignCallableIsTargetLive$LWS,
        30: foreignCallableIsTargetRevoked$LWS,
        31: foreignCallableSerializeTarget$LWS,
        32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        33: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        34: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = hooks$LWS);
      const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1
      /* ProxyHandlerTraps.Apply */
      );
      const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );
      const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2
      /* ProxyHandlerTraps.Construct */
      );

      if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === undefined) {
        // A minification safe way to get the 'apply' and 'construct'
        // trap property names.
        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS({
          applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
          applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
          applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
          applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
          applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
          applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
          applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
          constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
          constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
          constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
          constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
          constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
          constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
          constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
        });
      }

      arityToApplyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
      arityToApplyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
      arityToApplyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
      arityToApplyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
      arityToApplyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
      arityToApplyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
      arityToApplyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
      arityToConstructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
      arityToConstructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
      arityToConstructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
      arityToConstructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
      arityToConstructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
      arityToConstructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
      arityToConstructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
      const {
        prototype: BoundaryProxyHandlerProto$LWS
      } = BoundaryProxyHandler$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToApplyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[arityToConstructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
      ReflectSetPrototypeOf$LWS(BoundaryProxyHandlerProto$LWS, null); // Future optimization: Hoping proxies with frozen handlers can be faster.

      ObjectFreeze$LWS(BoundaryProxyHandlerProto$LWS);
    };
  };
  /* eslint-enable prefer-object-spread */
}

const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;

function createBlueConnector$LWS(_globalObject$LWS) {
  if (typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing globalObject.');
  }

  return createMembraneMarshall$LWS(_globalObject$LWS);
}

function createRedConnector$LWS(evaluator$LWS) {
  if (typeof evaluator$LWS !== 'function') {
    throw new TypeErrorCtor$LWS('Missing evaluator function.');
  }

  return evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
}

const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = Symbol.for('@@lockerNearMembraneUndefinedValue');

class VirtualEnvironment$LWS {
  constructor(options$LWS) {
    if (options$LWS === undefined) {
      throw new ErrorCtor$LWS('Missing required VirtualEnvironment options.');
    } // prettier-ignore


    const {
      blueConnector: blueConnector$LWS,
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      redConnector: redConnector$LWS // eslint-disable-next-line prefer-object-spread

    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    let blueHooks$LWS;
    const blueConnect$LWS = blueConnector$LWS('blue', (...hooks$LWS) => {
      blueHooks$LWS = hooks$LWS;
    }, {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS
    });
    const {
      0: blueGlobalThisPointer$LWS,
      1: blueGetSelectedTarget$LWS,
      2: blueGetTransferableValue$LWS,
      3: blueCallableGetPropertyValuePointer$LWS,
      // 4: blueCallableEvaluate,
      5: blueCallableLinkPointers$LWS,
      6: blueCallablePushErrorTarget$LWS,
      7: blueCallablePushTarget$LWS,
      8: blueCallableApply$LWS,
      9: blueCallableConstruct$LWS,
      10: blueCallableDefineProperty$LWS,
      11: blueCallableDeleteProperty$LWS,
      12: blueCallableGet$LWS,
      13: blueCallableGetOwnPropertyDescriptor$LWS,
      14: blueCallableGetPrototypeOf$LWS,
      15: blueCallableHas$LWS,
      16: blueCallableIsExtensible$LWS,
      17: blueCallableOwnKeys$LWS,
      18: blueCallablePreventExtensions$LWS,
      19: blueCallableSet$LWS,
      20: blueCallableSetPrototypeOf$LWS,
      21: blueCallableDebugInfo$LWS,
      // 22: blueCallableDefineProperties,
      23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: blueCallableGetTargetIntegrityTraits$LWS,
      25: blueCallableGetToStringTagOfTarget$LWS,
      26: blueCallableGetTypedArrayIndexedValue$LWS,
      27: blueCallableInstallErrorPrepareStackTrace$LWS,
      // 28: blueCallableInstallLazyPropertyDescriptors,
      29: blueCallableIsTargetLive$LWS,
      30: blueCallableIsTargetRevoked$LWS,
      31: blueCallableSerializeTarget$LWS,
      32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      34: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      35: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = blueHooks$LWS;
    let redHooks$LWS;
    const redConnect$LWS = redConnector$LWS('red', (...hooks$LWS) => {
      redHooks$LWS = hooks$LWS;
    });
    const {
      0: redGlobalThisPointer$LWS,
      // 1: redGetSelectedTarget,
      // 2: redGetTransferableValue,
      3: redCallableGetPropertyValuePointer$LWS,
      4: redCallableEvaluate$LWS,
      5: redCallableLinkPointers$LWS,
      6: redCallablePushErrorTarget$LWS,
      7: redCallablePushTarget$LWS,
      8: redCallableApply$LWS,
      9: redCallableConstruct$LWS,
      10: redCallableDefineProperty$LWS,
      11: redCallableDeleteProperty$LWS,
      12: redCallableGet$LWS,
      13: redCallableGetOwnPropertyDescriptor$LWS,
      14: redCallableGetPrototypeOf$LWS,
      15: redCallableHas$LWS,
      16: redCallableIsExtensible$LWS,
      17: redCallableOwnKeys$LWS,
      18: redCallablePreventExtensions$LWS,
      19: redCallableSet$LWS,
      20: redCallableSetPrototypeOf$LWS,
      21: redCallableDebugInfo$LWS,
      22: redCallableDefineProperties$LWS,
      23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: redCallableGetTargetIntegrityTraits$LWS,
      25: redCallableGetToStringTagOfTarget$LWS,
      26: redCallableGetTypedArrayIndexedValue$LWS,
      27: redCallableInstallErrorPrepareStackTrace$LWS,
      28: redCallableInstallLazyPropertyDescriptors$LWS,
      29: redCallableIsTargetLive$LWS,
      30: redCallableIsTargetRevoked$LWS,
      31: redCallableSerializeTarget$LWS,
      32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      34: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      35: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = redHooks$LWS;
    blueConnect$LWS(noop$LWS, // redGlobalThisPointer,
    noop$LWS, // redGetSelectedTarget,
    noop$LWS, // redGetTransferableValue,
    noop$LWS, // redCallableGetPropertyValuePointer,
    noop$LWS, // redCallableEvaluate,
    noop$LWS, // redCallableLinkPointers,
    redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS, // redCallableDefineProperties,
    redCallableGetLazyPropertyDescriptorStateByTarget$LWS, redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableGetTypedArrayIndexedValue$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, // redCallableInstallLazyPropertyDescriptors,
    redCallableIsTargetLive$LWS, redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    redConnect$LWS(noop$LWS, // blueGlobalThisPointer,
    noop$LWS, // blueGetSelectedTarget,
    noop$LWS, // blueGetTransferableValue,
    noop$LWS, // blueCallableGetPropertyValuePointer,
    noop$LWS, // blueCallableEvaluate,
    noop$LWS, // blueCallableLinkPointers,
    blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, blueCallableDebugInfo$LWS, noop$LWS, // blueCallableDefineProperties,
    blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableGetTypedArrayIndexedValue$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, // blueCallableInstallLazyPropertyDescriptors,
    blueCallableIsTargetLive$LWS, blueCallableIsTargetRevoked$LWS, blueCallableSerializeTarget$LWS, blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
    this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
    this.blueGetTransferableValue = blueGetTransferableValue$LWS;
    this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
    this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
    this.redGlobalThisPointer = redGlobalThisPointer$LWS;
    this.redCallableGetPropertyValuePointer = redCallableGetPropertyValuePointer$LWS;
    this.redCallableEvaluate = redCallableEvaluate$LWS;
    this.redCallableLinkPointers = redCallableLinkPointers$LWS;
    this.redCallableSetPrototypeOf = redCallableSetPrototypeOf$LWS;
    this.redCallableDefineProperties = redCallableDefineProperties$LWS;
    this.redCallableInstallLazyPropertyDescriptors = redCallableInstallLazyPropertyDescriptors$LWS;
  }

  evaluate(_sourceText$LWS) {
    try {
      const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(_sourceText$LWS);

      if (typeof bluePointerOrPrimitiveValue$LWS === 'function') {
        bluePointerOrPrimitiveValue$LWS();
        return this.blueGetSelectedTarget();
      }

      return bluePointerOrPrimitiveValue$LWS;
    } catch (error) {
      var _this$blueGetSelected$LWS;

      throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
    }
  }

  lazyRemapProperties(__target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const _args$LWS = [this.blueGetTransferableValue(__target$LWS)];
      ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, ownKeys$LWS);

      if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
        // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit
        // `ownKeys` and `unforgeableGlobalThisKeys`.
        _args$LWS[_args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, unforgeableGlobalThisKeys$LWS);
      }

      ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, undefined, _args$LWS);
    }
  }

  link(..._keys$LWS) {
    let bluePointer$LWS = this.blueGlobalThisPointer;
    let redPointer$LWS = this.redGlobalThisPointer;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const __key$LWS = _keys$LWS[_i$LWS];
      bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, __key$LWS);
      redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, __key$LWS);
      this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
      this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
    }
  }

  remapProperties(__target$LWS, unsafeBlueDescMap$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const targetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescMap$LWS);
      const {
        length: _length$LWS
      } = ownKeys$LWS;
      const _args$LWS = new ArrayCtor$LWS(1 + _length$LWS * 7);
      _args$LWS[0] = targetPointer$LWS;

      for (let _i$LWS = 0, _j$LWS = 1; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        const unsafeBlueDesc$LWS = unsafeBlueDescMap$LWS[ownKey$LWS]; // Avoid poisoning by only installing own properties from unsafeBlueDescMap.
        // We don't use a toSafeDescriptor() style helper since that mutates
        // the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread

        const safeBlueDesc$LWS = ObjectAssign$LWS({
          __proto__: null
        }, unsafeBlueDesc$LWS);
        _args$LWS[_j$LWS] = ownKey$LWS;
        _args$LWS[_j$LWS + 1] = 'configurable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 2] = 'enumerable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 3] = 'writable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 4] = 'value' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 5] = 'get' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        _args$LWS[_j$LWS + 6] = 'set' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }

      ReflectApply$LWS(this.redCallableDefineProperties, this, _args$LWS);
    }
  }

  remapProto(__target$LWS, _proto$LWS) {
    if (typeof __target$LWS === 'object' && __target$LWS !== null || typeof __target$LWS === 'function') {
      const foreignTargetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
      const transferableProto$LWS = _proto$LWS ? this.blueGetTransferableValue(_proto$LWS) : _proto$LWS;
      this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
    }
  }

}
/**
 * This list must be in sync with ecma-262, anything new added to the global object
 * should be considered, to decide whether or not they need remapping. The default
 * behavior, if missing form the following list, is to be remapped, which is safer.
 *
 * Note: remapped means the functionality is provided by the blue realm, rather than
 * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects
 * have the same identity because it is always derived from the outer realm's Set.
 *
 * Note 1: We have identified 3 types of intrinsics
 * A: primitives driven intrinsics
 * B: syntax driven intrinsics (they usually have a imperative form as well)
 * C: imperative only intrinsics
 *
 * While A is not remapped, it is safe, and works fast that way, and C is remapped to
 * preserve the identity of all produced objects from the same realm, B is really
 * problematic, and requires a lot more work to guarantee that objects from both sides
 * can be considered equivalents (without identity discontinuity).
 */


const ESGlobalKeys$LWS = [// *** 19.1 Value Properties of the Global Object
'globalThis', 'Infinity', 'NaN', 'undefined', // *** 19.2 Function Properties of the Global Object
// 'eval', // dangerous & Reflective
'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', // *** 19.3 Constructor Properties of the Global Object
// 'AggregateError', // Reflective
// 'Array', // Reflective
// 'ArrayBuffer', // Remapped
'BigInt', // 'BigInt64Array', // Remapped
// 'BigUint64Array', // Remapped
'Boolean', // 'DataView', // Remapped
// 'Date', // Remapped
// 'Error', // Reflective
// 'EvalError', // Reflective
'FinalizationRegistry', // 'Float32Array', // Remapped
// 'Float64Array', // Remapped
// 'Function', // dangerous & Reflective
// 'Int8Array', // Remapped
// 'Int16Array', // Remapped
// 'Int32Array', // Remapped
// 'Map', // Remapped
'Number', // 'Object', // Reflective
// Allow blue `Promise` constructor to overwrite the Red one so that promises
// created by the `Promise` constructor or APIs like `fetch` will work.
// 'Promise', // Remapped
// 'Proxy', // Reflective
// 'RangeError', // Reflective
// 'ReferenceError', // Reflective
'RegExp', // 'Set', // Remapped
// 'SharedArrayBuffer', // Remapped
'String', 'Symbol', // 'SyntaxError', // Reflective
// 'TypeError', // Reflective
// 'Uint8Array', // Remapped
// 'Uint8ClampedArray', // Remapped
// 'Uint16Array', // Remapped
// 'Uint32Array', // Remapped
// 'URIError', // Reflective
// 'WeakMap', // Remapped
// 'WeakSet', // Remapped
'WeakRef', // *** 18.4 Other Properties of the Global Object
// 'Atomics', // Remapped
'JSON', 'Math', 'Reflect', // *** Annex B
'escape', 'unescape' // *** ECMA-402
// 'Intl',  // Remapped
]; // These are foundational things that should never be wrapped but are equivalent
// TODO: revisit this list.

const ReflectiveIntrinsicObjectNames$LWS = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];
const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);

function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(_descMap$LWS, source$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[_i$LWS]; // Avoid overriding ECMAScript global names that correspond to
    // global intrinsics. This guarantee that those entries will be
    // ignored if present in the source property descriptor map.

    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      const _unsafeDesc$LWS = source$LWS[ownKey$LWS];

      if (_unsafeDesc$LWS) {
        // Avoid poisoning by only installing own properties from
        // unsafeDesc. We don't use a toSafeDescriptor() style helper
        // since that mutates the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        _descMap$LWS[ownKey$LWS] = ObjectAssign$LWS({
          __proto__: null
        }, _unsafeDesc$LWS);
      }
    }
  }

  return _descMap$LWS;
}

function getFilteredGlobalOwnKeys$LWS(source$LWS) {
  const _result$LWS = [];
  let resultOffset$LWS = 0;
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[_i$LWS]; // Avoid overriding ECMAScript global names that correspond to global
    // intrinsics. This guarantees that those entries will be ignored if
    // present in the source object.

    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      _result$LWS[resultOffset$LWS++] = ownKey$LWS;
    }
  }

  return _result$LWS;
}

function linkIntrinsics$LWS(env$LWS, _globalObject$LWS) {
  // Remap intrinsics that are realm agnostic.
  for (let _i$LWS = 0, {
    length: _length$LWS
  } = ReflectiveIntrinsicObjectNames$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[_i$LWS];
    const reflectiveValue$LWS = _globalObject$LWS[globalName$LWS];

    if (reflectiveValue$LWS) {
      // Proxy.prototype is undefined.
      if (reflectiveValue$LWS.prototype) {
        env$LWS.link(globalName$LWS, 'prototype');
      } else {
        env$LWS.link(globalName$LWS);
      }
    }
  }
}

const {
  prototype: DocumentProto$LWS
} = Document;
const {
  close: DocumentProtoClose$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');
const {
  remove: ElementProtoRemove$LWS,
  setAttribute: ElementProtoSetAttribute$LWS
} = Element.prototype;
const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'style');
const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, 'contentWindow');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS
} = NodeProto$LWS;
const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');
const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap()); // Chromium based browsers have a bug that nulls the result of `window`
// getters in detached iframes when the property descriptor of `window.window`
// is retrieved.
// https://bugs.chromium.org/p/chromium/issues/detail?id=1305302

const unforgeablePoisonedWindowKeys$LWS = (() => {
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = window; // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata

  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;

  if ( // While experimental, `navigator.userAgentData.brands` may be defined
  // as an empty array in headless Chromium based browsers.
  ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ? // Use user-agent client hints API if available to avoid
  // deprecation warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  brands$LWS.find(item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium') : // Fallback to a standard user-agent string sniff.
  // Note: Chromium identifies itself as Chrome in its user-agent string.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  / (?:Headless)?Chrome\/\d+/.test(navigator$LWS.userAgent)) {
    return ['window'];
  }

  return undefined;
})();

function getCachedGlobalObjectReferences$LWS(_globalObject$LWS) {
  const {
    window: window$LWS
  } = _globalObject$LWS;
  let _record$LWS;
  let _document$LWS; // Suppress errors thrown on cross-origin opaque windows.

  try {
    ({
      document: _document$LWS
    } = _globalObject$LWS);
    _record$LWS = blueDocumentToRecordMap$LWS.get(_document$LWS); // eslint-disable-next-line no-empty
  } catch (__unused$LWS) {
    return undefined;
  }

  if (_record$LWS) {
    return _record$LWS;
  } // Cache references to object values that can't be replaced
  // window -> Window -> WindowProperties -> EventTarget


  const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
  const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
  const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
  _record$LWS = {
    document: _document$LWS,
    DocumentProto: ReflectGetPrototypeOf$LWS(_document$LWS),
    window: window$LWS,
    WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
    WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
    EventTargetProto: EventTargetProto$LWS,
    EventTargetProtoOwnKeys: ReflectOwnKeys$LWS(EventTargetProto$LWS)
  };
  blueDocumentToRecordMap$LWS.set(_document$LWS, _record$LWS);
  return _record$LWS;
}

function filterWindowKeys$LWS(_keys$LWS) {
  const _result$LWS = [];
  let resultOffset$LWS = 0;

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const __key$LWS = _keys$LWS[_i$LWS];

    if ( // Filter out unforgeable property keys that cannot be installed.
    __key$LWS !== 'document' && __key$LWS !== 'location ' && __key$LWS !== 'top' && __key$LWS !== 'window' && // Remove other browser specific unforgeables.
    __key$LWS !== 'chrome') {
      _result$LWS[resultOffset$LWS++] = __key$LWS;
    }
  }

  return _result$LWS;
}
/**
 * global descriptors are a combination of 3 set of descriptors:
 * - first, the key of the red descriptors define the descriptors
 *   provided by the browser when creating a brand new window.
 * - second, once we know the base keys, we get the actual descriptors
 *   from the blueDescriptors, since those are the one we want to provide
 *   access to via the membrane.
 * - third, the user of this library can provide endowments, which define
 *   global descriptors that should be installed into the sandbox on top
 *   of the base descriptors.
 *
 * Note: The main reason for using redDescriptors as the base keys instead
 * of blueDescriptor is because there is no guarantee that this library is
 * the first one to be evaluated in the host app, which means it has no ways
 * to determine what is a real DOM API vs app specific globals.
 *
 * Quirk: The only quirk here is for the case in which this library runs
 * after some other code that patches some of the DOM APIs. This means
 * the installed proxy in the sandbox will point to the patched global
 * API in the blue realm, rather than the original, because we don't have
 * a way to access the original anymore. This should not be a deal-breaker
 * if the patched API behaves according to the spec.
 *
 * The result of this method is a descriptor map that contains everything
 * that will be installed (via the membrane) as global descriptors in
 * the red realm.
 */


function removeWindowDescriptors$LWS(unsafeDescMap$LWS) {
  // Remove unforgeable descriptors that cannot be installed.
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'document');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'location');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'top');
  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'window'); // Remove other browser specific unforgeables.

  ReflectDeleteProperty$LWS(unsafeDescMap$LWS, 'chrome');
  return unsafeDescMap$LWS;
}
/**
 * Initialization operation to capture and cache all unforgeable references
 * and their respective descriptor maps before any other code runs, this
 * usually help because this library runs before anything else that can poison
 * the environment.
 */


getCachedGlobalObjectReferences$LWS(window);
const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = 'allow-same-origin allow-scripts';
const blueDocumentToBlueCreateHooksCallbackMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
let defaultGlobalOwnKeys$LWS = null;

function createDetachableIframe$LWS(doc$LWS) {
  var _ReflectApply$LWS;

  const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ['iframe']); // It is impossible to test whether the NodeProtoLastChildGetter branch is
  // reached in a normal Karma test environment.

  const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS :
  /* istanbul ignore next */
  ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
  const _style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
  _style$LWS.display = 'none';
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ['sandbox', IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
  return iframe$LWS;
}

function createIframeVirtualEnvironment$LWS(_globalObject$LWS, options$LWS) {
  if (typeof _globalObject$LWS !== 'object' || _globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing global object virtualization target.');
  }

  const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(_globalObject$LWS);

  if (typeof blueRefs$LWS !== 'object' || blueRefs$LWS === null) {
    throw new TypeErrorCtor$LWS('Invalid virtualization target.');
  }

  const {
    distortionCallback: distortionCallback$LWS,
    endowments: endowments$LWS,
    globalObjectShape: globalObjectShape$LWS,
    instrumentation: instrumentation$LWS,
    keepAlive: keepAlive$LWS = false,
    liveTargetCallback: liveTargetCallback$LWS // eslint-disable-next-line prefer-object-spread

  } = ObjectAssign$LWS({
    __proto__: null
  }, options$LWS);
  const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
  const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
  const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== 'object' || globalObjectShape$LWS === null;

  if (shouldUseDefaultGlobalOwnKeys$LWS && defaultGlobalOwnKeys$LWS === null) {
    defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS));
  }

  let blueConnector$LWS = blueDocumentToBlueCreateHooksCallbackMap$LWS.get(blueRefs$LWS.document);

  if (blueConnector$LWS === undefined) {
    blueConnector$LWS = createBlueConnector$LWS(_globalObject$LWS);
    blueDocumentToBlueCreateHooksCallbackMap$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
  }

  const env$LWS = new VirtualEnvironment$LWS({
    blueConnector: blueConnector$LWS,
    distortionCallback: distortionCallback$LWS,
    instrumentation: instrumentation$LWS,
    liveTargetCallback: liveTargetCallback$LWS,
    redConnector: createRedConnector$LWS(redWindow$LWS.eval)
  });
  linkIntrinsics$LWS(env$LWS, _globalObject$LWS); // window
  // window.document
  // In browsers globalThis is === window.

  if (typeof globalThis === 'undefined') {
    // Support for globalThis was added in Chrome 71.
    // However, environments like Android emulators are running Chrome 69.
    env$LWS.link('window', 'document');
  } else {
    // document is === window.document.
    env$LWS.link('document');
  } // window.__proto__ (aka Window.prototype)
  // window.__proto__.__proto__ (aka WindowProperties.prototype)
  // window.__proto__.__proto__.__proto__ (aka EventTarget.prototype)


  env$LWS.link('__proto__', '__proto__', '__proto__');
  env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
  env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS)), // Chromium based browsers have a bug that nulls the result of `window`
  // getters in detached iframes when the property descriptor of `window.window`
  // is retrieved.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
  keepAlive$LWS ? undefined : unforgeablePoisonedWindowKeys$LWS);

  if (endowments$LWS) {
    const filteredEndowments$LWS = {};
    assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS);
    removeWindowDescriptors$LWS(filteredEndowments$LWS);
    env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
  } // We intentionally skip remapping Window.prototype because there is nothing
  // in it that needs to be remapped.


  env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys); // We don't remap `blueRefs.WindowPropertiesProto` because it is "magical"
  // in that it provides access to elements by id.
  //
  // Once we get the iframe info ready, and all mapped, we can proceed to
  // detach the iframe only if `options.keepAlive` isn't true.

  if (keepAlive$LWS) {
    // TODO: Temporary hack to preserve the document reference in Firefox.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=543435
    const {
      document: redDocument$LWS
    } = redWindow$LWS;
    ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
    ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
  } else {
    ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
  }

  return env$LWS;
} // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md
// istanbul ignore next


const HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function redHelpersFactory$LWS(_context$LWS) {
  const {
    elementToLoadingPromiseMap: elementToLoadingPromiseMap$LWS
  } = _context$LWS;
  const ArrayCtor$LWS = Array;
  const PromiseCtor$LWS = Promise;
  const TypeErrorCtor$LWS = TypeError;
  const {
    asyncIterator: SymbolAsyncIterator$LWS,
    iterator: SymbolIterator$LWS
  } = Symbol;
  const {
    [SymbolIterator$LWS]: ArrayIterator$LWS
  } = ArrayCtor$LWS.prototype; // The Generator prototype object is %GeneratorFunction.prototype.prototype%.
  // https://tc39.es/ecma262/#sec-generatorfunction.prototype.prototype
  // eslint-disable-next-line @typescript-eslint/no-empty-function, func-names

  const GeneratorProto$LWS = function* () {}.constructor.prototype.prototype;

  const {
    next: GeneratorProtoNext$LWS,
    throw: GeneratorProtoThrow$LWS
  } = GeneratorProto$LWS;
  const {
    delete: MapProtoDelete$LWS,
    get: MapProtoGet$LWS,
    set: MapProtoSet$LWS
  } = Map.prototype;
  const {
    appendChild: NodeProtoAppendChild$LWS
  } = Node.prototype;
  const {
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS
  } = Object;
  const {
    then: PromiseProtoThen$LWS
  } = PromiseCtor$LWS.prototype;
  const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
  const {
    apply: ReflectApply$LWS,
    get: ReflectGet$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  const {
    replace: StringProtoReplace$LWS
  } = String.prototype;
  const {
    get: WeakMapProtoGet$LWS,
    set: WeakMapProtoSet$LWS
  } = WeakMap.prototype;
  const {
    createElement: DocumentProtoCreateElement$LWS
  } = Document.prototype;
  const {
    querySelector: ElementProtoQuerySelector$LWS,
    setAttribute: ElementProtoSetAttribute$LWS
  } = Element.prototype;
  const {
    stopPropagation: EventProtoStopPropagation$LWS
  } = Event.prototype;
  const {
    addEventListener: EventTargetProtoAddEventListener$LWS,
    removeEventListener: EventTargetProtoRemoveEventListener$LWS
  } = EventTarget.prototype;
  const {
    head: headRef$LWS
  } = document; // We don't use `toSafeMap()` here because `Map` is remapped from the
  // primary realm and dot notation is actually more complex internally for
  // cross-realm objects.

  const forOfStateMap$LWS = new Map();
  const singleQuotesRegExp$LWS = /\\?'/g;
  const LOCKER_ID_DATA_NAME$LWS = 'data-locker-id'; // Generate a UID for this sandbox run for <script> elements.

  const LOCKER_ID_DATA_VALUE$LWS = `${crypto.getRandomValues(new Uint32Array(1))[0]}`;

  class LockerSecurityError$LWS extends Error {
    constructor(message$LWS) {
      super(`Lightning Web Security: ${message$LWS}`);
    }

  } // This helper is used to wrap the bodies of async functions that are
  // transformed into generator functions. It's based on @babel/helpers
  // `helpers.asyncToGenerator()`:
  // https://github.com/babel/babel/blob/a967910/packages/babel-helpers/src/helpers.js#L255-L288


  function asyncToGen$LWS(func$LWS, thisArg$LWS) {
    return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      const gen$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, []);

      function next$LWS(__value$LWS) {
        genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorProtoNext$LWS, __value$LWS);
      }

      function thrower$LWS(error) {
        genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorProtoThrow$LWS, error);
      }

      next$LWS(undefined);
    });
  }

  function escapeSingleQuotes$LWS(_string$LWS) {
    // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    return ReflectApply$LWS(StringProtoReplace$LWS, _string$LWS, [singleQuotesRegExp$LWS, "\\'"]);
  }

  function forAwaitOf$LWS(_index$LWS, stage$LWS, object$LWS) {
    if (stage$LWS === 0
    /* init */
    ) {
      let sync$LWS = false;
      let {
        [SymbolAsyncIterator$LWS]: iterator$LWS
      } = object$LWS;

      if (iterator$LWS === null || iterator$LWS === undefined) {
        sync$LWS = true;
        ({
          [SymbolIterator$LWS]: iterator$LWS
        } = object$LWS);
      }

      if (typeof iterator$LWS !== 'function') {
        throw new TypeErrorCtor$LWS('Object is not iterable.');
      }

      ReflectApply$LWS(MapProtoSet$LWS, forOfStateMap$LWS, [_index$LWS, {
        iterable: ReflectApply$LWS(iterator$LWS, object$LWS, []),
        step: undefined,
        sync: sync$LWS
      }]);
      return undefined;
    }

    const state$LWS = ReflectApply$LWS(MapProtoGet$LWS, forOfStateMap$LWS, [_index$LWS]);

    if (stage$LWS === 1
    /* step */
    ) {
      const _result$LWS = state$LWS.iterable.next();
      return state$LWS.sync ? new PromiseCtor$LWS(resolve$LWS => {
        state$LWS.step = _result$LWS;
        resolve$LWS();
      }) : ReflectApply$LWS(PromiseProtoThen$LWS, _result$LWS, [step$LWS => {
        state$LWS.step = step$LWS;
      }]);
    }

    if (stage$LWS === 2
    /* value */
    ) {
      return state$LWS.step.value;
    }

    if (stage$LWS === 3
    /* done */
    ) {
      const done$LWS = !!state$LWS.step.done;

      if (done$LWS) {
        ReflectApply$LWS(MapProtoDelete$LWS, forOfStateMap$LWS, [_index$LWS]);
      }

      return done$LWS;
    }

    return undefined;
  }

  function genStep$LWS(gen$LWS, resolve$LWS, reject$LWS, next$LWS, thrower$LWS, GeneratorMethod$LWS, arg$LWS) {
    let info$LWS;
    let __value$LWS;

    try {
      info$LWS = ReflectApply$LWS(GeneratorMethod$LWS, gen$LWS, [arg$LWS]);
      __value$LWS = info$LWS.value;
    } catch (error) {
      reject$LWS(error);
      return;
    }

    if (info$LWS.done) {
      resolve$LWS(__value$LWS);
    } else {
      PromiseResolve$LWS(__value$LWS).then(next$LWS, thrower$LWS);
    }
  } // loadPromise returns a promise to load the given element.


  function loadPromise$LWS(_element$LWS, urlAsString$LWS) {
    const promise$LWS = new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      function onerror$LWS(_event$LWS) {
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['load', onload$LWS]);
        ReflectApply$LWS(EventProtoStopPropagation$LWS, _event$LWS, []);
        reject$LWS(new LockerSecurityError$LWS(`Resource loader error loading '${escapeSingleQuotes$LWS(urlAsString$LWS)}'.`));
      }

      function onload$LWS() {
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ['load', onload$LWS]);
        resolve$LWS(undefined);
      }

      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, _element$LWS, ['error', onerror$LWS]);
      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, _element$LWS, ['load', onload$LWS]);
    });
    ReflectApply$LWS(WeakMapProtoSet$LWS, elementToLoadingPromiseMap$LWS, [_element$LWS, promise$LWS]);
    ReflectApply$LWS(NodeProtoAppendChild$LWS, headRef$LWS, [_element$LWS]);
    return promise$LWS;
  } // Functionality based on https://sfdc.co/7FuDU but adjusted for multiple
  // sandboxes. loadScript will create one <script> element in the DOM per url
  // per sandbox.


  function loadScript$LWS(_thisArg$LWS, _url$LWS) {
    const urlAsString$LWS = toString$LWS(_url$LWS);
    let script$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, headRef$LWS, [`script[data-distorted-src='${escapeSingleQuotes$LWS(urlAsString$LWS)}'][${LOCKER_ID_DATA_NAME$LWS}='${LOCKER_ID_DATA_VALUE$LWS}']`]);

    if (script$LWS) {
      var _ReflectApply2$LWS;

      return (_ReflectApply2$LWS = ReflectApply$LWS(WeakMapProtoGet$LWS, elementToLoadingPromiseMap$LWS, [script$LWS])) != null ? _ReflectApply2$LWS : PromiseResolve$LWS();
    }

    script$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['script']);
    ReflectApply$LWS(ElementProtoSetAttribute$LWS, script$LWS, [LOCKER_ID_DATA_NAME$LWS, LOCKER_ID_DATA_VALUE$LWS]);
    script$LWS.type = 'text/javascript';
    script$LWS.src = urlAsString$LWS;
    return loadPromise$LWS(script$LWS, urlAsString$LWS);
  } // Functionality based on http://sfdc.co/bIpMYB but adjusted for multiple
  // sandboxes. loadStyle will create one <link> element in the DOM per url
  // for all the sandboxes.


  function loadStyle$LWS(_thisArg$LWS, _url$LWS) {
    const urlAsString$LWS = toString$LWS(_url$LWS);
    let link$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, headRef$LWS, [`link[href='${escapeSingleQuotes$LWS(urlAsString$LWS)}']`]);

    if (link$LWS) {
      var _ReflectApply3$LWS;

      return (_ReflectApply3$LWS = ReflectApply$LWS(WeakMapProtoGet$LWS, elementToLoadingPromiseMap$LWS, [link$LWS])) != null ? _ReflectApply3$LWS : PromiseResolve$LWS();
    }

    link$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['link']);
    link$LWS.type = 'text/css';
    link$LWS.rel = 'stylesheet';
    link$LWS.href = urlAsString$LWS;
    return loadPromise$LWS(link$LWS, urlAsString$LWS);
  }

  function makeRedGet$LWS(...bindings$LWS) {
    const {
      length: _length$LWS
    } = bindings$LWS;
    const redGet$LWS = ArrayCtor$LWS(_length$LWS);
    const descriptors$LWS = {};

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      descriptors$LWS[_i$LWS] = {
        __proto__: null,
        get: bindings$LWS[_i$LWS]
      };
    }

    ObjectDefineProperties$LWS(redGet$LWS, descriptors$LWS);
    return redGet$LWS;
  }

  function makeRedResyncImports$LWS(bindings$LWS) {
    return function (..._args$LWS) {
      for (let _i$LWS = 0, {
        length: _length$LWS
      } = bindings$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        try {
          // eslint-disable-next-line @typescript-eslint/no-unused-expressions
          bindings$LWS[_i$LWS]; // eslint-disable-next-line no-empty
        } catch (_unused35$LWS) {}
      }

      return spreadable$LWS(_args$LWS);
    };
  }

  function _namespace$LWS(object$LWS) {
    return ObjectFreeze$LWS(object$LWS);
  }

  function spreadable$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS[SymbolIterator$LWS] = ArrayIterator$LWS;
    return array$LWS;
  }

  function superApplyOrGet$LWS(__target$LWS, __key$LWS, thisArgOrReceiver$LWS, _args$LWS) {
    const superProto$LWS = ReflectGetPrototypeOf$LWS(__target$LWS);

    if (superProto$LWS === null) {
      return undefined;
    }

    return _args$LWS ? ReflectApply$LWS(superProto$LWS[__key$LWS], thisArgOrReceiver$LWS, _args$LWS) : ReflectGet$LWS(superProto$LWS, __key$LWS, thisArgOrReceiver$LWS);
  }

  function toString$LWS(__value$LWS) {
    return typeof __value$LWS === 'string' ? __value$LWS : `${__value$LWS}`;
  }

  return {
    asyncToGen: asyncToGen$LWS,
    forAwaitOf: forAwaitOf$LWS,
    loadScript: loadScript$LWS,
    loadStyle: loadStyle$LWS,
    makeRedGet: makeRedGet$LWS,
    makeRedResyncImports: makeRedResyncImports$LWS,
    namespace: _namespace$LWS,
    spreadable: spreadable$LWS,
    super: superApplyOrGet$LWS
  };
}})`; // WebKit based browsers have a bug that prematurely removes distortion entries
// from their weak map.

const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = (() => {
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = selfWindow$LWS;
  const webKitRegExp$LWS = /WebKit/i; // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands; // istanbul ignore else: needs default platform behavior test

  if ( // While experimental, `navigator.userAgentData.brands` may be defined
  // as an empty array in headless Chromium based browsers.
  ArrayIsArray$LWS$1(brands$LWS) && brands$LWS.length ? // Use user-agent client hints API if available to avoid
  // deprecation warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  // istanbul ignore next: this code is not reachable in the version of chrome used to measure coverage.
  brands$LWS.find( // istanbul ignore next
  item$LWS => {
    const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
    return typeof brand$LWS === 'string' && webKitRegExp$LWS.test(brand$LWS);
  }) : // Fallback to a standard user-agent string sniff.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  webKitRegExp$LWS.test(navigator$LWS.userAgent)) {
    return false;
  } // istanbul ignore next: needs default platform behavior test


  return true;
})();

const {
  location: selfLocation$LWS,
  top: topWindow$LWS
} = selfWindow$LWS; // Fast path non-configurable document, location, and window objects in the
// virtual environment distortion callback by seeding them in the top window's
// created distortion map.

const selfDistortionMapSeedEntries$LWS = [[selfDocument$LWS, selfDocument$LWS], [selfLocation$LWS, selfLocation$LWS], [selfWindow$LWS, selfWindow$LWS]];
const selfSandboxRegistry$LWS = {
  __proto__: null
};
const documentToSandboxRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[selfDocument$LWS, selfSandboxRegistry$LWS]]));
const documentToDistortionFactoriesMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const documentToEvaluationDistortionFactoriesMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const elementToLoadingPromiseMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const opaqueToDistortionFactoriesMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const opaqueToSandboxRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const seenGlobalObjects$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
  [SANDBOX_EVAL_CONTEXT_NAME$LWS]: {
    __proto__: null,

    get() {
      return clearEvalContext$LWS();
    }

  },
  [SANDBOX_EVAL_HELPERS_NAME$LWS]: {
    __proto__: null,

    get() {
      return clearEvalHelpers$LWS();
    }

  }
};
const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
const EMPTY_HELPERS$LWS = createEvalHelpersObject$LWS();
const EMPTY_OBJECT$LWS = {};
const TOP_UNCOMPILED_CONTEXT$LWS = {
  [UNCOMPILED_LOCATION_NAME$LWS]: selfLocation$LWS,
  [UNCOMPILED_TOP_NAME$LWS]: topWindow$LWS
};
let lockerEvalContextValue$LWS;
let lockerEvalHelpersValue$LWS;

function clearEvalContext$LWS() {
  const evalContext$LWS = lockerEvalContextValue$LWS;
  lockerEvalContextValue$LWS = undefined;
  return evalContext$LWS;
}

function clearEvalHelpers$LWS() {
  const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
  lockerEvalHelpersValue$LWS = undefined;
  return evalHelpers$LWS;
}

function createChildWindowSandboxRecord$LWS({
  globalObject: _globalObject$LWS,
  document: _document$LWS,
  context: _context$LWS,
  key: __key$LWS,
  type: _type$LWS
}, top$LWS = selfSandboxRegistry$LWS[__key$LWS]) {
  const sandboxRegistry$LWS = getSandboxRegistry$LWS(_document$LWS);
  let _record$LWS = sandboxRegistry$LWS[__key$LWS];

  if (_record$LWS) {
    return _record$LWS;
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = top$LWS;
  const {
    location: location$LWS
  } = _globalObject$LWS;
  const overrideDistortions$LWS = createDistortionMap$LWS();
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: {
      [UNCOMPILED_LOCATION_NAME$LWS]: location$LWS
    },
    context: _context$LWS,
    document: _document$LWS,
    distortions: overrideDistortions$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: _globalObject$LWS,
    helpers: createEvalHelpersObject$LWS(),
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$LWS$1,
    top: top$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  };
  _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
  _record$LWS.virtualEnvironmentEvaluator = createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS); // Fast path non-configurable document, location, and window objects in the
  // virtual environment distortion callback by adding them to the top window's
  // distortion map.

  distortions$LWS.set(_document$LWS, _document$LWS);
  distortions$LWS.set(location$LWS, location$LWS);
  const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(_globalObject$LWS);

  if (!seenGlobalObject$LWS) {
    // WindowProxy object references don't change when the window location
    // changes.
    // https://developer.mozilla.org/en-US/docs/Glossary/WindowProxy
    distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
  }

  const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS));
  const evaluationEntries$LWS = createDistortionEntries$LWS(_record$LWS, getEvaluationDistortionFactories$LWS(_record$LWS)); // Call `createAttributeDistortionFactories()` last because its factories
  // are populated by the other distortion factories.

  createDistortionEntries$LWS(_record$LWS, createAttributeDistortionFactories$LWS(_record$LWS), entries$LWS);

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[_i$LWS]; // Add distortion to the top window's distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = evaluationEntries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = evaluationEntries$LWS[_i$LWS]; // Add evaluation distortion for the child window to the top
    // window's distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS); // Add the undistorted entry to the child window's distortion map
    // so the undistorted entry is used in the child window's sandbox
    // instead of the distorted entry.

    overrideDistortions$LWS.set(entryKey$LWS, entryKey$LWS);
  }

  sandboxRegistry$LWS[__key$LWS] = _record$LWS;

  if (seenGlobalObject$LWS) {
    return _record$LWS;
  }

  seenGlobalObjects$LWS.add(_globalObject$LWS);

  const onDOMContentLoadedOrWindowLoad$LWS = () => {
    try {
      // We don't need to use `WindowDocumentGetter()` because we know
      // this is a window object and the 'document' property is
      // non-configurable.
      const {
        document: newDocument$LWS
      } = _globalObject$LWS; // Ensure the document has changed before attempting to create a
      // sandbox record.

      if (_document$LWS !== newDocument$LWS) {
        createChildWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: newDocument$LWS,
          globalObject: _globalObject$LWS,
          key: __key$LWS,
          type: _type$LWS
        }, top$LWS);
      }
    } catch (_unused36$LWS) {
      // istanbul ignore next: this is a safety precaution that is unreachable via tests
      createOpaqueChildWindowSandboxRecord$LWS({
        globalObject: _globalObject$LWS,
        key: __key$LWS,
        type: _type$LWS
      }, top$LWS);
    }
  };

  const frameElement$LWS = ReflectApply$LWS$1(WindowFrameElementGetter$LWS, _globalObject$LWS, []);

  if (frameElement$LWS) {
    // Create a new sandbox record when the iframe window location changes.
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, frameElement$LWS, ['load', onDOMContentLoadedOrWindowLoad$LWS, // useCapture
    true]);
  } else {
    // Create a new sandbox record when the opened window location changes.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes
    //
    // The 'unload' event handler is okay to use here under the assumption
    // that most `window.open()` calls are not done with the 'noopener'
    // option, so the back/forward cache (i.e. bfcache) is likely being
    // skipped anyways.
    // https://web.dev/bfcache/#avoid-window.opener-references
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['unload', function onWindowUnload$LWS() {
      WindowQueueMicrotask$LWS(() => {
        try {
          // Ensure the document has changed before adding event
          // listeners.
          const {
            document: newDocument$LWS
          } = _globalObject$LWS;

          if (_document$LWS !== newDocument$LWS) {
            ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['DOMContentLoaded', onDOMContentLoadedOrWindowLoad$LWS, true]);
            ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ['unload', onWindowUnload$LWS, true]);
          }
        } catch (_unused37$LWS) {
          // istanbul ignore next: this is a safety precaution that is unreachable via tests
          createOpaqueChildWindowSandboxRecord$LWS({
            globalObject: _globalObject$LWS,
            key: __key$LWS,
            type: _type$LWS
          }, top$LWS);
        }
      });
    }, // useCapture
    true]);
  }

  return _record$LWS;
}

function createDistortionEntries$LWS(_record$LWS, _factories$LWS, entries$LWS = []) {
  let {
    length: entriesOffset$LWS
  } = entries$LWS;

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = _factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const factory$LWS = _factories$LWS[_i$LWS];
    const entry$LWS = factory$LWS(_record$LWS);

    if (entry$LWS) {
      const {
        0: proxyTarget$LWS,
        1: distortedValue$LWS
      } = entry$LWS;

      if (typeof proxyTarget$LWS === 'function') {
        entries$LWS[entriesOffset$LWS++] = [proxyTarget$LWS, proxyWrapFunctionDistortion$LWS(_record$LWS, factory$LWS.name, proxyTarget$LWS, distortedValue$LWS)];
      } else if (typeof proxyTarget$LWS === 'object' && proxyTarget$LWS !== null) {
        entries$LWS[entriesOffset$LWS++] = entry$LWS;
      }
    }
  }

  return entries$LWS;
}

function createDistortionMap$LWS(entries$LWS) {
  return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? // istanbul ignore next: navigator.userAgentData.brands is used to infer WeakMap support, but the array is empty in Chrome Headless.
  toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1(entries$LWS)) : toSafeMap$LWS(new MapCtor$LWS(entries$LWS));
}

function createEvalHelpersObject$LWS() {
  return {
    asyncToGen: noop$LWS$1,
    forAwaitOf: noop$LWS$1,
    loadScript: noop$LWS$1,
    loadStyle: noop$LWS$1,
    makeRedGet: noop$LWS$1,
    makeRedResyncImports: noop$LWS$1,
    namespace: noop$LWS$1,
    spreadable: noop$LWS$1,
    super: noop$LWS$1
  };
}

function createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS) {
  // Defer creating a virtual environment and populating `record.helpers`
  // until the first call to `evaluate()`.
  let lazyVirtualEnvironmentEvaluator$LWS;
  return _sourceText$LWS => {
    if (lazyVirtualEnvironmentEvaluator$LWS === undefined) {
      const virtualEnvironmentEvaluator$LWS = createVirtualEnvironmentEvaluator$LWS(_record$LWS); // Overwrite `lazyVirtualEnvironmentEvaluator` with `virtualEnvironmentEvaluator`.

      lazyVirtualEnvironmentEvaluator$LWS = virtualEnvironmentEvaluator$LWS; // Stash old eval context.

      const oldEvalContext$LWS = clearEvalContext$LWS(); // Populate `record.helpers`.

      setEvalContext$LWS(redHelpersFactory$LWS => {
        ObjectAssign$LWS$1(_record$LWS.helpers, redHelpersFactory$LWS({
          elementToLoadingPromiseMap: elementToLoadingPromiseMap$LWS
        }));
      });
      virtualEnvironmentEvaluator$LWS(HELPERS_SOURCE_TEXT$LWS); // Restore old eval context.

      setEvalContext$LWS(oldEvalContext$LWS);
    }

    return lazyVirtualEnvironmentEvaluator$LWS(_sourceText$LWS);
  };
}

function createOpaqueChildWindowSandboxRecord$LWS({
  globalObject: _globalObject$LWS,
  key: __key$LWS,
  type: _type$LWS
}, top$LWS) {
  const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(_globalObject$LWS);
  let _record$LWS = sandboxRegistry$LWS[__key$LWS]; // istanbul ignore if: calls that would evaluate to true here ARE tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered

  if (_record$LWS) {
    return _record$LWS;
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = top$LWS;
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
    context: EMPTY_OBJECT$LWS,
    document,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: _globalObject$LWS,
    helpers: EMPTY_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$LWS$1,
    top: top$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  }; // Fast path non-configurable location and window objects in the virtual
  // environment distortion callback by adding them to the top window's
  // distortion map.

  const {
    location: location$LWS
  } = _globalObject$LWS;
  distortions$LWS.set(location$LWS, location$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (!seenGlobalObjects$LWS.has(_globalObject$LWS)) {
    distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
  }

  const opaqueEntries$LWS = createDistortionEntries$LWS(_record$LWS, getOpaqueDistortionFactories$LWS(_record$LWS));

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = opaqueEntries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = opaqueEntries$LWS[_i$LWS]; // Add opaque distortion for the child window to the top window's
    // distortion map.

    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  sandboxRegistry$LWS[__key$LWS] = _record$LWS;
  return _record$LWS;
}

function createSandboxEvaluator$LWS({
  LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
  document: _document$LWS,
  globalObject: _globalObject$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS,
  type: _type$LWS
}) {
  return (_sourceText$LWS, evalContext$LWS, evalGlobalObject$LWS = _globalObject$LWS, evalDocument$LWS = _document$LWS) => internalEvaluateInSandbox$LWS({
    context: evalContext$LWS,
    document: evalDocument$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: evalGlobalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: _sourceText$LWS,
    sourceType: 0
    /* SourceType.Script */
    ,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}

function createWindowSandboxRecord$LWS({
  context: _context$LWS,
  endowments: endowments$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS,
  type: _type$LWS,
  verboseInstrumentation: verboseInstrumentation$LWS
}) {
  let _record$LWS = selfSandboxRegistry$LWS[__key$LWS];

  if (_record$LWS) {
    return _record$LWS;
  }

  const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
  // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
  // removed in minified production builds.
  instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
  const distortions$LWS = createDistortionMap$LWS(selfDistortionMapSeedEntries$LWS);
  _record$LWS = {
    BASIC_INSTRUMENTATION_DATA: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? {
      sandboxKey: __key$LWS
    } : EMPTY_OBJECT$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    verboseInstrumentation$LWS && LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: TOP_UNCOMPILED_CONTEXT$LWS,
    context: _context$LWS,
    document: selfDocument$LWS,
    distortions: distortions$LWS,
    endowments: endowments$LWS,
    globalObject: selfWindow$LWS,
    helpers: createEvalHelpersObject$LWS(),
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    sandboxEvaluator: noop$LWS$1,
    top: EMPTY_OBJECT$LWS,
    type: _type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  };
  _record$LWS.top = _record$LWS;
  _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
  _record$LWS.virtualEnvironmentEvaluator = createLazyVirtualEnvironmentEvaluator$LWS(_record$LWS);
  const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS)); // Call `createAttributeDistortionFactories()` last because its factories
  // are populated by the other distortion factories.

  createDistortionEntries$LWS(_record$LWS, createAttributeDistortionFactories$LWS(_record$LWS), entries$LWS); // Add distortions to the top window's distortion map.

  for (let _i$LWS = 0, {
    length: _length$LWS
  } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[_i$LWS];
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }

  selfSandboxRegistry$LWS[__key$LWS] = _record$LWS;
  return _record$LWS;
}

function createVirtualEnvironmentEvaluator$LWS(_record$LWS) {
  const {
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
    distortions: overrideDistortions$LWS,
    endowments: endowments$LWS,
    globalObject: _globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    type: _type$LWS,
    top: top$LWS,
    top: {
      distortions: distortions$LWS
    }
  } = _record$LWS;
  const isTopRecord$LWS = _record$LWS === top$LWS;
  const env$LWS = createIframeVirtualEnvironment$LWS(_globalObject$LWS, {
    distortionCallback(originalTarget$LWS) {
      const distortedTarget$LWS = distortions$LWS.get(originalTarget$LWS);

      if (distortedTarget$LWS) {
        return isTopRecord$LWS ? distortedTarget$LWS : overrideDistortions$LWS.get(originalTarget$LWS) || distortedTarget$LWS;
      }

      if (typeof originalTarget$LWS === 'function') {
        return originalTarget$LWS;
      } // Perform the first own property check in a try-catch to avoid
      // throwing an error on opaque, non-window, objects of a cross-origin
      // window.


      try {
        // The location property is the only common non-configurable
        // property between window and document, so it serves this check
        // very well.
        if (!ObjectHasOwn$LWS$1(originalTarget$LWS, 'location')) {
          return originalTarget$LWS;
        }
      } catch (_unused38$LWS) {
        // Likely an opaque object of a cross-origin window.
        // istanbul ignore next: an access of property iframe.contentWindow.location.href on an opaque window, that should reach this catch clause IS tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
        return originalTarget$LWS;
      }

      let originalTargetDocument$LWS;
      let originalTargetWindow$LWS; // Do the safe cross-origin window object check first to avoid
      // failure caused by touching non-cross-origin-safe properties.

      if (ObjectHasOwn$LWS$1(originalTarget$LWS, 'window') && originalTarget$LWS.window === originalTarget$LWS) {
        // Slower check to detect a window object.
        try {
          // This will throw if `originalTarget` is not a window
          // object, or if it is an opaque cross-origin window.
          originalTargetDocument$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, originalTarget$LWS, []);
          originalTargetWindow$LWS = originalTarget$LWS;
        } catch (_unused39$LWS) {
          try {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (ReflectApply$LWS$1(WindowLocationGetter$LWS, originalTarget$LWS, [])) {
              createOpaqueChildWindowSandboxRecord$LWS({
                globalObject: originalTarget$LWS,
                key: __key$LWS,
                type: _type$LWS
              }, top$LWS);
              return originalTarget$LWS;
            } // eslint-disable-next-line no-empty

          } catch (_unused40$LWS) {}
        } // Check if originalTarget is a document and get its defaultView.

      } else if ('defaultView' in originalTarget$LWS) {
        // If the object doesn't appear to be a window, same or
        // cross-origin, then it may be a document for window that we
        // haven't seen yet, but can safely check non-cross-origin-safe
        // properties of, specifically `defaultView` which will give us
        // a window if one exists.
        let _defaultView$LWS;

        try {
          // This will throw if `originalTarget` is not a document object.
          _defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, originalTarget$LWS, []); // eslint-disable-next-line no-empty
        } catch (_unused41$LWS) {}

        if (_defaultView$LWS) {
          originalTargetDocument$LWS = originalTarget$LWS;
          originalTargetWindow$LWS = _defaultView$LWS;
        }
      }

      if (originalTargetWindow$LWS) {
        createChildWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: originalTargetDocument$LWS,
          globalObject: originalTargetWindow$LWS,
          key: __key$LWS,
          type: _type$LWS
        }, top$LWS);
      }

      return originalTarget$LWS;
    },

    endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ? // Normalize the descriptors of the provided endowments object,
    // and the default endowments descriptors so they can be
    // accessible from inside the sandbox.
    ObjectAssign$LWS$1({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, ObjectGetOwnPropertyDescriptors$LWS(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
    instrumentation: verboseInstrumentation$LWS ? instrumentation$LWS : undefined,
    // Flag whether the iframe should remain connected to DOM.
    keepAlive: false,
    liveTargetCallback: isTargetLive$LWS
  });
  return _sourceText$LWS => env$LWS.evaluate(_sourceText$LWS);
}

function getDistortionFactories$LWS(_record$LWS) {
  const {
    document: _document$LWS,
    globalObject: _globalObject$LWS,
    type: _type$LWS
  } = _record$LWS;
  let _factories$LWS = documentToDistortionFactoriesMap$LWS.get(_document$LWS);

  if (_factories$LWS === undefined) {
    const {
      Document: _Document$LWS,
      Element: _Element$LWS,
      HTMLElement: _HTMLElement$LWS,
      HTMLIFrameElement: _HTMLIFrameElement$LWS,
      HTMLScriptElement: _HTMLScriptElement$LWS,
      SVGElement: _SVGElement$LWS,
      XSLTProcessor: XSLTProcessor$LWS
    } = _globalObject$LWS;
    const initializers$LWS = _type$LWS === 1
    /* SandboxType.Internal */
    ? ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, internalKeyedDistortionFactoryInitializers$LWS) : ArrayConcat$LWS(externalDistortionFactoryInitializers$LWS, externalKeyedDistortionFactoryInitializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLElement$LWS, 'HTMLElement', HTMLElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLIFrameElement$LWS, 'HTMLIFrameElement', HTMLIFrameElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLScriptElement$LWS, 'HTMLScriptElement', HTMLScriptElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedAttributeDistortionFactoryInitializers$LWS(_SVGElement$LWS, 'SVGElement', SVGElementBlockedAttributes$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, CustomElementRegistry.prototype, CustomElementRegistryBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Document$LWS.prototype, DocumentBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Element$LWS.prototype, ElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS, initializers$LWS);
    createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS, initializers$LWS); // istanbul ignore else: this is a safety precaution that is unreachable via tests

    if (typeof XSLTProcessor$LWS === 'function') {
      createBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS, initializers$LWS);
    } // Reuse the `initializers` array as the `factories` array.


    _factories$LWS = initializers$LWS;

    for (let _i$LWS = 0, {
      length: _length$LWS
    } = _factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = initializers$LWS[_i$LWS](_record$LWS);
    }

    documentToDistortionFactoriesMap$LWS.set(_document$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getEvaluationDistortionFactories$LWS(_record$LWS) {
  const {
    document: _document$LWS
  } = _record$LWS;
  let _factories$LWS = documentToEvaluationDistortionFactoriesMap$LWS.get(_document$LWS);

  if (_factories$LWS === undefined) {
    const {
      length: _length$LWS
    } = evaluationDistortionFactoryInitializers$LWS;
    _factories$LWS = Array(_length$LWS);

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = evaluationDistortionFactoryInitializers$LWS[_i$LWS](_record$LWS);
    }

    documentToEvaluationDistortionFactoriesMap$LWS.set(_document$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getOpaqueDistortionFactories$LWS(_record$LWS) {
  const {
    globalObject: _globalObject$LWS
  } = _record$LWS;
  let _factories$LWS = opaqueToDistortionFactoriesMap$LWS.get(_globalObject$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (_factories$LWS === undefined) {
    const {
      length: _length$LWS
    } = opaqueDistortionFactoryInitializers$LWS;
    _factories$LWS = Array(_length$LWS);

    for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
      _factories$LWS[_i$LWS] = opaqueDistortionFactoryInitializers$LWS[_i$LWS](_record$LWS);
    }

    opaqueToDistortionFactoriesMap$LWS.set(_globalObject$LWS, _factories$LWS);
  }

  return _factories$LWS;
}

function getOpaqueSandboxRegistry$LWS(_globalObject$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = opaqueToSandboxRegistry$LWS.get(_globalObject$LWS); // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false

  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    opaqueToSandboxRegistry$LWS.set(_globalObject$LWS, sandboxRegistry$LWS);
  }

  return sandboxRegistry$LWS;
}

function getSandboxRegistry$LWS(_document$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = documentToSandboxRegistry$LWS.get(_document$LWS);

  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxRegistry$LWS.set(_document$LWS, sandboxRegistry$LWS);
  }

  return sandboxRegistry$LWS;
}

function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
  const {
    document: _document$LWS,
    context: _context$LWS,
    endowments: endowments$LWS,
    globalObject: _globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: source$LWS,
    sourceType: sourceType$LWS,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = evaluateOptions$LWS;

  if (typeof __key$LWS !== 'string') {
    throw new LockerSecurityError$LWS('Invalid sandbox key.');
  }

  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    helpers: helpers$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  } = _globalObject$LWS === selfWindow$LWS ? createWindowSandboxRecord$LWS({
    context: _context$LWS,
    endowments: endowments$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    type: _type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  }) : createChildWindowSandboxRecord$LWS({
    context: _context$LWS,
    document: _document$LWS,
    globalObject: _globalObject$LWS,
    key: __key$LWS,
    type: _type$LWS
  }); // Setting the context before evaluating the sourceText so compiled code
  // can wire up import/exports from both sides of the membrane.

  if (_context$LWS !== EMPTY_OBJECT$LWS) {
    setEvalContext$LWS(_context$LWS);
  }

  setEvalHelpers$LWS(helpers$LWS);
  let _result$LWS;
  const _sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
  const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
  let activity$LWS; // istanbul ignore else: this is a safety precaution that is unreachable via tests

  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
    activity$LWS = startActivity$LWS('evaluateInSandbox', BASIC_INSTRUMENTATION_DATA$LWS);
  }

  try {
    // Protecting against errors during evaluation can guarantee the state
    // of the EvalContext to avoid leaking context values
    _result$LWS = virtualEnvironmentEvaluator$LWS(_sourceText$LWS);
  } catch (error) {
    // istanbul ignore if: this is a safety precaution that is unreachable via tests
    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
      activity$LWS.error({
        sandboxKey: __key$LWS,
        error
      });
    }

    throw error;
  } finally {
    clearEvalContext$LWS();
    clearEvalHelpers$LWS();
  } // istanbul ignore else: this is a safety precaution that is unreachable via tests


  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
    activity$LWS.stop();
  }

  return _result$LWS;
}

function proxyWrapFunctionDistortion$LWS({
  BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
  LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
  LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
  instrumentation: instrumentation$LWS,
  key: __key$LWS
}, factoryName$LWS, originalFunc$LWS, distortedFunc$LWS) {
  const activityName$LWS = LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? factoryName$LWS ? ReflectApply$LWS$1(StringProtoReplace$LWS, factoryName$LWS, [LOCKER_IDENTIFIER_MARKER$LWS, '']) :
  /* istanbul ignore next: currently unreachable via tests */
  '<unknown>' : undefined;
  const startActivity$LWS = LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : undefined;
  const _proxy$LWS = new ProxyCtor$LWS(originalFunc$LWS, ObjectFreeze$LWS$1({
    apply(__target$LWS, thisArg$LWS, _args$LWS) {
      // istanbul ignore if: this is a safety precaution that is unreachable via tests
      if (thisArg$LWS === _proxy$LWS) {
        thisArg$LWS = distortedFunc$LWS;
      }

      let activity$LWS; // istanbul ignore if: this is a safety precaution that is unreachable via tests

      if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
      }

      try {
        return ReflectApply$LWS$1(distortedFunc$LWS, thisArg$LWS, _args$LWS);
      } catch (error) {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error({
            sandboxKey: __key$LWS,
            error
          });
        }

        throw error;
      } finally {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
      }
    },

    construct(__target$LWS, _args$LWS, newTarget$LWS) {
      // istanbul ignore else: no non-matching path found via tests
      if (newTarget$LWS === _proxy$LWS) {
        newTarget$LWS = distortedFunc$LWS;
      }

      let activity$LWS; // istanbul ignore if: this is a safety precaution that is unreachable via tests

      if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
      }

      try {
        return ReflectConstruct$LWS(distortedFunc$LWS, _args$LWS, newTarget$LWS);
      } catch (error) {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.error({
            sandboxKey: __key$LWS,
            error
          });
        }

        throw error;
      } finally {
        // istanbul ignore if: this is a safety precaution that is unreachable via tests
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
      }
    }

  }));
  return _proxy$LWS;
}

function setEvalContext$LWS(evalContext$LWS) {
  lockerEvalContextValue$LWS = evalContext$LWS;
}

function setEvalHelpers$LWS(evalHelpers$LWS) {
  lockerEvalHelpersValue$LWS = evalHelpers$LWS;
}

function toSourceText$LWS(__value$LWS, sourceType$LWS) {
  let _sourceText$LWS = typeof __value$LWS === 'function' ? extractFunctionBodySource$LWS(__value$LWS) : toString$LWS(__value$LWS); // We workaround bundlers, like Rollup, aggressively stripping inline source
  // maps by compiling them with the name "sandboxMappingURL". At runtime the
  // name is changed so the inline source map is registered.

  _sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, _sourceText$LWS, [// This regexp looks involved, but it prevents browsers and developer
  // tools from mistaking the regexp or the replacement string for an
  // actual source mapping URL.
  /\/\/# sandbox(?=MappingURL=.*?\s*$)/, '//# source']);
  return sourceType$LWS === 1
  /* SourceType.Module */
  && indexOfPragma$LWS(_sourceText$LWS, 'use strict') === -1 ? // Append "'use strict'" to the extracted function body so it is
  // evaluated in strict mode.
  `'use strict';${_sourceText$LWS}` : _sourceText$LWS;
}

function evaluateInSandbox$LWS(__key$LWS, source$LWS, _context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  return internalEvaluateInSandbox$LWS({
    context: _context$LWS,
    document: selfDocument$LWS,
    endowments: endowments$LWS,
    globalObject: selfWindow$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    source: source$LWS,
    sourceType: 1
    /* SourceType.Module */
    ,
    type: 0
    /* SandboxType.External */
    ,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}

const loaderDefine = globalThis.LWR.define;
/**
 * Mark an exports object as "live", see https://github.com/caridy/secure-javascript-environment/pull/87.
 *
 * @returns the marked object
 */
function markLiveObject(object) {
    Reflect.defineProperty(object, Symbol.for('@@lockerLiveValue'), {});
    return object;
}
/**
 * Evaluate the given exporter in a sandbox of the given namespace
 */
function vNextEvaluateModule(namespace, specifier, exporter) {
    let out;
    // first, stringify the exporter, wrapping it with Locker context
    // note: sourceMap does not work for now
    const src = `"use strict";$lockerEvalContext$(${exporter.toString()});\n//# sourceURL=modules/${specifier}.js\n`;
    evaluateInSandbox$LWS(namespace, src, (def) => {
        out = def;
    });
    return out;
}
/**
 * Return a "secure" version of the given exporter, either
 * the given exporter as is if the module is from a trusted
 * namespace/component, or a "lockerized" version of the exporter if not.
 */
function secureExporter(specifier, dependencies, exporter, trustedNamespaces) {
    const [namespace, name] = specifier.split('/');
    // return the exporter as is if it's from a trusted component or namespace
    if (trustedNamespaces.includes(namespace) ||
        trustedNamespaces.includes(`${namespace}/*`) ||
        trustedNamespaces.includes(`${namespace}/${name}`)) {
        return exporter;
    }
    // not a trusted namespace/component, let's lockerize the exporter
    const out = vNextEvaluateModule(namespace, specifier, exporter);
    // mark the exports object as "live" if needed
    const exportsIndex = dependencies.indexOf('exports');
    if (exportsIndex >= 0) {
        return function (...args) {
            const modifiedArgs = args.map((arg, index) => {
                return (index === exportsIndex && markLiveObject(arg)) || arg;
            });
            return out.apply(this, modifiedArgs);
        };
    }
    return out;
}
function registerLockerDefine(trustedNamespaces) {
    // override the global LWR.define() for Locker
    globalThis.LWR = Object.freeze(Object.assign(Object.assign({}, globalThis.LWR), {
        define: function (specifier, dependencies, exporter, signature) {
            if (typeof dependencies === 'function') {
                // when the module has no dependency, the bundler only passes 3 parameters, the specifier, exporter and signature
                // e.g. LWR.define('my/cmp', function() { return 1; }, {ownhash})
                signature = exporter;
                exporter = dependencies;
                dependencies = [];
            }
            loaderDefine(specifier, dependencies, secureExporter(specifier, dependencies, exporter, trustedNamespaces), signature);
        },
    }));
}

export { registerLockerDefine };
