var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/diagnostics/src/descriptions/configParser.ts
__markAsModule(exports);
__export(exports, {
  configParser: () => configParser
});
var import_core_diagnostics = __toModule(require("./core-diagnostics.cjs"));
var configParser = (0, import_core_diagnostics.createDiagnosticsCategory)({
  TEST: {message: "test"},
  TEST_ADVICE: (tagName, openLocation) => ({
    message: `Unclosed ${tagName} tag`,
    advice: [
      {type: "log", category: "info", text: `Tag started here`},
      {
        type: "frame",
        location: openLocation
      }
    ]
  }),
  INVALID_JSON: (invalidJsonError) => ({
    category: "lwrConfig/invalidJson",
    message: `Invalid JSON: ${invalidJsonError}`
  }),
  INCORRECT_NODE_TYPE: (configProperty, expectedNodeType, actualNodeType) => ({
    category: "lwrConfig/invalidSchema",
    message: `Incorrect node type for property "${configProperty}". Expected type: "${expectedNodeType}", got "${actualNodeType}"`
  }),
  INVALID_EMPTY_NODE: (configProperty) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must not be an empty object`
  }),
  INVALID_PROPERTY: (configProperty, prop) => ({
    category: "lwrConfig/invalidSchema",
    message: `Unexpected property "${prop}" in "${configProperty}" configuration`
  }),
  NON_EMPTY_STRING: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a non-empty string, received ${actualProp}`
  }),
  NON_EMPTY_ARRAY: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a non-empty array, received ${actualProp}`
  }),
  INVALID_PORT: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a valid port number, received ${actualProp}`
  }),
  INVALID_METHOD: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be "get" or "post", received ${actualProp}`
  }),
  INVALID_SERVER_TYPE: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be one of ["express" | "koa" | "fs"] , received ${actualProp}`
  }),
  INVALID_GENERATOR_CONFIG: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be an object , received ${actualProp}`
  }),
  INVALID_STATUS: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be 404 or 500, received ${actualProp}`
  }),
  INVALID_SPECIFIER: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a valid specifier, received ${actualProp}`
  }),
  INVALID_PATH: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a URI path string which starts but does not end with a slash, received ${actualProp}`
  }),
  INVALID_BASEPATH: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a URI base path string which starts with a slash, received ${actualProp}`
  }),
  INVALID_SERVICE: (configProperty, actualProp) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must be a valid service (a non-empty string or array with [non-empty string, any]), received ${actualProp}`
  }),
  INVALID_ENVIRONMENT: (configProperty) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" must define a default environment`
  }),
  MISSING_ONE_OF: (configProperty, childProps) => ({
    category: "lwrConfig/invalidSchema",
    message: `A "${configProperty}" must contain at least one of [${childProps}]`
  }),
  TOO_MANY: (configProperty, childProps) => ({
    category: "lwrConfig/invalidSchema",
    message: `A "${configProperty}" must contain exactly one of [${childProps}]`
  }),
  MISSING_REQUIRED: (configProperty, childProps) => ({
    category: "lwrConfig/invalidSchema",
    message: `Property "${configProperty}" is missing required properties [${childProps}]`
  }),
  DUPLICATE_IDS: (configProperty, dupeIds) => ({
    category: "lwrConfig/invalidSchema",
    message: `Each "${configProperty}" must have a unique "id", found duplicates [${dupeIds}]`
  })
});
