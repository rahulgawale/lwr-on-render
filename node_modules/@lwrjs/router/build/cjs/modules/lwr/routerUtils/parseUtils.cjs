var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/router/src/modules/lwr/routerUtils/parseUtils.ts
__markAsModule(exports);
__export(exports, {
  compileQueryObject: () => compileQueryObject,
  getQueryMatcher: () => getQueryMatcher,
  parseRoutes: () => parseRoutes
});
var import_routerErrors = __toModule(require("lwr/routerErrors"));
var import_pathToRegexp = __toModule(require("./pathToRegexp"));
var import_uriUtils = __toModule(require("./uriUtils"));
var {
  INVALID_ROUTE_QUERY,
  MISSING_ROUTE_TEMPLATE,
  MISSING_PAGE_BINDING,
  INVALID_PAGE_BINDING,
  INVALID_URI_SYNTAX
} = import_routerErrors.messages;
function parseRoutes(config) {
  const {routes, caseSensitive} = config;
  return routes.map((def) => {
    return parseUriRoute(def, caseSensitive);
  });
}
function parseUriRoute(def, caseSensitive = false) {
  const params = [];
  const {uri, page} = def;
  (0, import_routerErrors.invariant)(!!uri, MISSING_ROUTE_TEMPLATE);
  (0, import_routerErrors.invariant)(isValidUri(uri), INVALID_URI_SYNTAX);
  (0, import_routerErrors.invariant)(!!page, MISSING_PAGE_BINDING);
  const path = (0, import_uriUtils.getPathFromUrl)(uri);
  const query = (0, import_uriUtils.getQueryFromUrl)(uri);
  const regex = (0, import_pathToRegexp.pathToRegexp)(path, params, {
    sensitive: caseSensitive,
    end: def.exact === false ? false : true
  });
  const toPath = (0, import_pathToRegexp.compile)(path, {encode: encodeURIComponent});
  const compiledQuery = compileQueryObject(query);
  const queryMatcher = getQueryMatcher(compiledQuery, caseSensitive);
  const compiledRoute = {original: def, regex, params, toPath, compiledQuery, queryMatcher};
  (0, import_routerErrors.invariant)(isValidPageBinding(compiledRoute), INVALID_PAGE_BINDING);
  return compiledRoute;
}
function isValidUri(uri = "") {
  const invalid = ["*", "+", "(", ")", ";"];
  const containsInvalidCharacter = invalid.some((invalidChar) => uri.indexOf(invalidChar) >= 0);
  return !containsInvalidCharacter;
}
function isValidPageBinding(compiledDef) {
  const {original: {page} = {}, params, compiledQuery} = compiledDef;
  const pageType = page ? page.type : page;
  const pageAttributes = (page ? page.attributes : page) || {};
  const pageState = (page ? page.state : page) || {};
  if (typeof pageType !== "string" || typeof pageAttributes !== "object" || typeof pageState !== "object") {
    return false;
  }
  const pathParams = Object.values(params).map(({name}) => name);
  const queryParams = (0, import_uriUtils.getQueryNames)(compiledQuery);
  const allParams = [...pathParams, ...queryParams];
  const attributeBindings = Object.values(pageAttributes).filter(import_uriUtils.isParam).map(import_uriUtils.getParamName);
  const stateBindings = Object.values(pageState).filter(import_uriUtils.isParam).map(import_uriUtils.getParamName);
  const hasAllParams = allParams.every((paramName) => {
    if (typeof paramName !== "string") {
      return false;
    }
    return attributeBindings.indexOf(paramName) >= 0 || stateBindings.indexOf(paramName) >= 0;
  });
  const paramsUsedOnlyOnce = allParams.length === attributeBindings.length + stateBindings.length;
  return !!(page && pageType && pageAttributes && pageState && hasAllParams && paramsUsedOnlyOnce);
}
function compileQueryObject(queryObject) {
  const compiled = {};
  Object.keys(queryObject).forEach((qKey) => {
    const qValue = queryObject[qKey];
    (0, import_routerErrors.invariant)((0, import_uriUtils.isParam)(qKey) ? qValue === null : true, INVALID_ROUTE_QUERY);
    if ((0, import_uriUtils.isParam)(qKey)) {
      compiled[qKey.substr(1)] = {
        routeParamName: qKey
      };
    } else if (qValue && (0, import_uriUtils.isParam)(qValue)) {
      compiled[qKey] = {
        routeParamName: qValue
      };
    } else {
      compiled[qKey] = {
        literalValue: qValue === null ? null : qValue
      };
    }
  });
  return compiled;
}
function getQueryMatcher(compiledQuery, caseSensitive = false) {
  const queryMatcher = (queryObject) => {
    const inputKeys = Object.keys(queryObject);
    const defKeys = Object.keys(compiledQuery);
    const hasAllDefKeys = defKeys.every((defKey) => inputKeys.indexOf(defKey) >= 0);
    if (hasAllDefKeys) {
      return defKeys.reduce((matched, defKey) => {
        if (matched === null)
          return null;
        const {literalValue, routeParamName} = compiledQuery[defKey];
        const inputValue = queryObject[defKey];
        let literalValueMatches = true;
        if (typeof literalValue === "string") {
          literalValueMatches = caseSensitive ? literalValue === inputValue : literalValue.toUpperCase() === (inputValue == null ? inputValue : inputValue.toUpperCase());
        } else if (literalValue === null) {
          literalValueMatches = inputValue === literalValue;
        }
        if (literalValueMatches) {
          matched = {...matched, [defKey]: {value: inputValue, routeParamName}};
        } else {
          matched = null;
        }
        return matched;
      }, {});
    }
    return null;
  };
  return queryMatcher;
}
