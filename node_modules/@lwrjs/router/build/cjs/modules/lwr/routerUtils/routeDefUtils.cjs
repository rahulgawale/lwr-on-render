var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/router/src/modules/lwr/routerUtils/routeDefUtils.ts
__markAsModule(exports);
__export(exports, {
  getPageReferenceFromUriAndRouteDef: () => getPageReferenceFromUriAndRouteDef,
  getPathParams: () => getPathParams,
  getQueryParams: () => getQueryParams,
  matchRouteDefinitionByPageReference: () => matchRouteDefinitionByPageReference
});
var import_uriUtils = __toModule(require("./uriUtils"));
function matchRouteDefinitionByPageReference(pageReference, routeDefs) {
  if (!pageReference) {
    return null;
  }
  const {type: refType, attributes: refAttrs = {}, state: refState = {}} = pageReference;
  if (refType) {
    const [matched] = routeDefs.filter((compiledDef) => {
      const {
        original: {page: {type = null, attributes: pageAttrs = {}, state: pageState = {}} = {}}
      } = compiledDef;
      const matchesType = type === refType;
      const refAttributesHasAllPageKeys = Object.keys(pageAttrs).every((key) => {
        return Object.keys(refAttrs).indexOf(key) >= 0;
      });
      const refAttributesHasSameNumberOfKeys = Object.keys(pageAttrs).length === Object.keys(refAttrs).length;
      const refStateHasAllPageKeys = Object.keys(pageState).every((key) => {
        return Object.keys(refState).indexOf(key) >= 0;
      });
      const pageAttributeLiteralsCompletelyMatch = Object.keys(pageAttrs).filter((key) => {
        const value = pageAttrs[key];
        return !value || !(0, import_uriUtils.isParam)(value);
      }).every((key) => pageAttrs[key] === refAttrs[key]);
      const pageStateLiteralsCompletelyMatch = Object.keys(pageState).filter((key) => {
        const value = pageState[key];
        return value === null || !(0, import_uriUtils.isParam)(value);
      }).every((key) => pageState[key] === refState[key]);
      return matchesType && refAttributesHasAllPageKeys && refAttributesHasSameNumberOfKeys && pageAttributeLiteralsCompletelyMatch && refStateHasAllPageKeys && pageStateLiteralsCompletelyMatch;
    });
    return matched || null;
  }
  return null;
}
function getPathParams(path, routeDef) {
  const {regex, params: definedParams} = routeDef;
  const execArray = regex.exec(path);
  if (execArray) {
    const [, ...pathParamValues] = execArray;
    const pathParams = {};
    definedParams.forEach((param, index) => {
      const {name: paramName} = param;
      const paramValue = pathParamValues[index];
      pathParams[paramName] = paramValue ? (0, import_uriUtils.decode)(paramValue) : paramValue;
    });
    return pathParams;
  }
  return null;
}
function getQueryParams(queryObj, routeDef) {
  if (queryObj && routeDef) {
    const {queryMatcher} = routeDef;
    const matchedQuery = queryMatcher(queryObj);
    if (matchedQuery) {
      const params = {};
      Object.keys(matchedQuery).forEach((queryKeyName) => {
        const paramValue = matchedQuery[queryKeyName];
        const {value, routeParamName} = paramValue;
        const paramName = routeParamName ? routeParamName.substr(1) : queryKeyName;
        params[paramName] = value ? (0, import_uriUtils.decode)(value) : value;
      });
      return params;
    }
  }
  return null;
}
function getUnboundQueries(queryObj, routeDef) {
  const {compiledQuery} = routeDef;
  const boundKeys = Object.keys(compiledQuery).filter((qKey) => {
    const {literalValue} = compiledQuery[qKey];
    return !literalValue;
  });
  const unbound = {};
  Object.keys(queryObj).forEach((queryKey) => {
    const queryValue = queryObj[queryKey];
    if (boundKeys.indexOf(queryKey) < 0) {
      unbound[queryKey] = queryValue;
    }
  });
  return unbound;
}
function getPageReferenceFromUriAndRouteDef(uri, routeDef) {
  if (routeDef) {
    const {
      original: {
        page: {type: pageType = "", attributes: pageAttributes = {}, state: pageState = {}} = {}
      } = {}
    } = routeDef;
    const path = (0, import_uriUtils.getPathFromUrl)(uri);
    const query = (0, import_uriUtils.getQueryFromUrl)(uri);
    const pathParams = getPathParams(path, routeDef);
    const queryParams = getQueryParams(query, routeDef);
    if (pathParams && queryParams) {
      const allParams = {
        ...pathParams,
        ...queryParams
      };
      const boundAttributeParams = {};
      Object.keys(pageAttributes).forEach((attributeKey) => {
        const attributeValue = pageAttributes[attributeKey];
        let value;
        if (attributeValue && (0, import_uriUtils.isParam)(attributeValue)) {
          const paramName = attributeValue.substr(1);
          value = allParams[paramName];
        } else {
          value = attributeValue;
        }
        boundAttributeParams[attributeKey] = value;
      });
      const boundStateParams = {};
      Object.keys(pageState).forEach((stateKey) => {
        const stateValue = pageState[stateKey];
        let value;
        if (stateValue && (0, import_uriUtils.isParam)(stateValue)) {
          const paramName = stateValue.substr(1);
          value = allParams[paramName];
        } else {
          value = stateValue;
        }
        boundStateParams[stateKey] = value;
      });
      const unboundState = getUnboundQueries(query, routeDef);
      return {
        type: pageType,
        attributes: {...boundAttributeParams},
        state: {
          ...unboundState,
          ...boundStateParams
        }
      };
    }
  }
  return null;
}
