var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/router/src/modules/lwr/router/router.ts
__markAsModule(exports);
__export(exports, {
  createRouter: () => createRouter
});
var import_routerUtils = __toModule(require("lwr/routerUtils"));
var import_routerErrors = __toModule(require("lwr/routerErrors"));
var import_observable = __toModule(require("lwr/observable"));
var RouterImpl = class {
  constructor(config) {
    this.deprecatedConfig = {};
    this.routeHandlerId = 0;
    this.compiledRoutes = [];
    this.routeObservable = (0, import_observable.createObservable)();
    this.config = {
      basePath: config.basePath || "",
      caseSensitive: Boolean(config.caseSensitive),
      routes: config.routes || [],
      generateUrl: (address) => (0, import_routerUtils.getUrlFromPageReference)(address, this.compiledRoutes, this.config.basePath),
      parseUrl: (url) => (0, import_routerUtils.getPageReferenceFromUrl)(url, this.compiledRoutes, this.config.basePath)
    };
    const {DEPRECATED_getRouteFromUrl, DEPRECATED_getUrlFromRoute} = config;
    if (DEPRECATED_getRouteFromUrl) {
      this.deprecatedConfig.DEPRECATED_getRouteFromUrl = DEPRECATED_getRouteFromUrl;
    }
    if (DEPRECATED_getUrlFromRoute) {
      this.deprecatedConfig.DEPRECATED_getUrlFromRoute = DEPRECATED_getUrlFromRoute;
    }
    this.compiledRoutes = (0, import_routerUtils.parseRoutes)(this.config);
  }
  generateUrl(address) {
    const {DEPRECATED_getUrlFromRoute: getUrlFromRoute} = this.deprecatedConfig;
    if (getUrlFromRoute) {
      return getUrlFromRoute(address, this.config.generateUrl);
    } else {
      return this.config.generateUrl(address);
    }
  }
  parseUrl(url) {
    const {DEPRECATED_getRouteFromUrl: getRouteFromUrl} = this.deprecatedConfig;
    if (getRouteFromUrl) {
      return getRouteFromUrl(url, this.config.parseUrl);
    } else {
      return this.config.parseUrl(url);
    }
  }
  matchRoute(address) {
    const url = typeof address === "string" ? address : this.generateUrl(address);
    if (url === null) {
      return null;
    }
    const match = (0, import_routerUtils.matchRouteByUrl)(url, this.compiledRoutes, this.config.basePath);
    const pathMatch = match && (0, import_routerUtils.getUrlFromPageReferenceAndRouteDef)(match.route.pageReference, match.routeDefinition, this.config.basePath);
    if (!match || !pathMatch) {
      return null;
    }
    return {
      pathMatch,
      route: match.route,
      routeDefinition: match.routeDefinition.original
    };
  }
  async resolveView(address) {
    return new Promise((resolve, reject) => {
      const routingMatch = this.matchRoute(address);
      if (!routingMatch) {
        return reject((0, import_routerErrors.generateMessage)(import_routerErrors.messages.NO_ROUTE_MATCH, [JSON.stringify(address)]));
      }
      return routingMatch.routeDefinition.handler().then((handlerModule) => {
        const routeHandlerClass = handlerModule.default;
        if (!routeHandlerClass) {
          return reject((0, import_routerErrors.generateMessage)(import_routerErrors.messages.INVALID_ROUTE_HANDLER, [routingMatch.routeDefinition.id]));
        }
        const routeHandler = new routeHandlerClass(resolve);
        if (routeHandler) {
          routeHandler.update(routingMatch.route);
        }
      });
    });
  }
  navigate(address) {
    const routingMatch = this.matchRoute(address);
    if (!routingMatch) {
      throw new Error((0, import_routerErrors.generateMessage)(import_routerErrors.messages.MISSING_ROUTE, [JSON.stringify(address)]));
    }
    this.pendingRoute = {...routingMatch};
    this._mapView(this.pendingRoute);
  }
  subscribe(callback, replay) {
    return this.routeObservable.subscribe({
      next: callback,
      error: () => {
      },
      complete: () => {
      }
    }, Boolean(replay));
  }
  async _mapView(routingMatch) {
    const routeHandlerId = Math.random();
    this.routeHandlerId = routeHandlerId;
    const handlerModule = await routingMatch.routeDefinition.handler();
    const routeHandlerClass = handlerModule.default;
    if (!routeHandlerClass) {
      throw new Error((0, import_routerErrors.generateMessage)(import_routerErrors.messages.INVALID_ROUTE_HANDLER, [routingMatch.routeDefinition.id]));
    }
    this.routeHandler = new routeHandlerClass((routeDestination) => {
      this._updateView(routeHandlerId, routeDestination);
    });
    if (this.routeHandler) {
      this.routeHandler.update(routingMatch.route);
    }
    return true;
  }
  _updateView(viewHandlerId, routeDestination) {
    if (!routeDestination || !routeDestination.viewset || viewHandlerId !== this.routeHandlerId) {
      return;
    }
    if (!this.pendingRoute) {
      throw new Error("Trying to commit route state without a route");
    }
    const viewset = (0, import_routerUtils.freeze)(routeDestination.viewset);
    this.routeObservable.next({...this.pendingRoute, viewset});
  }
};
function createRouter(config = {}) {
  return new RouterImpl(config);
}
