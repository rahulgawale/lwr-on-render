var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/router/src/services/module-provider/index.ts
__markAsModule(exports);
__export(exports, {
  default: () => module_provider_default
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var import__ = __toModule(require("../index.cjs"));
var DEFAULT_DIR = "$rootDir/src/routes";
var RouterModuleProvider = class {
  constructor({routesDir = DEFAULT_DIR}, context) {
    this.name = "router-module-provider";
    this.watchedFileMap = new Map();
    this.routerModuleCache = new Map();
    const {
      appEmitter,
      config: {rootDir, contentDir, layoutsDir},
      runtimeEnvironment: {lwrVersion, watchFiles}
    } = context;
    this.version = lwrVersion;
    this.routesDir = (0, import_shared_utils.normalizeResourcePath)(routesDir, {
      rootDir,
      assets: [],
      contentDir,
      layoutsDir
    }).replace(/\/$/, "");
    this.routerEmitter = appEmitter;
    this.routerWatcher = watchFiles ? (0, import_utils.setUpWatcher)(this.onRouterModuleChange.bind(this)) : void 0;
  }
  async onRouterModuleChange(configPath, deleted = false) {
    const moduleId = this.watchedFileMap.get(configPath);
    if (!moduleId) {
      throw new Error("We are observing an unprocessed Router Config file, this should not happen...");
    }
    (0, import__.deleteRouterConfigJsonCacheEntry)(configPath);
    this.routerModuleCache.delete(configPath);
    if (!deleted) {
      const recompiledModule = await this.getModule(moduleId);
      if (recompiledModule) {
        this.routerEmitter.notifyModuleSourceChanged(recompiledModule);
      }
    }
  }
  watchConfigs(specifier, moduleId) {
    if (this.routerWatcher) {
      const configPath = (0, import_utils.getRouterConfigPath)(this.routesDir, specifier);
      if (!this.watchedFileMap.has(configPath)) {
        this.routerWatcher.add(configPath);
      }
      this.watchedFileMap.set(configPath, moduleId);
    }
  }
  getRouterConfig(specifier) {
    let config;
    const routerId = (0, import_utils.parseSpecifier)(specifier);
    if (routerId) {
      const configPath = (0, import_utils.getRouterConfigPath)(this.routesDir, specifier);
      config = (0, import__.getClientRoutes)(configPath);
    }
    return config;
  }
  async getModuleEntry({specifier}) {
    const config = this.getRouterConfig(specifier);
    if (config) {
      return {
        id: `${specifier}|${this.version}`,
        virtual: true,
        entry: `<virtual>/${specifier}.js`,
        specifier,
        version: this.version
      };
    }
  }
  async getModule(moduleId) {
    const {specifier, namespace, name = specifier} = moduleId;
    const moduleEntry = await this.getModuleEntry({specifier});
    if (!moduleEntry) {
      return;
    }
    const configPath = (0, import_utils.getRouterConfigPath)(this.routesDir, specifier);
    if (this.routerModuleCache.has(configPath)) {
      return this.routerModuleCache.get(configPath);
    }
    const config = this.getRouterConfig(specifier);
    const compiledSource = (0, import_utils.generateModule)(config);
    const moduleCompiled = {
      id: moduleEntry.id,
      specifier,
      namespace,
      name,
      version: this.version,
      originalSource: compiledSource,
      moduleEntry,
      ownHash: (0, import_shared_utils.hashContent)(compiledSource),
      compiledSource
    };
    this.watchConfigs(specifier, moduleId);
    this.routerModuleCache.set(configPath, moduleCompiled);
    return moduleCompiled;
  }
};
var module_provider_default = RouterModuleProvider;
