import { hashContent, normalizeResourcePath } from '@lwrjs/shared-utils';
import { generateModule, getRouterConfigPath, parseSpecifier, setUpWatcher } from './utils.js';
import { deleteRouterConfigJsonCacheEntry, getClientRoutes } from '../index.js';
const DEFAULT_DIR = '$rootDir/src/routes';
export default class RouterModuleProvider {
    constructor({ routesDir = DEFAULT_DIR }, context) {
        this.name = 'router-module-provider';
        this.watchedFileMap = new Map(); // <config path, module id>
        // Two layers of caching:
        //      1. Cache the Router Config JSON objects read from the file system, by config path (routerConfigJsonCache in ../index)
        //      2. Cache the modules generated from the config, by config path
        this.routerModuleCache = new Map();
        const { appEmitter, config: { rootDir, contentDir, layoutsDir }, runtimeEnvironment: { lwrVersion, watchFiles }, } = context;
        this.version = lwrVersion;
        // Replace aliases and remove trailing slash from the routes directory
        this.routesDir = normalizeResourcePath(routesDir, {
            rootDir,
            assets: [],
            contentDir,
            layoutsDir,
        }).replace(/\/$/, '');
        // Set up watcher on Router Config files
        this.routerEmitter = appEmitter;
        this.routerWatcher = watchFiles ? setUpWatcher(this.onRouterModuleChange.bind(this)) : undefined;
    }
    // When Router Metadata changes on the file system:
    //      1. delete the config data from the routerConfigJsonCache (in ../index)
    //      2. delete the module from the routerModuleCache
    //      3. recompile the module based on the new data and emit
    async onRouterModuleChange(configPath, deleted = false) {
        const moduleId = this.watchedFileMap.get(configPath);
        if (!moduleId) {
            throw new Error('We are observing an unprocessed Router Config file, this should not happen...');
        }
        deleteRouterConfigJsonCacheEntry(configPath);
        this.routerModuleCache.delete(configPath);
        if (!deleted) {
            const recompiledModule = await this.getModule(moduleId);
            if (recompiledModule) {
                this.routerEmitter.notifyModuleSourceChanged(recompiledModule);
            }
        }
    }
    // Watch Router Config files:
    //      1. Add files to the watcher
    //      2. Track watched files in the watchedFileMap with the associated module ID object
    watchConfigs(specifier, moduleId) {
        if (this.routerWatcher) {
            const configPath = getRouterConfigPath(this.routesDir, specifier);
            if (!this.watchedFileMap.has(configPath)) {
                this.routerWatcher.add(configPath);
            }
            this.watchedFileMap.set(configPath, moduleId);
        }
    }
    // 1. Check that:
    //      a. the specifier is in the correct format: "@lwrjs/router/{routerId}"
    //      b. the config JSON addressed by "routerId" is available on the file system
    // 2. Maintain the Router Config cache
    getRouterConfig(specifier) {
        let config;
        const routerId = parseSpecifier(specifier);
        if (routerId) {
            // Fetch the Router Config JSON
            const configPath = getRouterConfigPath(this.routesDir, specifier);
            config = getClientRoutes(configPath);
        }
        return config;
    }
    async getModuleEntry({ specifier }) {
        const config = this.getRouterConfig(specifier);
        if (config) {
            return {
                id: `${specifier}|${this.version}`,
                virtual: true,
                entry: `<virtual>/${specifier}.js`,
                specifier,
                version: this.version,
            };
        }
    }
    async getModule(moduleId) {
        // Retrieve the Module Entry
        const { specifier, namespace, name = specifier } = moduleId;
        const moduleEntry = await this.getModuleEntry({ specifier });
        if (!moduleEntry) {
            return;
        }
        // Check the module cache first
        const configPath = getRouterConfigPath(this.routesDir, specifier);
        if (this.routerModuleCache.has(configPath)) {
            return this.routerModuleCache.get(configPath);
        }
        // Generate code for the requested module
        const config = this.getRouterConfig(specifier);
        const compiledSource = generateModule(config);
        // Construct a Compiled Module
        const moduleCompiled = {
            id: moduleEntry.id,
            specifier,
            namespace,
            name,
            version: this.version,
            originalSource: compiledSource,
            moduleEntry,
            ownHash: hashContent(compiledSource),
            compiledSource,
        };
        // Watch Router Config file, add cache entries, and return
        this.watchConfigs(specifier, moduleId);
        this.routerModuleCache.set(configPath, moduleCompiled);
        return moduleCompiled;
    }
}
//# sourceMappingURL=index.js.map