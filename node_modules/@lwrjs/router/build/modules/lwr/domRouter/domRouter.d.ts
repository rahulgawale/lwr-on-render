/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
import type { RouteChange, DomRouterConfig } from 'lwr/domRouterUtils';
import type { ContextId } from 'lwr/navigationContext';
import type { Filter, MessageObject } from 'lwr/routerUtils';
import type { PageReference, Router, RouteCallback, RoutingMatch, RoutingResult } from 'lwr/router';
import type { Observable, Unsubscriber } from 'lwr/observable';
export declare const NAV_EVENT: string;
export declare const PARENT_EVENT: string;
interface RouterParent {
    addChild(child: DomRouter): Promise<void>;
}
export declare type ParentRouterEvent = CustomEvent<(router: RouterParent) => void>;
declare type DomRoutingMatch = RoutingMatch & {
    url: string;
};
interface DomRouterNode extends RouterParent {
    root: DomRouter;
    parent?: DomRouter;
    child?: DomRouter;
    connected: boolean;
    process(url: string, replace?: boolean): Promise<boolean>;
    processError(messageObject: MessageObject): void;
    preProcess(url: string): Promise<boolean>;
}
export interface DomRouter extends DomRouterNode {
    router: Router<PageReference>;
    pendingRoute: DomRoutingMatch | null;
    committedRoute: DomRoutingMatch | null;
    contextId: ContextId;
    historyDisabled?: boolean;
    connect(): void;
    disconnect(): void;
    addPreNavigate(filters: Filter<RouteChange> | Filter<RouteChange>[]): void;
    addErrorNavigate(filters: Filter<MessageObject> | Filter<MessageObject>[]): void;
    navigate(address: PageReference, replace?: boolean): void;
    generateUrl(address: PageReference): string | null;
    subscribe(callback: RouteCallback, replay?: boolean): Unsubscriber;
}
export declare class DomRouterImpl implements DomRouter {
    config: Required<DomRouterConfig>;
    target: EventTarget;
    router: Router<PageReference>;
    pendingRoute: DomRoutingMatch | null;
    committedRoute: DomRoutingMatch | null;
    routeObservable: Observable<RoutingResult>;
    eventId?: string;
    contextId: ContextId;
    connected: boolean;
    parent?: DomRouter;
    child?: DomRouter;
    preNavFilters: import("lwr/routerUtils").FilterChain<RouteChange>;
    errorNavFilters: import("lwr/routerUtils").FilterChain<MessageObject>;
    /**
     * Create and configure the Router.
     *
     * @param {object} config - The domRouter config object, all properties are optional
     * @param {object} router - an optional Router
     * @param {HTMLElement} target - DOM node to attach to
     */
    constructor(config: DomRouterConfig, router: Router<PageReference>, target?: EventTarget);
    /**
     * Search up the node chain until the root node is hit
     */
    get root(): DomRouter;
    /**
     * Informs an wire listeners of routing changes/errors
     *
     * @param {RoutingResult} result - result object from navigation event
     * @param {string} url - url from the page reference that triggered the navigation event
     * @param {MessageObject} error - if an error occurred during the navigation
     */
    updateWires(result: RoutingResult, url: string, error?: MessageObject): void;
    /**
     * Override to provide this router as a navigation context
     */
    connect(): void;
    disconnect(): void;
    /**
     * Add listeners to this router hook which run BEFORE a new URL is processed (root -> leaf).
     *
     * @param {object | object[]} filters
     */
    addPreNavigate(filters: Filter<RouteChange> | Filter<RouteChange>[]): void;
    /**
     * Add listeners to this router hook which run when there is an error navigating.
     *
     * @param {object | object[]} filters
     */
    addErrorNavigate(filters: Filter<MessageObject> | Filter<MessageObject>[]): void;
    /**
     * Override parent implementation.
     * Pass the current state down to a new child.
     *
     * @param {child} child - Child router
     */
    addChild(child: DomRouter): Promise<void>;
    /**
     * Process the current URL passed down by the parent router.
     * Stop propagation of the navigation event if a preNavigate filter returns false.
     *
     * Update the current path and route matches.
     * Update the observable to hold the new route.
     *
     * After processing, delegate to a child router, if it exists.
     *
     * @param {string} url - Relative URL string to process
     * @returns {boolean} - True if the processing was NOT blocked by a preNavigate listener
     */
    process(url: string, replace?: boolean): Promise<boolean>;
    /**
     * Run the preNavigate filters for this router.
     * After processing, delegate to a child router, if it exists.
     *
     * @param {string} url - Relative URL string to process,
     *                   cannot use a route since the processing is done in context
     *
     * @returns {Promise<boolean>} - Resolves to true if successful
     */
    preProcess(url: string): Promise<boolean>;
    /**
     * Run the errorNavigate filters for this router.
     * After processing, delegate to a child router, if it exists.
     *
     * @param {object} e - An error object to pass into the error hook listeners.
     */
    processError(messageObject: MessageObject): void;
    /**
     * lightning/navigation
     * Fire an event to send the navigation event up the DOM.
     * The root router will be the last to catch the event if it is not stopped.
     *
     * @param {object} address - Address to navigate to
     * @param {*} options - Usually a boolean; when true the previous browser history
     *                    entry should be replaced by this one
     */
    navigate(address: PageReference, replace?: boolean): void;
    /**
     * lightning/navigation
     * Generate a URL based on the given route.
     * Return a Promise containing the URL string.
     *
     * @param   {object} route - Route to generate a url for
     *
     * @returns {Promise<string>}
     */
    generateUrl(address: PageReference): string | null;
    /**
     * lightning/navigation
     * Subscribe a callback to the Observable on the current route of this router.
     *
     * @param {function} callback - A callback function invoked when the navigation state changes
     *                     callback(route, routeDef)
     * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
     */
    subscribe(callback: RouteCallback, replay?: boolean): Unsubscriber;
    /**
     * Inspect a navigation event bubbling up from a descendent component.
     * This node can choose to stop the event by returning false.
     * If propagation is not stopped, and this node is the root (no parent),
     *      then begin the root -> leaf processing of this new route.
     *      This will update the navigation event subscribers in each DomRouter, top down.
     *
     * @param {Event} event - With detail: { url, options }
     */
    private _handleNavigationEvent;
    /**
     * Be discovered as a parent for descendent components.
     * Stop immediate propagation because we only want 1 parent to be found.
     *
     * @param {Event} event - With detail: callback
     */
    private _handleParentEvent;
    private _sendEvent;
    private _stripUrlForChild;
}
/**
 * Create a new root Router, attach to the Window.
 * This is the public, programmatic API for root router creation.
 * An application can only have ONE root router.
 *
 * @param {object} config - The router config object
 *
 * @returns {object} - { addPreNavigate, addErrorNavigate, connect, disconnect }
 */
export declare function createDomRouter(config: DomRouterConfig, router: Router<PageReference>, target?: EventTarget): DomRouter;
export {};
//# sourceMappingURL=domRouter.d.ts.map