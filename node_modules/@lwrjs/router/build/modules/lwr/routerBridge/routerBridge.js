import { PARENT_EVENT } from 'lwr/domRouter';

// Bridge navigation events, without access to a <lwr-router-container> or NavigationContext
// Used to allow a bridge between a LWR Router and vanilla HTML/JS (eg: in LWR Everywhere)
class DomRouterBridge {
  constructor(config = {}, target = window) {
    // Provide fallbacks for missing config values
    this.config = {
      historyDisabled: !!config.historyDisabled,
      onReady: config.onReady || (() => {
        /* noop */
      }),
      onPostNavigate: config.onPostNavigate || (() => {
        /* noop */
      }),
      onError: config.onError || (() => {
        return true;
      })
    }; // Add a listener for the parent router event

    this.target = target;
    this.target.addEventListener(PARENT_EVENT, this.handleParentEvent);
  } // Routers send out the PARENT_EVENT to build a router hierarchy
  // Listen for this event to find the topmost router located beneath the bridge in the DOM
  // NOTE: because of the restrictions on "lwr/router" hierachy, this is only called 0 or 1 time(s)
  //       - only ONE root router is allowed in a document
  //       - sibling routers are NOT allowed


  handleParentEvent = event => {
    const parentEvent = event;

    if (parentEvent && parentEvent.detail && typeof parentEvent.detail === 'function') {
      // event.detail() will call this.addChild()
      parentEvent.detail(this);

      if (this.bridgedRouter) {
        // Ensure the bridge does not become part of the router hierarchy
        this.bridgedRouter.parent = undefined;
        this.target.removeEventListener(PARENT_EVENT, this.handleParentEvent);
      }
    }
  }; // Save an observed router and subscribe to its navigation and error updates

  async addChild(child) {
    this.bridgedRouter = child;
    this.bridgedRouter.subscribe(({
      route: {
        pageReference
      }
    }) => {
      this.config.onPostNavigate(pageReference); // ONLY return the page reference
    });
    this.bridgedRouter.addErrorNavigate(this.config.onError); // Prevent the observed router from altering the browser URL or history
    // This is good practice for routers embedded in an outside host document

    if (this.config.historyDisabled) {
      this.bridgedRouter.historyDisabled = true;
    } // The router PARENT_EVENT is sent before the NAV_EVENT is subscribed,
    //      so mark this bridge as ready in the next event loop.
    // The events are both set up during router.connect(),
    //      so they'll be finished before the timeout triggers.


    await new Promise(resolve => {
      /* eslint-disable-next-line */
      setTimeout(() => {
        this.config.onReady();
        resolve();
      }, 0);
    });
  } // Use the observed router to navigate to the given page reference
  // Return true if the router is connected and the navigation event was sent
  // False is returned if there are no mounted routers to observe (yet)


  navigate(pageRef) {
    if (this.bridgedRouter && this.bridgedRouter.connected) {
      this.bridgedRouter.navigate(pageRef);
      return true;
    }

    return false;
  }

} // Return a subset of the bridge class instance, as an API


export function createBridge(config, target) {
  const bridge = new DomRouterBridge(config, target);
  return {
    navigate: bridge.navigate.bind(bridge)
  };
}