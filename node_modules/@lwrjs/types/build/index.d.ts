/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import fs from 'fs';
import { Server } from 'http';
import { Readable } from 'stream';
import { BundleConfig, EnvironmentConfig, HooksPlugin, LwrLockerConfig, NormalizedLwrErrorRoute, NormalizedLwrGlobalConfig, NormalizedLwrRoute, ResolverModuleRecord } from './config.js';
import { AssetReference, CompiledView, PublicViewRegistry, ViewProvider, ViewRegistry, ViewTransformPlugin } from './views.js';
export * from './lwr-shim.js';
export * from './config.js';
export * from './server.js';
export * from './views.js';
export * from './serviceAPI/serviceAPI.js';
export * from './serviceAPI/loaderPlugins/loaderPlugins.js';
export * from './serviceAPI/handleStaleModule/handleStaleModule.js';
export * from './serviceAPI/appMetadata/appMetadata.js';
export declare type Json = undefined | null | boolean | number | string | Json[] | {
    [prop: string]: Json;
};
export declare type Dict<T> = Record<string, T>;
export declare type JsonCompatible<T> = {
    [P in keyof T]: T[P] extends Json ? T[P] : Pick<T, P> extends Required<Pick<T, P>> ? never : JsonCompatible<T[P]>;
};
export declare type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type Specifier = string;
export declare type Version = string;
export interface AbstractModuleId {
    specifier: string;
    namespace?: string;
    name?: string;
    importer?: string;
    version?: Version;
}
export interface ModuleId {
    id: string;
    specifier: string;
    namespace?: string;
    name: string;
    version: Version;
}
export interface ModuleJson {
    specifier: string;
    version?: Version;
    ownHash?: string;
    links: {
        self: string;
    };
}
export interface ModuleJsonDefinition {
    specifier: string;
    version: Version;
    ownHash: string;
    dependencies: ModuleJson[];
    format: ModuleFormat;
    minified: boolean;
    code: string;
    metadata?: object;
}
export interface ImportMetadata {
    imports: ImportMetadataImports;
    index?: ImportMetadataIndex;
}
export interface ImportMetadataImports {
    [uri: string]: string[];
}
export interface ImportMetadataIndex {
    [specifier: string]: string;
}
export declare type ModuleEntry = FsModuleEntry | VirtualModuleEntry;
interface BaseModuleEntry {
    id: string;
    entry: string;
    virtual?: boolean;
    scope?: string;
    specifier: Specifier;
    version: Version;
    interchangeable?: boolean;
}
export interface FsModuleEntry extends BaseModuleEntry {
    virtual?: false;
}
export interface VirtualModuleEntry extends BaseModuleEntry {
    virtual: true;
}
export interface BaseModuleReference {
    scope?: string;
    namespace?: string;
    name: string;
    specifier: string;
    version: Version;
    interchangeable?: boolean;
}
export interface ImportModuleReference extends BaseModuleReference {
    sourceSpecifier: Specifier;
    locations: SourceLocation[];
}
interface DynamicImportLocation {
    location: SourceLocation;
    importLocation: SourceLocation;
}
export interface BaseDynamicModuleReference extends BaseModuleReference {
    sourceSpecifier: Specifier;
    moduleNameType: ModuleNameType;
}
export interface DynamicImportReference extends BaseDynamicModuleReference {
    locations: DynamicImportLocation[];
}
export interface ModuleRecord {
    imports?: ImportModuleReference[];
    dynamicImports?: DynamicImportReference[];
}
export interface ChildHashObject {
    [specifier: string]: string;
}
export interface SignatureRecord {
    hashes?: ChildHashObject;
}
export interface ModuleSource extends ModuleId {
    ownHash: string;
    originalSource: string;
    moduleEntry: ModuleEntry;
}
export interface ModuleCompiled extends ModuleSource {
    compiledSource: string;
    compiledMetadata?: CompiledMetadata;
}
export interface ModuleDefinition extends ModuleCompiled {
    moduleRecord: ModuleRecord;
}
export interface LinkedModuleDefinitionConfig {
    minified: boolean;
}
export interface LinkedModuleDefinition extends ModuleDefinition {
    linkedSource: string;
    linkedModuleRecord: ModuleRecord;
    linkedConfig: LinkedModuleDefinitionConfig;
    runtimeEnvironment: RuntimeEnvironment;
    runtimeParams?: RuntimeParams;
}
export interface CodeSource {
    code: string;
    sourcemap?: string;
}
export interface SignedSource extends CodeSource {
    signedCode?: string;
}
export declare type CompatMode = '0' | '1';
export declare type ModuleFormat = 'esm' | 'amd';
export interface ServerModeConfig {
    format: ModuleFormat;
    bundle: boolean;
    minify: boolean;
    compat: CompatMode;
    watchFiles: boolean;
    debug: boolean;
    defaultLocale: string;
    hmrEnabled: boolean;
    immutableAssets: boolean;
    env: {
        NODE_ENV: string;
    };
    featureFlags: FeatureFlags;
}
export interface FeatureFlags {
    LEGACY_LOADER: boolean;
}
export interface RuntimeEnvironment extends ServerModeConfig {
    apiVersion: string;
    lwrVersion: string;
    debug: boolean;
    serverMode: string;
    basePath: string;
}
export interface SourceMapRuntimeEnvironment extends RuntimeEnvironment {
    sourceMapUrl?: string;
}
export declare type RuntimeParams = Record<string, string | number | boolean | null | undefined | Record<string, string>>;
export interface ModuleIdentity {
    signature: string;
    moduleId: AbstractModuleId;
}
export interface MappingIdentity {
    moduleIds: AbstractModuleId[];
}
export interface ResourceIdentity {
    signature: string;
    resourceId: ResourceIdentifier;
}
export interface AssetIdentity {
    assetId: AssetIdentifier;
    signature: string;
}
export interface RuntimeContext {
    runtimeEnvironment: RuntimeEnvironment;
    runtimeParams: RuntimeParams;
}
export interface BootstrapRuntimeEnvironment extends RuntimeEnvironment {
    bootstrapImports?: string[];
    bootstrapDynamicImports?: string[];
}
export interface Watcher extends EventEmitter {
    add(paths: string | ReadonlyArray<string>): void;
    unwatch(paths: string | ReadonlyArray<string>): void;
    getWatched(): {
        [directory: string]: string[];
    };
    on(event: 'add' | 'addDir' | 'change', listener: (path: string, stats?: fs.Stats) => void): this;
    on(event: 'all', listener: (eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', path: string, stats?: fs.Stats) => void): this;
    on(event: 'error', listener: (error: Error) => void): this;
    on(event: 'raw', listener: (eventName: string, path: string, details: Record<string, Json>) => void): this;
    on(event: 'ready', listener: () => void): this;
    on(event: 'unlink' | 'unlinkDir', listener: (path: string) => void): this;
    on(event: string, listener: (...args: unknown[]) => void): this;
}
export interface LwrAppObserver {
    onModuleDefinitionChange(listener: (event: ModuleDefinitionChangedEvent) => void): void;
    onModuleSourceChange(listener: (event: ModuleSourceChangedEvent) => void): void;
    onViewSourceChange(listener: (event: ViewSourceChangedEvent) => void): void;
    onAssetSourceChange(listener: (event: AssetSourceChangedEvent) => void): void;
}
export interface LwrAppEmitter {
    notifyModuleDefinitionChanged(payload: LinkedModuleDefinition): void;
    notifyModuleSourceChanged(payload: ModuleCompiled): void;
    notifyViewSourceChanged(payload: CompiledView): void;
    notifyAssetSourceChanged(payload: AssetSource): void;
}
export declare type EVENT_MODULE_DEFINITION_CHANGED = 'module_definition_changed';
export interface ModuleDefinitionChangedEvent {
    eventType: EVENT_MODULE_DEFINITION_CHANGED;
    payload: LinkedModuleDefinition;
}
export declare type EVENT_MODULE_SOURCE_CHANGED = 'module_source_changed';
export declare type EVENT_ASSET_SOURCE_CHANGED = 'asset_source_changed';
export declare type EVENT_VIEW_SOURCE_CHANGED = 'view_source_changed';
export interface ModuleSourceChangedEvent {
    eventType: EVENT_MODULE_SOURCE_CHANGED;
    payload: ModuleCompiled;
}
export interface ViewSourceChangedEvent {
    eventType: EVENT_VIEW_SOURCE_CHANGED;
    payload: CompiledView;
}
export interface AssetSourceChangedEvent {
    eventType: EVENT_ASSET_SOURCE_CHANGED;
    payload: AssetSource;
}
export interface ModuleProvider {
    name: string;
    getModule<T extends AbstractModuleId>(moduleId: T, runtimeParams?: RuntimeParams): Promise<ModuleCompiled | undefined>;
    getModuleEntry<T extends AbstractModuleId>(moduleId: T, runtimeParams?: RuntimeParams): Promise<ModuleEntry | undefined>;
}
export declare type LwrService = ModuleProvider | ResourceProvider | ViewProvider | AssetProvider | HooksPlugin | AssetTransformPlugin | ViewTransformPlugin;
export interface ServiceCtor<T extends LwrService, R extends Record<string, Json> = {}> {
    new (moduleProviderConfig: R, serviceProviderConfig?: any, ...args: any[]): T;
}
export interface ModuleRegistry {
    name: string;
    addModuleProviders(registries: ModuleProvider[]): void;
    getLinkedModule<T extends AbstractModuleId>(moduleId: T, runtimeEnvironment: RuntimeEnvironment, runtimeParams?: RuntimeParams): Promise<LinkedModuleDefinition>;
    getModule<T extends AbstractModuleId>(moduleId: T, runtimeParams?: RuntimeParams): Promise<ModuleDefinition>;
    getModuleEntry(moduleId: AbstractModuleId, runtimeParams?: RuntimeParams): Promise<ModuleEntry>;
    resolveModuleUri<R extends RuntimeEnvironment, S extends string | undefined>(moduleId: Required<Pick<ModuleId, 'specifier' | 'version'>>, runtimeEnvironment: R, runtimeParams?: RuntimeParams, signature?: S): S extends string ? string : Promise<string>;
    getPublicApi(): PublicModuleRegistry;
}
export declare type PublicModuleRegistry = Pick<ModuleRegistry, 'getModule' | 'getModuleEntry' | 'resolveModuleUri'>;
export interface ModuleBundler {
    getModuleBundle<T extends AbstractModuleId, R extends RuntimeEnvironment>(moduleId: T, runtimeEnvironment: R, runtimeParams?: RuntimeParams, bundleConfigOverrides?: BundleConfig): Promise<BundleDefinition>;
}
export declare type PublicModuleBundler = Pick<ModuleBundler, 'getModuleBundle'>;
export interface BundleRecord {
    imports?: BaseModuleReference[];
    dynamicImports?: BaseDynamicModuleReference[];
    includedModules: string[];
}
export interface BundleDefinition extends ModuleId {
    code: string;
    config: BundleConfig;
    map?: any;
    bundleRecord: BundleRecord;
}
export interface ProviderAppConfig {
    modules: ResolverModuleRecord[];
    routes: NormalizedLwrRoute[];
    errorRoutes: NormalizedLwrErrorRoute[];
    basePath: string;
    rootDir: string;
    contentDir: string;
    layoutsDir: string;
    cacheDir: string;
    locker: LwrLockerConfig;
    amdLoader: string;
    esmLoader: string;
    environment?: EnvironmentConfig;
}
export interface ProviderContext {
    compiler: Compiler;
    appObserver: Pick<LwrAppObserver, 'onModuleDefinitionChange' | 'onModuleSourceChange' | 'onAssetSourceChange' | 'onViewSourceChange'>;
    appEmitter: Pick<LwrAppEmitter, 'notifyModuleDefinitionChanged' | 'notifyAssetSourceChanged' | 'notifyModuleSourceChanged' | 'notifyViewSourceChanged'>;
    moduleRegistry: PublicModuleRegistry;
    moduleBundler: PublicModuleBundler;
    resourceRegistry: PublicResourceRegistry;
    viewRegistry: PublicViewRegistry;
    assetRegistry: PublicAssetRegistry;
    config: ProviderAppConfig;
    runtimeEnvironment: RuntimeEnvironment;
}
export interface ResourceIdentifier {
    specifier: string;
    version?: Version;
}
export interface AssetIdentifier {
    specifier: string;
    type?: AssetType;
    importer?: string;
}
export interface AssetUri {
    uri: string;
    immutable: boolean;
    entry: string;
}
export declare type ResourceType = 'application/javascript' | 'application/json' | 'text/css' | 'lwr-importmap' | 'module';
export interface ResourceDefinition {
    specifier?: string;
    type: ResourceType;
    src?: string;
    inline?: boolean;
    async?: boolean;
    defer?: boolean;
    nonce?: string;
    content?: string;
    stream?: Readable;
    isPreload?: boolean;
}
export interface AssetMetadata {
    assetReferences?: AssetReference[];
}
export interface AssetSource {
    entry: string;
    ext: string;
    mime: string | false;
    ownHash: string;
    content: (encoding?: BufferEncoding) => string | Buffer;
    uri?: string;
    metadata?: AssetMetadata;
}
export declare type AssetType = 'asset' | 'content-asset' | 'external' | 'unknown';
export interface AssetDefinition extends AssetSource {
    uri: string;
    type: AssetType;
    stream: (encoding?: BufferEncoding) => Readable;
}
export declare type ResourceJson = Pick<ResourceDefinition, 'type' | 'src'>;
export interface ResourceProvider {
    name: string;
    getResource<R extends ResourceIdentifier, T extends BootstrapRuntimeEnvironment>(resourceIdentity: R, runtimeEnvironment: T, runtimeParams?: RuntimeParams): Promise<ResourceDefinition | undefined>;
}
export interface AssetProvider {
    name: string;
    getAsset(fileAssetPath: string): Promise<AssetSource | undefined>;
}
export declare type TransformPluginContext = Record<string, any>;
declare type AssetPluginTransformHook = (code: string | Buffer, assetSource: AssetSource, context?: TransformPluginContext) => Promise<AssetPluginTransformHookReturn>;
declare type AssetPluginTransformHookReturn = null | undefined | false | string | Buffer | {
    code: string | Buffer;
    context?: TransformPluginContext;
};
declare type AssetPluginExtractMetaHook = (code: string | Buffer, assetSource: AssetSource, context?: TransformPluginContext) => Promise<AssetPluginExtractMetaHookReturn>;
declare type AssetPluginExtractMetaHookReturn = null | undefined | false | {
    metadata?: AssetMetadata;
    context?: TransformPluginContext;
};
declare type AssetPluginOptimizeHook = (code: string | Buffer, assetSource: AssetSource, context?: TransformPluginContext) => Promise<AssetPluginOptimizeHookReturn>;
declare type AssetPluginOptimizeHookReturn = null | undefined | false | string | Buffer | {
    code: string | Buffer;
    map?: any;
    context?: TransformPluginContext;
};
export interface AssetTransformHooks {
    transform: AssetPluginTransformHook;
    extractMetadata: AssetPluginExtractMetaHook;
    optimize: AssetPluginOptimizeHook;
}
export interface AssetTransformPlugin extends Partial<AssetTransformHooks> {
    name: string;
}
export interface ResourceRegistry {
    name: string;
    addResourceProviders(provider: ResourceProvider[]): void;
    getResource<R extends ResourceIdentifier, T extends RuntimeEnvironment>(resourceIdentity: R, runtimeEnvironment: T, runtimeParams?: RuntimeParams): Promise<ResourceDefinition | undefined>;
    resolveResourceUri<R extends ResourceIdentifier, T extends RuntimeEnvironment>(resourceIdentity: R, runtimeEnvironment: T): string;
    getPublicApi(): PublicResourceRegistry;
}
export declare type PublicResourceRegistry = Pick<ResourceRegistry, 'getResource' | 'resolveResourceUri'>;
export interface AssetRegistry {
    name: string;
    addAssetProviders(provider: AssetProvider[]): void;
    getAsset<R extends AssetIdentifier, T extends RuntimeEnvironment>(resourceIdentity: R, runtimeEnvironment: T, includeMetadata?: boolean): Promise<AssetDefinition>;
    resolveAssetUri<R extends AssetIdentifier, T extends RuntimeEnvironment>(resourceIdentity: R, runtimeEnvironment: T): Promise<AssetUri>;
    getPublicApi(): PublicAssetRegistry;
}
export declare type PublicAssetRegistry = Pick<AssetRegistry, 'getAsset' | 'resolveAssetUri'>;
export interface CompilerConfig {
    name: string;
    namespace?: string;
    filename: string;
    scopedStyles?: boolean;
}
export declare type SourceMap = string | null | undefined;
export interface CompiledMetadata {
    imports?: Import[];
    dynamicImports?: DynamicImport[];
}
export interface SourceLocation {
    startColumn: number;
    endColumn: number;
}
export interface Import {
    moduleSpecifier: string;
    location: SourceLocation;
}
export declare type ModuleNameType = 'string' | 'unresolved';
export interface DynamicImport {
    moduleSpecifier: string;
    location: SourceLocation;
    importLocation: SourceLocation;
    moduleNameType: ModuleNameType;
}
export interface CompilerResult {
    code: string;
    map?: SourceMap;
    metadata?: CompiledMetadata;
}
export interface BundleFiles {
    [filename: string]: string;
}
export interface Compiler {
    convertToAmd(source: string, { id }: {
        id: string;
    }): Promise<CompilerResult>;
    getModuleMetadata(compiledSource: string): Promise<Partial<CompiledMetadata>>;
    lockerize(compiledModule: ModuleCompiled, lockerConfig: LwrLockerConfig, sourcemap: boolean): CompilerResult;
    minifyJavascript(source: string): Promise<CompilerResult>;
    parseJavascript(source: string, options: ParseOptions): Promise<CompilerResult>;
    minifyCSS(source: string): Promise<CompilerResult>;
}
export interface ParseOptions {
    envMode: string;
}
export interface CompilerContext {
    runtimeEnvironment: RuntimeEnvironment;
}
export interface ClientBootstrapConfig {
    appId?: string;
    bootstrapModule: string;
    requiredModules?: string[];
    autoBoot: boolean;
    preloadModules?: string[];
    rootComponent?: string;
    rootComponents?: string[];
    ssrProps?: Json;
    customInit?: Function;
    onError?: Function;
    baseUrl?: string;
    disableInitDefer?: boolean;
    endpoints?: Endpoints;
    imports?: ImportMetadataImports;
    index?: ImportMetadataIndex;
    metricsConfig?: MetricsConfig;
    /**
    /* @deprecated for mapping endpoint syntax
    /* Import map for the loader to resolve modules, defaults to a "lwr-importmap" script tag
    */
    importMappings?: object;
}
export interface Endpoints {
    uris: Record<string, string>;
    modifiers?: Record<string, string>;
}
export interface BootstrapJson {
    ownHash: string;
    resources: ResourceJson[];
    modules: ModuleJson[];
    workers: {
        [id: string]: ModuleJson;
    };
}
export interface MetricsConfig {
    enableModuleFetchTracking?: boolean;
    enableMappingFetchTracking?: boolean;
}
export interface ServerContext {
    appObserver: LwrAppObserver;
    appEmitter: LwrAppEmitter;
    server: Server;
    compiler: Compiler;
    moduleRegistry: ModuleRegistry;
    moduleBundler: ModuleBundler;
    viewRegistry: ViewRegistry;
    resourceRegistry: ResourceRegistry;
    assetRegistry: AssetRegistry;
    appConfig: NormalizedLwrGlobalConfig;
    runtimeEnvironment: RuntimeEnvironment;
}
export interface Observer<V> {
    next: (value: V) => void;
    error: (error: Error) => void;
    complete: () => void;
}
export interface Observable<V> {
    next: (value: V) => void;
    error: (error: Error) => void;
    complete: () => void;
    subscribe: (obs: Observer<V>, replay?: boolean) => Unsubscriber;
}
export interface Unsubscriber {
    unsubscribe: () => void;
}
export interface GraphOptions {
    includeUris?: boolean;
    includeLinkedDefinitions?: boolean;
    depth: GraphDepthOptions;
}
export interface IncludeIdHook {
    (moduleReference: BaseModuleReference): boolean;
}
export interface GraphDepthOptions {
    static: GraphDepth;
    dynamic: number;
    includeId?: IncludeIdHook;
}
export declare type GraphDepth = 'all' | 'direct' | 'none';
export interface FlatGraphNode {
    specifier: Specifier;
    static: Specifier[];
    dynamicRefs: Specifier[];
}
export interface GraphNode {
    static: Specifier[];
    dynamic: Specifier[];
}
export declare type URIMap = Record<string, string>;
export declare type LinkedModuleDefinitionMap = Record<string, LinkedModuleDefinition | BundleDefinition>;
export interface FlattenedModuleGraphs {
    graphs: FlatGraphNode[];
    uriMap: URIMap;
    linkedDefinitions: LinkedModuleDefinitionMap;
}
export declare type ImportMapImports = {
    [key: string]: string;
};
export interface LwrBuilderOverwriteOptions {
    storeName?: boolean;
    contentOnly?: boolean;
}
export interface LwrStringBuilder {
    append(content: string): LwrStringBuilder;
    appendLeft(index: number, content: string): LwrStringBuilder;
    appendRight(index: number, content: string): LwrStringBuilder;
    clone(): LwrStringBuilder;
    move(start: number, end: number, index: number): LwrStringBuilder;
    overwrite(start: number, end: number, content: string, options?: boolean | LwrBuilderOverwriteOptions): LwrStringBuilder;
    prepend(content: string): LwrStringBuilder;
    prependLeft(index: number, content: string): LwrStringBuilder;
    prependRight(index: number, content: string): LwrStringBuilder;
    remove(start: number, end: number): LwrStringBuilder;
    slice(start: number, end: number): string;
    snip(start: number, end: number): LwrStringBuilder;
    trim(charType?: string): LwrStringBuilder;
    trimStart(charType?: string): LwrStringBuilder;
    trimEnd(charType?: string): LwrStringBuilder;
    trimLines(): LwrStringBuilder;
    lastChar(): string;
    lastLine(): string;
    isEmpty(): boolean;
    length(): number;
    toString(): string;
    original: string;
}
//# sourceMappingURL=index.d.ts.map