/// <reference types="node" />
/// <reference types="node" />
import { Application as ExpressApp } from 'express';
import Koa, { Context } from 'koa';
import http from 'http';
import { Readable } from 'stream';
import { RuntimeContext, RuntimeEnvironment } from './index';
export declare type ServerTypes = 'koa' | 'express' | 'fs';
export declare type ServerTypeImpl<T extends ServerTypes> = T extends 'koa' ? Koa : T extends 'express' ? ExpressApp : T extends 'fs' ? LwrDispatcher : never;
export interface FsContext extends Context {
    fs?: {
        headers?: http.IncomingHttpHeaders;
        body?: any;
        stream?: any;
        metadata?: any;
        type?: string;
    };
}
export interface LwrDispatcher {
    dispatchUrl(url: string, method: string, lang: string): Promise<FsContext>;
}
export interface InternalAppServer<T extends ServerTypes> {
    /**
     * For external consumers only. Internally we should only be interacting with the interface
     * and not the underlying implementation to ensure that we maintain compatibility with each server type.
     */
    getImpl(): ServerTypeImpl<T>;
    getInternalRequestKey(): string;
    createHttpServer(): http.Server;
    use(middleware: MiddlewareFunction): void;
    all(path: string | Array<string>, middleware: MiddlewareFunction): void;
    get(path: string | Array<string>, middleware: MiddlewareFunction): void;
    post(path: string | Array<string>, middleware: MiddlewareFunction): void;
    initRoutes(): void;
    useCompression(): void;
    getRegexWildcard(): string;
}
export declare type PublicAppServer<T extends ServerTypes> = Pick<InternalAppServer<T>, 'use' | 'all' | 'get' | 'post' | 'getRegexWildcard'>;
export declare type InternalAppServerOptions = {
    basePath?: string;
};
export interface InternalAppServerConstructable {
    new (options: InternalAppServerOptions): InternalAppServer<ServerTypes>;
}
export interface MiddlewareFunction {
    (req: MiddlewareRequest, res: MiddlewareResponse, next: Function): void;
}
export declare type Headers = http.IncomingHttpHeaders;
export interface MiddlewareRequest {
    params: any;
    originalUrl: string;
    path: string;
    query: any;
    body: any;
    method: string;
    headers: Headers;
    protocol: string;
    locale: string;
    acceptsLanguages(): string[];
    get(field: string): string | undefined;
    cookie(name: string): string | undefined;
    hasJsonParam(): boolean;
    /**
     * Return JSON if:
     *      - the URI contains the "json" query parameter
     *      - the Accept header explicitly requests "application/json"
     */
    isJsonRequest(): boolean;
    /**
     * Return false when both Accept and JSON query param are applied, but do not semantically match
     */
    validateJsonRequest(): boolean;
    /**
     * Use the Express Request parameters to create a Module/Resource Identifier and RuntimeEnvironment
     */
    getRuntimeContext(defaultRuntimeEnvironment: RuntimeEnvironment): RuntimeContext;
    isSiteGeneration(): boolean;
}
export interface MiddlewareResponse {
    set(header: any): void;
    setHeader(name: string, value: string | string[]): void;
    setMetadata(metadata: any): void;
    status(status: number): MiddlewareResponse;
    send(object: any): void;
    sendStatus(httpCode: number): void;
    stream(stream: Readable): void;
    type(type: string): MiddlewareResponse;
    cookie(name: string, value?: string, options?: any): MiddlewareResponse;
}
//# sourceMappingURL=server.d.ts.map