var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/linkers/view_bootstrap.ts
__markAsModule(exports);
__export(exports, {
  getHtmlResources: () => getHtmlResources
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_utils = __toModule(require("../utils.cjs"));
var import_utils2 = __toModule(require("./utils.cjs"));
async function getHtmlResources(view, viewParams, resourceContext) {
  const {
    runtimeEnvironment,
    runtimeParams,
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    viewMetadata
  } = resourceContext;
  const {id: appName, bootstrap: {services} = {services: []}} = view;
  const {lwrVersion, format, hmrEnabled, bundle, debug, minify} = runtimeEnvironment;
  const {customElements} = viewMetadata;
  const version = lwrVersion;
  const isAMD = format === "amd";
  const appIdentity = {
    appName,
    format: runtimeEnvironment.format,
    resourceType: import_identity.AppResourceEnum.MODULE
  };
  const bootstrapSpecifier = (0, import_identity.getAppSpecifier)(appIdentity);
  const moduleResources = [];
  const requiredResources = [];
  const configResources = [];
  const visitedCache = new Map();
  const imports = {};
  const rootComponents = [];
  const requiredAmdModules = [];
  const preloadAmdModules = [];
  const isSSR = view.bootstrap?.ssr;
  if (isAMD) {
    const shimBundle = !bundle ? "lwr-loader-shim.js" : debug || minify === false ? "lwr-loader-shim.bundle.js" : "lwr-loader-shim.bundle.min.js";
    const def = await resourceRegistry.getResource({specifier: shimBundle, version}, runtimeEnvironment, runtimeParams);
    if (!def) {
      throw Error("Failed to find definition of resource: " + shimBundle);
    }
    requiredResources.push(def);
    const errorShimDef = await resourceRegistry.getResource({specifier: "lwr-error-shim.js", version}, runtimeEnvironment, runtimeParams);
    if (!errorShimDef) {
      throw Error("Failed to find definition of resource: lwr-error-shim.js");
    }
    requiredResources.push(errorShimDef);
    if (!bundle) {
      requiredResources.push(await (0, import_utils.getModuleResource)({
        specifier: "lwr/loader",
        version
      }, runtimeEnvironment, {
        isSSR
      }, moduleRegistry, runtimeParams));
    }
  }
  const depth = isAMD ? {static: import_shared_utils.GraphDepth.ALL, dynamic: 1} : {static: import_shared_utils.GraphDepth.NONE, dynamic: 1};
  const bootstrapModuleGraph = await (0, import_shared_utils.getModuleGraphs)(bootstrapSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams, visitedCache);
  const versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
  const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
  moduleResources.push((0, import_utils.getModuleResourceByUri)(uri, runtimeEnvironment, {isPreload: false, isSSR}));
  if (isAMD) {
    requiredAmdModules.push(versionedSpecifier);
    imports[versionedSpecifier] = uri;
    for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
      const uri2 = bootstrapModuleGraph.uriMap[staticDep];
      imports[staticDep] = uri2;
      if (services && services.length) {
        moduleResources.push((0, import_utils.getModuleResourceByUri)(uri2, runtimeEnvironment, {isPreload: true, isSSR}));
        requiredAmdModules.push(staticDep);
      }
    }
    for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
      const uri2 = bootstrapModuleGraph.uriMap[dynamicDep];
      if (uri2) {
        imports[dynamicDep] = uri2;
      } else {
        import_shared_utils.logger.warn("Skipping unknown dynamic import " + dynamicDep);
      }
    }
  }
  let importMetadata = await (0, import_shared_utils.toImportMetadata)(bootstrapModuleGraph, {imports: {}, index: {}}, moduleRegistry, runtimeEnvironment, runtimeParams);
  const customElementsRecords = [];
  const flattenedElements = (0, import_utils2.flattenCustomElements)(customElements, isSSR);
  await Promise.all(flattenedElements.map(async ({tagName: element, props}) => {
    const graph = await (0, import_shared_utils.getModuleGraphs)((0, import_shared_utils.kebabCaseToModuleSpecifer)(element), {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams ? runtimeParams : {}, visitedCache);
    customElementsRecords.push({elementName: element, flatGraph: graph});
    const specifier = graph.graphs[0].specifier;
    const uri2 = graph.uriMap[specifier];
    moduleResources.push((0, import_utils.getModuleResourceByUri)(uri2, runtimeEnvironment, {isPreload: true, isSSR}));
    rootComponents.push(specifier);
    imports[specifier] = uri2;
    if (isAMD) {
      preloadAmdModules.push(specifier);
      for (const staticDep of graph.graphs[0].static) {
        const uri3 = graph.uriMap[staticDep];
        imports[staticDep] = uri3;
      }
      for (const dynamicDep of graph.graphs[0].dynamicRefs) {
        const uri3 = graph.uriMap[dynamicDep];
        imports[dynamicDep] = uri3;
      }
    }
    importMetadata = await (0, import_shared_utils.toImportMetadata)(graph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
  }));
  configResources.unshift(await (0, import_utils2.getViewBootstrapConfigurationResource)({
    id: view.id,
    url: viewParams?.page?.url,
    configAsSrc: view.bootstrap?.configAsSrc || false
  }, {
    appId: appIdentity.appName,
    bootstrapModule: versionedSpecifier,
    autoBoot: view.bootstrap?.autoBoot === false ? false : true,
    imports: importMetadata?.imports,
    index: importMetadata?.index,
    rootComponents,
    ...isAMD && {requiredModules: requiredAmdModules},
    ...isAMD && {preloadModules: preloadAmdModules}
  }, runtimeEnvironment, runtimeParams));
  if (!isAMD && hmrEnabled) {
    configResources.unshift(await (0, import_utils2.getViewHmrConfigurationResource)(view, viewMetadata));
  }
  const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(import_utils.generateHtmlTag));
  const mapping = (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, runtimeParams);
  const endpoints = {
    uris: {
      mapping
    }
  };
  return {
    partial: htmlResources.join("\n"),
    viewRecord: {
      resources: requiredResources,
      customElements: customElementsRecords,
      endpoints,
      importMetadata,
      bootstrapModule: {
        specifier: bootstrapModuleGraph.graphs[0].specifier,
        flatGraph: bootstrapModuleGraph,
        resources: configResources
      }
    }
  };
}
