var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/utils.ts
__markAsModule(exports);
__export(exports, {
  createJsonModule: () => createJsonModule,
  generateHtmlTag: () => generateHtmlTag,
  generatePageContext: () => generatePageContext,
  getModuleResource: () => getModuleResource,
  getModuleResourceByUri: () => getModuleResourceByUri,
  getRouteHandler: () => getRouteHandler,
  isViewResponse: () => isViewResponse,
  normalizeRenderOptions: () => normalizeRenderOptions,
  normalizeRenderedResult: () => normalizeRenderedResult,
  reduceSourceAssetReferences: () => reduceSourceAssetReferences,
  toJsonFormat: () => toJsonFormat
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_path = __toModule(require("path"));
var import_path2 = __toModule(require("path"));
var import_shared_utils2 = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_shared_utils3 = __toModule(require("@lwrjs/shared-utils"));
function streamToString(stream) {
  const chunks = [];
  return new Promise((resolve, reject) => {
    stream.on("data", (c) => chunks.push(c));
    stream.on("error", reject);
    stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
  });
}
function generateExternalStyle(src) {
  return `<link rel="stylesheet" href="${src}">`;
}
function generateExternalScript(type = "application/javascript", src, async, defer) {
  let scriptLoadOrder = "";
  if (defer) {
    scriptLoadOrder = " defer";
  } else if (async) {
    scriptLoadOrder = " async";
  }
  return `<script type="${type}"${scriptLoadOrder} src="${src}"></script>`;
}
function generateLinkPreloadTag({href, type}) {
  if (type === "module") {
    return `<link rel="modulepreload" href="${href}" />`;
  } else {
    return `<link rel="preload" href="${href}" type="${type}" />`;
  }
}
function generateExternalTag({type, src = "", async, defer, isPreload}) {
  if (isPreload) {
    return generateLinkPreloadTag({href: src, type});
  } else if (type === "text/css") {
    return generateExternalStyle(src);
  } else {
    return generateExternalScript(type, src, async, defer);
  }
}
async function generateInlineTag({specifier, type, content, stream, nonce}) {
  const typeStr = type === "text/css" ? "" : ` type="${type}"`;
  const tag = type === "text/css" ? "style" : "script";
  const nonceStr = nonce ? ` nonce="${nonce}"` : "";
  if (!content && !stream) {
    throw new Error(`Invalid inline Resource Definition: must have either "content" or "stream": "${specifier}"`);
  }
  const code = content ? content : await streamToString(stream);
  return `<${tag}${typeStr}${nonceStr}>${code}</${tag}>`;
}
async function generateHtmlTag(definition) {
  if (definition.inline) {
    return await generateInlineTag(definition);
  } else if (definition.src) {
    return generateExternalTag(definition);
  }
  throw new Error(`Invalid external Resource Definition: missing a "src": "${definition.specifier}"`);
}
function normalizeRenderedResult({
  renderedView,
  metadata,
  options
}) {
  return {
    renderedView,
    metadata: {
      customElements: metadata ? metadata.customElements : [],
      assetReferences: metadata ? metadata.assetReferences : []
    },
    options: {
      skipMetadataCollection: options ? options.skipMetadataCollection : false
    }
  };
}
function reduceSourceAssetReferences(assets) {
  return assets.map(({url, tagName, override}) => {
    return {
      url,
      tagName,
      override
    };
  });
}
function normalizeRenderOptions(runtimeEnvironment, overrideRenderOptions, baseRenderOptions) {
  return {
    skipMetadataCollection: false,
    freezeAssets: runtimeEnvironment.immutableAssets,
    skipCaching: false,
    viewParamCacheKey: null,
    ...baseRenderOptions,
    ...overrideRenderOptions
  };
}
function getTitleFromFilePath(filePath) {
  return filePath ? (0, import_path2.basename)(filePath, (0, import_path2.extname)(filePath)) : import_shared_utils.DEFAULT_TITLE;
}
function generatePageContext({requestPath: url}, {id, contentTemplate, properties}) {
  const title = properties?.title || getTitleFromFilePath(contentTemplate);
  return {id, title, url};
}
function isViewResponse(response) {
  return response.body !== void 0;
}
async function getRouteHandler(path, {cacheDir, rootDir}) {
  try {
    const fullPath = (0, import_shared_utils.resolveFileExtension)(path);
    if (fullPath.endsWith(".ts")) {
      path = await (0, import_shared_utils.transpileTs)(path, {rootDir, cacheDir: import_path.default.join(cacheDir, "routeHandlers")});
    }
    const moduleEntry = await Promise.resolve().then(() => __toModule(require(path)));
    return moduleEntry.default || moduleEntry;
  } catch (err) {
    console.log(err);
    throw new Error(`Unable to get routeHandler: ${path}`);
  }
}
async function toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, moduleRegistry) {
  const {viewRecord} = viewDefinition;
  const {bootstrap, id: appName} = route;
  const workerSpecifiers = bootstrap?.workers || {};
  const workers = {};
  for (const id of Object.keys(workerSpecifiers)) {
    const appIdentity = {
      appName,
      format: runtimeEnvironment.format,
      resourceType: import_identity.AppResourceEnum.MODULE,
      subResource: {
        type: import_identity.ResourceIdentityTypes.WORKER,
        workerId: `${id}`
      }
    };
    const workerBootstrapSpecifier = (0, import_identity.getAppSpecifier)(appIdentity);
    workers[id] = await createJsonModule(workerBootstrapSpecifier, moduleRegistry, runtimeEnvironment, runtimeParams);
  }
  const modules = [];
  const resources = [];
  const bootstrapGraph = viewRecord.bootstrapModule;
  if (bootstrapGraph) {
    [bootstrapGraph.flatGraph.graphs[0].specifier, ...bootstrapGraph.flatGraph.graphs[0].static].map((module2) => {
      modules.push({
        specifier: module2,
        links: {
          self: bootstrapGraph.flatGraph.uriMap[module2]
        }
      });
    });
    resources.push({
      type: "application/javascript",
      src: (0, import_shared_utils3.getClientBootstrapConfigurationUri)({url: viewRequest.url, id: route.id}, runtimeEnvironment, runtimeParams)
    });
  }
  const mappingUrl = (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, runtimeParams);
  const endpoints = {
    uris: {
      mapping: mappingUrl
    },
    ...runtimeEnvironment.debug && {modifiers: {debug: "true"}}
  };
  const preloadModules = viewRecord.customElements?.map((ce) => {
    return {
      specifier: ce.flatGraph.graphs[0].specifier,
      links: {
        self: ce.flatGraph.uriMap[ce.flatGraph.graphs[0].specifier]
      }
    };
  });
  viewRecord.assetReferences?.forEach((asset) => {
    if (asset.override?.uri) {
      const type = (0, import_shared_utils2.mimeLookup)(asset.override?.uri);
      resources.push({type, src: asset.override?.uri});
    }
  });
  const importMetadata = !runtimeEnvironment.featureFlags?.LEGACY_LOADER && viewRecord.importMetadata;
  viewRecord.resources?.forEach((resource) => {
    resources.push({type: resource.type, src: resource.src});
  });
  const body = {
    ...importMetadata,
    modules,
    preloadModules,
    endpoints,
    resources,
    workers
  };
  return {
    body,
    headers: {
      "Content-Type": "application/json"
    }
  };
}
async function getModuleResource(moduleId, runtimeEnvironment, moduleResouceMeta, moduleRegistry, runtimeParams) {
  const {format} = runtimeEnvironment;
  const {isSSR = false, isPreload = false} = moduleResouceMeta;
  const moduleUri = await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
  return {
    src: moduleUri,
    type: format === "amd" ? "application/javascript" : "module",
    async: !isSSR && isPreload,
    defer: isSSR,
    isPreload: format !== "amd" && isPreload
  };
}
function getModuleResourceByUri(uri, runtimeEnvironment, moduleResouceMeta) {
  const {isSSR = false, isPreload = false} = moduleResouceMeta;
  const {format} = runtimeEnvironment;
  return {
    src: uri,
    type: format === "amd" ? "application/javascript" : "module",
    async: !isSSR && isPreload,
    defer: isSSR,
    isPreload: format !== "amd" && isPreload
  };
}
async function createJsonModule(specifier, moduleRegistry, environment, params) {
  const {version} = await moduleRegistry.getModuleEntry({specifier});
  const {namespace, name} = (0, import_shared_utils.explodeSpecifier)(specifier);
  const moduleIdentifier = {
    specifier,
    namespace,
    name,
    version
  };
  const {ownHash} = await moduleRegistry.getModule(moduleIdentifier);
  return {
    specifier: (0, import_shared_utils.getSpecifier)(moduleIdentifier),
    version,
    ownHash,
    links: {
      self: moduleRegistry.resolveModuleUri(moduleIdentifier, environment, params, ownHash)
    }
  };
}
