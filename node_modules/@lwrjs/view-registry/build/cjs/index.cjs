var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrViewHandler: () => import_view_handler.LwrViewHandler,
  LwrViewRegistry: () => LwrViewRegistry
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var import_link_lwr_resources = __toModule(require("./linkers/link-lwr-resources.cjs"));
var import_view_handler = __toModule(require("./view-handler.cjs"));
var LwrViewRegistry = class {
  constructor(context, globalConfig) {
    this.viewProviders = [];
    this.compiledViews = new Map();
    this.viewDefinitions = new Map();
    this.immutableAssets = new Map();
    this.pendingViewDefinitions = new import_shared_utils.InflightTasks();
    this.name = "lwr-view-registry";
    this.resourceRegistry = context.resourceRegistry;
    this.runtimeEnvironment = context.runtimeEnvironment;
    this.moduleRegistry = context.moduleRegistry;
    this.moduleBundler = context.moduleBundler;
    this.assetRegistry = context.assetRegistry;
    this.viewTransformers = context.viewTransformers || [];
    this.globalConfig = globalConfig;
    this.globalData = context.globalData;
    this.appEmitter = context.appEmitter;
    const observer = context.appObserver;
    observer.onViewSourceChange(({payload}) => this.onViewSourceChange(payload));
    observer.onModuleDefinitionChange(({payload}) => this.onModuleDefinitionChange(payload));
    observer.onAssetSourceChange(({payload}) => this.onAssetSourceChange(payload));
  }
  async onModuleDefinitionChange(moduleDefinition) {
    const versionedSpecifier = (0, import_shared_utils.getSpecifier)(moduleDefinition);
    for (const [id, {viewDefinition}] of this.viewDefinitions.entries()) {
      const {viewRecord} = viewDefinition;
      const uriMap = viewRecord.bootstrapModule?.flatGraph.uriMap;
      if (uriMap) {
        Object.keys(uriMap);
      }
      const someBootstrapDeps = viewRecord.bootstrapModule?.specifier === versionedSpecifier || Object.keys(viewRecord.bootstrapModule?.flatGraph.uriMap || []).includes(versionedSpecifier);
      const someCustomElementsDeps = viewRecord.customElements?.some((element) => {
        return element.flatGraph.graphs[0].specifier === versionedSpecifier || Object.keys(element.flatGraph.uriMap || []).includes(versionedSpecifier);
      });
      if (someBootstrapDeps || someCustomElementsDeps) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  async onViewSourceChange(compiledView) {
    const {contentTemplate, rootComponent} = compiledView.viewId;
    const compiledViewCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({contentTemplate, rootComponent});
    this.compiledViews.set(compiledViewCacheKey, compiledView);
    for (const [id, {view}] of this.viewDefinitions.entries()) {
      const {
        contentTemplate: eContentTempl,
        layoutTemplate: eLayoutTemplate,
        rootComponent: eRootComponent
      } = view;
      if (eContentTempl === contentTemplate || eLayoutTemplate === contentTemplate || eRootComponent === rootComponent) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  onAssetSourceChange(asset) {
    const assetId = asset.entry;
    for (const [id, {viewDefinition}] of this.viewDefinitions.entries()) {
      const {viewRecord} = viewDefinition;
      const someAssets = viewRecord.assetReferences?.some((ref) => {
        return ref.override?.entry === assetId;
      });
      if (someAssets) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  getPublicApi() {
    return {
      getViewDefinition: this.getViewDefinition.bind(this),
      getView: this.getView.bind(this)
    };
  }
  addViewProviders(providers) {
    this.viewProviders.push(...providers);
  }
  addViewTransformers(transformers) {
    this.viewTransformers.push(...transformers);
  }
  initializeViewProviders() {
    return Promise.all(this.viewProviders.map((vp) => vp.initialize()));
  }
  async delegateGetView(viewId) {
    for (const vp of this.viewProviders) {
      const result = await vp.getView(viewId);
      if (result) {
        return result;
      }
    }
    throw new Error(`No View provider was able to resolve a view for template: ${viewId.contentTemplate}`);
  }
  async getView(viewId, skipCaching = false) {
    const {contentTemplate, rootComponent} = viewId;
    const compiledViewCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({contentTemplate, rootComponent});
    if (!skipCaching && this.compiledViews.has(compiledViewCacheKey)) {
      return this.compiledViews.get(compiledViewCacheKey);
    }
    const compiledView = await this.delegateGetView(viewId);
    if (!skipCaching) {
      this.compiledViews.set(compiledViewCacheKey, compiledView);
    }
    return compiledView;
  }
  hasViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
    const {id, bootstrap, rootComponent, contentTemplate, layoutTemplate} = view;
    const {freezeAssets, viewParamCacheKey} = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderOptions);
    const viewDefId = (0, import_shared_utils.getCacheKeyFromJson)({
      id,
      bootstrap,
      rootComponent,
      contentTemplate,
      layoutTemplate,
      freezeAssets,
      locale: runtimeParams?.locale,
      debug: runtimeEnvironment.debug
    });
    const viewParamKey = viewParamCacheKey ? (0, import_shared_utils.getCacheKeyFromJson)(viewParamCacheKey) : (0, import_shared_utils.getCacheKeyFromJson)(viewParams);
    if (this.viewDefinitions.has(viewDefId)) {
      const viewDef = this.viewDefinitions.get(viewDefId);
      if (viewDef && viewDef.paramKey === viewParamKey) {
        return true;
      }
    }
    return false;
  }
  async getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
    const {skipCaching, freezeAssets, viewParamCacheKey} = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderOptions);
    const viewDefCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({
      ...view,
      freezeAssets,
      locale: runtimeParams?.locale,
      debug: runtimeEnvironment.debug
    });
    const viewParamKey = viewParamCacheKey ? (0, import_shared_utils.getCacheKeyFromJson)(viewParamCacheKey) : (0, import_shared_utils.getCacheKeyFromJson)(viewParams);
    const cacheDisabled = process.env.NOCACHE === "true" || skipCaching;
    if (cacheDisabled === false && this.viewDefinitions.has(viewDefCacheKey)) {
      const viewDefinition2 = this.viewDefinitions.get(viewDefCacheKey);
      if (viewDefinition2 && viewDefinition2.paramKey === viewParamKey && viewDefinition2.viewDefinition.immutable) {
        return viewDefinition2.viewDefinition;
      }
    }
    const pendingViewDefCacheKey = viewDefCacheKey + viewParamKey;
    const viewDefinition = await this.pendingViewDefinitions.execute(pendingViewDefCacheKey, () => this.renderView(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions));
    if (cacheDisabled === false) {
      this.viewDefinitions.set(viewDefCacheKey, {
        view,
        viewDefinition,
        paramKey: viewParamKey
      });
    }
    return viewDefinition;
  }
  async renderView(view, viewParams, runtimeEnvironment, runtimeParams = {}, renderOptions) {
    const {contentTemplate, rootComponent, layoutTemplate} = view;
    const lwrResourcesId = `__LWR_RESOURCES__${Date.now()}`;
    const renderedContent = await this.render({contentTemplate, rootComponent}, {...viewParams, lwr_resources: lwrResourcesId}, renderOptions);
    let normalizedRenderOptions = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderedContent.options, renderOptions);
    const layout = layoutTemplate || renderedContent.compiledView.layoutTemplate;
    if (!layout) {
      const renderedViewDef2 = await this.link(renderedContent, {
        view,
        viewParams,
        runtimeEnvironment,
        runtimeParams,
        renderOptions: normalizedRenderOptions,
        contentIds: {lwrResourcesId}
      });
      return renderedViewDef2;
    }
    const layoutTemplatePath = (0, import_shared_utils.normalizeResourcePath)(layout, this.globalConfig);
    const renderedLayout = await this.render({contentTemplate: layoutTemplatePath}, {
      ...renderedContent.compiledView.properties,
      ...viewParams,
      body: renderedContent.renderedView,
      lwr_resources: lwrResourcesId
    });
    normalizedRenderOptions = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderedLayout.options, normalizedRenderOptions);
    const renderedViewDef = await this.link({
      ...renderedLayout,
      compiledView: {
        ...renderedLayout.compiledView,
        immutable: renderedContent.compiledView.immutable && renderedLayout.compiledView.immutable
      },
      metadata: {
        customElements: [
          ...renderedContent.metadata.customElements,
          ...renderedLayout.metadata.customElements
        ],
        assetReferences: [
          ...renderedContent.metadata.assetReferences,
          ...renderedLayout.metadata.assetReferences
        ]
      }
    }, {
      view: {...view, layoutTemplate: layoutTemplatePath},
      viewParams,
      runtimeEnvironment,
      runtimeParams,
      renderOptions: normalizedRenderOptions,
      contentIds: {lwrResourcesId},
      importer: renderedContent.compiledView.filePath
    });
    return renderedViewDef;
  }
  async render(viewId, viewParams, renderOptions) {
    const globalContext = this.globalData;
    const {rootComponent, contentTemplate} = viewId;
    const compiledView = await this.getView({
      contentTemplate,
      rootComponent
    }, renderOptions?.skipCaching);
    const result = await compiledView.render({
      ...globalContext,
      ...compiledView.properties,
      ...viewParams
    });
    const normalizedResult = (0, import_utils.normalizeRenderedResult)(result);
    return {
      compiledView,
      ...normalizedResult
    };
  }
  async link(renderedView, viewContext) {
    const {
      view,
      viewParams,
      runtimeEnvironment: runtimeEnv,
      runtimeParams,
      renderOptions,
      contentIds,
      importer
    } = viewContext;
    const {skipMetadataCollection, freezeAssets} = renderOptions;
    const {lwrResourcesId} = contentIds;
    const {moduleRegistry, resourceRegistry, moduleBundler} = this;
    const runtimeEnvironment = {...runtimeEnv, immutableAssets: freezeAssets};
    const {
      renderedView: renderedViewContent,
      metadata: renderedViewMetadata,
      compiledView: {immutable = true}
    } = renderedView;
    const linkedMetadata = skipMetadataCollection ? renderedViewMetadata : await (0, import_shared_utils.extractMetadataFromHtml)(renderedViewContent);
    const mergedViewContext = {
      ...viewContext,
      runtimeEnvironment,
      importer: importer || renderedView.compiledView.filePath
    };
    const stringBuilder = (0, import_shared_utils.createStringBuilder)(renderedViewContent);
    for (const viewTransformer of this.viewTransformers) {
      await viewTransformer.link?.(stringBuilder, mergedViewContext, linkedMetadata);
    }
    const linkedAssetContent = stringBuilder.toString();
    if (linkedAssetContent.includes(lwrResourcesId)) {
      const {renderedView: linkedView, viewRecord} = await (0, import_link_lwr_resources.linkLwrResources)(linkedAssetContent, view, viewParams, {
        lwrResourcesId,
        viewMetadata: linkedMetadata,
        moduleRegistry,
        moduleBundler,
        resourceRegistry,
        runtimeEnvironment,
        runtimeParams
      });
      return {
        renderedView: linkedView,
        immutable,
        viewRecord: {
          assetReferences: (0, import_utils.reduceSourceAssetReferences)(linkedMetadata.assetReferences),
          ...viewRecord
        }
      };
    }
    return {
      renderedView: linkedAssetContent,
      immutable,
      viewRecord: {
        assetReferences: (0, import_utils.reduceSourceAssetReferences)(linkedMetadata.assetReferences)
      }
    };
  }
};
