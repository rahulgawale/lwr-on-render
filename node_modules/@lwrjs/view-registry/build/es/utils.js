import { explodeSpecifier, getMappingUriPrefix, getSpecifier, resolveFileExtension, transpileTs, DEFAULT_TITLE, } from '@lwrjs/shared-utils';
import libPath from 'path';
import { basename, extname } from 'path';
import { mimeLookup } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier, ResourceIdentityTypes, } from '@lwrjs/app-service/identity';
import { getClientBootstrapConfigurationUri } from '@lwrjs/shared-utils';
function streamToString(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('data', (c) => chunks.push(c));
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    });
}
function generateExternalStyle(src) {
    return `<link rel="stylesheet" href="${src}">`;
}
function generateExternalScript(type = 'application/javascript', src, async, defer) {
    let scriptLoadOrder = '';
    if (defer) {
        scriptLoadOrder = ' defer';
    }
    else if (async) {
        scriptLoadOrder = ' async';
    }
    return `<script type="${type}"${scriptLoadOrder} src="${src}"></script>`;
}
function generateLinkPreloadTag({ href, type }) {
    if (type === 'module') {
        return `<link rel="modulepreload" href="${href}" />`;
    }
    else {
        return `<link rel="preload" href="${href}" type="${type}" />`;
    }
}
function generateExternalTag({ type, src = '', async, defer, isPreload }) {
    if (isPreload) {
        return generateLinkPreloadTag({ href: src, type: type });
    }
    else if (type === 'text/css') {
        return generateExternalStyle(src);
    }
    else {
        return generateExternalScript(type, src, async, defer);
    }
}
async function generateInlineTag({ specifier, type, content, stream, nonce }) {
    const typeStr = type === 'text/css' ? '' : ` type="${type}"`;
    const tag = type === 'text/css' ? 'style' : 'script';
    const nonceStr = nonce ? ` nonce="${nonce}"` : '';
    if (!content && !stream) {
        throw new Error(`Invalid inline Resource Definition: must have either "content" or "stream": "${specifier}"`);
    }
    const code = content ? content : await streamToString(stream);
    return `<${tag}${typeStr}${nonceStr}>${code}</${tag}>`;
}
export async function generateHtmlTag(definition) {
    if (definition.inline) {
        return await generateInlineTag(definition);
    }
    else if (definition.src) {
        return generateExternalTag(definition);
    }
    throw new Error(`Invalid external Resource Definition: missing a "src": "${definition.specifier}"`);
}
export function normalizeRenderedResult({ renderedView, metadata, options, }) {
    return {
        renderedView,
        metadata: {
            customElements: metadata ? metadata.customElements : [],
            assetReferences: metadata ? metadata.assetReferences : [],
        },
        options: {
            skipMetadataCollection: options ? options.skipMetadataCollection : false,
        },
    };
}
export function reduceSourceAssetReferences(assets) {
    return assets.map(({ url, tagName, override }) => {
        return {
            url,
            tagName,
            override,
        };
    });
}
export function normalizeRenderOptions(runtimeEnvironment, overrideRenderOptions, baseRenderOptions) {
    return {
        // Default render options
        skipMetadataCollection: false,
        freezeAssets: runtimeEnvironment.immutableAssets,
        skipCaching: false,
        viewParamCacheKey: null,
        ...baseRenderOptions,
        ...overrideRenderOptions,
    };
}
function getTitleFromFilePath(filePath) {
    return filePath ? basename(filePath, extname(filePath)) : DEFAULT_TITLE;
}
export function generatePageContext({ requestPath: url }, { id, contentTemplate, properties }) {
    // title is set to the first defined value of the following:
    //      - properties.title from the route (or viewParams.title from the route handler)
    //      - filename from route.contentTemplate
    //      - DEFAULT_TITLE
    const title = properties?.title || getTitleFromFilePath(contentTemplate);
    return { id, title, url };
}
// type guard for ViewDef responses
export function isViewResponse(response) {
    return response.body !== undefined;
}
/**
 * Load and cache a route handler function (for a view) from the fs
 * @param path - path to the route handle code on the fs
 * @param param1 - directories
 */
export async function getRouteHandler(path, { cacheDir, rootDir }) {
    try {
        const fullPath = resolveFileExtension(path);
        if (fullPath.endsWith('.ts')) {
            path = await transpileTs(path, { rootDir, cacheDir: libPath.join(cacheDir, 'routeHandlers') });
        }
        const moduleEntry = await import(path);
        return moduleEntry.default || moduleEntry;
    }
    catch (err) {
        console.log(err);
        throw new Error(`Unable to get routeHandler: ${path}`);
    }
}
export async function toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, moduleRegistry) {
    const { viewRecord } = viewDefinition;
    const { bootstrap, id: appName } = route;
    const workerSpecifiers = bootstrap?.workers || {};
    // coalesce workers from route configuration
    const workers = {};
    for (const id of Object.keys(workerSpecifiers)) {
        const appIdentity = {
            appName,
            format: runtimeEnvironment.format,
            resourceType: AppResourceEnum.MODULE,
            subResource: {
                type: ResourceIdentityTypes.WORKER,
                workerId: `${id}`,
            },
        };
        const workerBootstrapSpecifier = getAppSpecifier(appIdentity);
        // eslint-disable-next-line no-await-in-loop
        workers[id] = await createJsonModule(workerBootstrapSpecifier, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
    // ADD bootstrap module and dependencies to modules property
    const modules = [];
    const resources = [];
    const bootstrapGraph = viewRecord.bootstrapModule;
    if (bootstrapGraph) {
        [bootstrapGraph.flatGraph.graphs[0].specifier, ...bootstrapGraph.flatGraph.graphs[0].static].map((module) => {
            modules.push({
                // versioned specifier
                specifier: module,
                links: {
                    self: bootstrapGraph.flatGraph.uriMap[module],
                },
            });
        });
        // If bootstrapGraph exists exposes its resources via configuration URL
        resources.push({
            type: 'application/javascript',
            src: getClientBootstrapConfigurationUri({ url: viewRequest.url, id: route.id }, runtimeEnvironment, runtimeParams),
        });
    }
    const mappingUrl = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping: mappingUrl,
        },
        ...(runtimeEnvironment.debug && { modifiers: { debug: 'true' } }),
    };
    // ADD customElements as pre-loadable module entry points
    const preloadModules = viewRecord.customElements?.map((ce) => {
        return {
            // versioned specifier
            specifier: ce.flatGraph.graphs[0].specifier,
            links: {
                self: ce.flatGraph.uriMap[ce.flatGraph.graphs[0].specifier],
            },
        };
    });
    // ADD assetReferences to the JSON resources
    viewRecord.assetReferences?.forEach((asset) => {
        if (asset.override?.uri) {
            const type = mimeLookup(asset.override?.uri);
            resources.push({ type, src: asset.override?.uri });
        }
    });
    // Import Metadata
    const importMetadata = !runtimeEnvironment.featureFlags?.LEGACY_LOADER && viewRecord.importMetadata;
    viewRecord.resources?.forEach((resource) => {
        resources.push({ type: resource.type, src: resource.src });
    });
    const body = {
        ...importMetadata,
        modules,
        preloadModules,
        endpoints,
        resources,
        workers,
    };
    return {
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    };
}
export async function getModuleResource(moduleId, runtimeEnvironment, moduleResouceMeta, moduleRegistry, runtimeParams) {
    const { format } = runtimeEnvironment;
    const { isSSR = false, isPreload = false } = moduleResouceMeta;
    const moduleUri = await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
    return {
        src: moduleUri,
        type: format === 'amd' ? 'application/javascript' : 'module',
        async: !isSSR && isPreload,
        defer: isSSR,
        // only use link preload for ESM for compat reasons.
        // AMD should use regular script tags for preloading
        isPreload: format !== 'amd' && isPreload,
    };
}
export function getModuleResourceByUri(uri, runtimeEnvironment, moduleResouceMeta) {
    const { isSSR = false, isPreload = false } = moduleResouceMeta;
    const { format } = runtimeEnvironment;
    return {
        src: uri,
        type: format === 'amd' ? 'application/javascript' : 'module',
        async: !isSSR && isPreload,
        defer: isSSR,
        // only use link preload for ESM for compat reasons.
        // AMD should use regular script tags for preloading
        isPreload: format !== 'amd' && isPreload,
    };
}
// Given a specifier and resource type, return the JSON serialized Module data
export async function createJsonModule(specifier, moduleRegistry, environment, params) {
    const { version } = await moduleRegistry.getModuleEntry({ specifier });
    const { namespace, name } = explodeSpecifier(specifier);
    const moduleIdentifier = {
        specifier,
        namespace,
        name,
        version,
    };
    const { ownHash } = await moduleRegistry.getModule(moduleIdentifier);
    return {
        // versioned specifier
        specifier: getSpecifier(moduleIdentifier),
        version,
        ownHash,
        links: {
            self: moduleRegistry.resolveModuleUri(moduleIdentifier, environment, params, ownHash),
        },
    };
}
//# sourceMappingURL=utils.js.map