import { extractMetadataFromHtml, getCacheKeyFromJson, getSpecifier, normalizeResourcePath, createStringBuilder, InflightTasks, } from '@lwrjs/shared-utils';
import { normalizeRenderOptions, normalizeRenderedResult, reduceSourceAssetReferences } from './utils.js';
import { linkLwrResources } from './linkers/link-lwr-resources.js';
export { LwrViewHandler } from './view-handler.js';
export class LwrViewRegistry {
    constructor(context, globalConfig) {
        this.viewProviders = [];
        // Cache of compiled views retrieved from the viewProviders
        //  Cache key: ViewIdentity
        this.compiledViews = new Map();
        // Cache of linked view definitions, keyed by the View
        //  Cache key: View
        this.viewDefinitions = new Map();
        this.immutableAssets = new Map();
        // Cache of unresolved view definitions
        //  Cache key: View + View Params
        //
        // Pending view definitions are tracked to prevent concurrent resolution of the same view.
        // Subsequent requests for the same view will await the original promise.
        this.pendingViewDefinitions = new InflightTasks();
        this.name = 'lwr-view-registry';
        this.resourceRegistry = context.resourceRegistry;
        this.runtimeEnvironment = context.runtimeEnvironment;
        this.moduleRegistry = context.moduleRegistry;
        this.moduleBundler = context.moduleBundler;
        this.assetRegistry = context.assetRegistry;
        this.viewTransformers = context.viewTransformers || [];
        this.globalConfig = globalConfig;
        this.globalData = context.globalData;
        this.appEmitter = context.appEmitter;
        const observer = context.appObserver;
        // Observers for cached entries external dependencies -- view templates, modules, and assets
        observer.onViewSourceChange(({ payload }) => this.onViewSourceChange(payload));
        observer.onModuleDefinitionChange(({ payload }) => this.onModuleDefinitionChange(payload));
        observer.onAssetSourceChange(({ payload }) => this.onAssetSourceChange(payload));
    }
    async onModuleDefinitionChange(moduleDefinition) {
        const versionedSpecifier = getSpecifier(moduleDefinition);
        // invalidate viewDefinition cache entries with references to the LinkedModuleDefinition
        for (const [id, { viewDefinition }] of this.viewDefinitions.entries()) {
            const { viewRecord } = viewDefinition;
            const uriMap = viewRecord.bootstrapModule?.flatGraph.uriMap;
            if (uriMap) {
                Object.keys(uriMap);
            }
            const someBootstrapDeps = viewRecord.bootstrapModule?.specifier === versionedSpecifier ||
                Object.keys(viewRecord.bootstrapModule?.flatGraph.uriMap || []).includes(versionedSpecifier);
            const someCustomElementsDeps = viewRecord.customElements?.some((element) => {
                return (element.flatGraph.graphs[0].specifier === versionedSpecifier ||
                    Object.keys(element.flatGraph.uriMap || []).includes(versionedSpecifier));
            });
            // Delete the viewDefinition if it contains a reference to the updated module definition
            if (someBootstrapDeps || someCustomElementsDeps) {
                this.viewDefinitions.delete(id);
            }
        }
    }
    async onViewSourceChange(compiledView) {
        // invalidate compiledViews and viewDefinition cache entries with references to the CompiledView template id.
        const { contentTemplate, rootComponent } = compiledView.viewId;
        const compiledViewCacheKey = getCacheKeyFromJson({ contentTemplate, rootComponent });
        this.compiledViews.set(compiledViewCacheKey, compiledView);
        // invalidate viewDefinitions cache
        for (const [id, { view }] of this.viewDefinitions.entries()) {
            const { contentTemplate: eContentTempl, layoutTemplate: eLayoutTemplate, rootComponent: eRootComponent, } = view;
            if (eContentTempl === contentTemplate ||
                eLayoutTemplate === contentTemplate ||
                eRootComponent === rootComponent) {
                // invalidate matched entry.
                this.viewDefinitions.delete(id);
            }
        }
    }
    onAssetSourceChange(asset) {
        // invalidate viewDefinition cache entries with references to the AssetSource entry.
        const assetId = asset.entry;
        for (const [id, { viewDefinition }] of this.viewDefinitions.entries()) {
            const { viewRecord } = viewDefinition;
            const someAssets = viewRecord.assetReferences?.some((ref) => {
                return ref.override?.entry === assetId;
            });
            if (someAssets) {
                this.viewDefinitions.delete(id);
            }
        }
    }
    getPublicApi() {
        return {
            getViewDefinition: this.getViewDefinition.bind(this),
            getView: this.getView.bind(this),
        };
    }
    // -- Public API --------------------------------------------------------------------
    // Add new view providers
    addViewProviders(providers) {
        this.viewProviders.push(...providers);
    }
    addViewTransformers(transformers) {
        this.viewTransformers.push(...transformers);
    }
    initializeViewProviders() {
        return Promise.all(this.viewProviders.map((vp) => vp.initialize()));
    }
    async delegateGetView(viewId) {
        for (const vp of this.viewProviders) {
            // eslint-disable-next-line no-await-in-loop
            const result = await vp.getView(viewId);
            if (result) {
                return result;
            }
        }
        throw new Error(`No View provider was able to resolve a view for template: ${viewId.contentTemplate}`);
    }
    async getView(viewId, skipCaching = false) {
        const { contentTemplate, rootComponent } = viewId;
        const compiledViewCacheKey = getCacheKeyFromJson({ contentTemplate, rootComponent });
        // use cached compiledView if available
        if (!skipCaching && this.compiledViews.has(compiledViewCacheKey)) {
            return this.compiledViews.get(compiledViewCacheKey);
        }
        const compiledView = await this.delegateGetView(viewId);
        // cache the compiled view
        if (!skipCaching) {
            this.compiledViews.set(compiledViewCacheKey, compiledView);
        }
        return compiledView;
    }
    hasViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
        const { id, bootstrap, rootComponent, contentTemplate, layoutTemplate } = view;
        const { freezeAssets, viewParamCacheKey } = normalizeRenderOptions(this.runtimeEnvironment, renderOptions);
        const viewDefId = getCacheKeyFromJson({
            id,
            bootstrap,
            rootComponent,
            contentTemplate,
            layoutTemplate,
            freezeAssets,
            locale: runtimeParams?.locale,
            debug: runtimeEnvironment.debug,
        });
        // viewParams is an unbounded object and can be very large (17MB/view for developer.salesforce.com). Allowing conusmers
        // to provide a simple override avoids the excess memory / performance overhead of serializing & storing the viewParams
        // on every request, while still reusing our caching logic.
        const viewParamKey = viewParamCacheKey
            ? getCacheKeyFromJson(viewParamCacheKey)
            : getCacheKeyFromJson(viewParams);
        // important: cache key does not include the unbounded viewParams
        if (this.viewDefinitions.has(viewDefId)) {
            const viewDef = this.viewDefinitions.get(viewDefId);
            if (viewDef && viewDef.paramKey === viewParamKey) {
                return true;
            }
        }
        return false;
    }
    async getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
        const { skipCaching, freezeAssets, viewParamCacheKey } = normalizeRenderOptions(this.runtimeEnvironment, renderOptions);
        const viewDefCacheKey = getCacheKeyFromJson({
            ...view,
            freezeAssets,
            locale: runtimeParams?.locale,
            debug: runtimeEnvironment.debug,
        });
        // viewParams is an unbounded object and can be very large (17MB/view for developer.salesforce.com). Allowing consumers
        // to provide a simple override avoids the excess memory / performance overhead of serializing & storing the viewParams
        // on every request, while still reusing our caching logic.
        const viewParamKey = viewParamCacheKey
            ? getCacheKeyFromJson(viewParamCacheKey)
            : getCacheKeyFromJson(viewParams);
        const cacheDisabled = process.env.NOCACHE === 'true' || skipCaching;
        // important: cache key does not include the unbounded viewParams
        if (cacheDisabled === false && this.viewDefinitions.has(viewDefCacheKey)) {
            const viewDefinition = this.viewDefinitions.get(viewDefCacheKey);
            if (viewDefinition &&
                viewDefinition.paramKey === viewParamKey &&
                viewDefinition.viewDefinition.immutable) {
                return viewDefinition.viewDefinition;
            }
        }
        const pendingViewDefCacheKey = viewDefCacheKey + viewParamKey;
        const viewDefinition = await this.pendingViewDefinitions.execute(pendingViewDefCacheKey, () => this.renderView(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions));
        if (cacheDisabled === false) {
            this.viewDefinitions.set(viewDefCacheKey, {
                view,
                viewDefinition,
                paramKey: viewParamKey,
            });
        }
        return viewDefinition;
    }
    async renderView(view, viewParams, runtimeEnvironment, runtimeParams = {}, renderOptions) {
        const { contentTemplate, rootComponent, layoutTemplate } = view;
        const lwrResourcesId = `__LWR_RESOURCES__${Date.now()}`;
        const renderedContent = await this.render({ contentTemplate, rootComponent }, { ...viewParams, lwr_resources: lwrResourcesId }, renderOptions);
        // normalize the renderOptions provided by the CompiledView content with the request options.
        let normalizedRenderOptions = normalizeRenderOptions(this.runtimeEnvironment, renderedContent.options, renderOptions);
        const layout = layoutTemplate || renderedContent.compiledView.layoutTemplate;
        if (!layout) {
            // Content only view
            const renderedViewDef = await this.link(renderedContent, {
                view,
                viewParams,
                runtimeEnvironment,
                runtimeParams,
                // using any options provided by the content, overridden with invocation provided rendering options
                renderOptions: normalizedRenderOptions,
                contentIds: { lwrResourcesId },
            });
            return renderedViewDef;
        }
        // Layout wrapped content: pass in the view provider properties and body from the rendered content
        const layoutTemplatePath = normalizeResourcePath(layout, this.globalConfig);
        const renderedLayout = await this.render({ contentTemplate: layoutTemplatePath }, {
            ...renderedContent.compiledView.properties,
            ...viewParams,
            body: renderedContent.renderedView,
            lwr_resources: lwrResourcesId,
        });
        normalizedRenderOptions = normalizeRenderOptions(this.runtimeEnvironment, renderedLayout.options, normalizedRenderOptions);
        const renderedViewDef = await this.link({
            ...renderedLayout,
            // Rendered Layout view's immutability is a composite of the layouts mutability and the body's mutability
            compiledView: {
                ...renderedLayout.compiledView,
                immutable: renderedContent.compiledView.immutable && renderedLayout.compiledView.immutable,
            },
            // Rendered layouts known metadata is a composition of the layouts and body content's known metadata.
            metadata: {
                customElements: [
                    ...renderedContent.metadata.customElements,
                    ...renderedLayout.metadata.customElements,
                ],
                assetReferences: [
                    ...renderedContent.metadata.assetReferences,
                    ...renderedLayout.metadata.assetReferences,
                ],
            },
        }, 
        // Render Content now contains a layout
        {
            view: { ...view, layoutTemplate: layoutTemplatePath },
            viewParams,
            runtimeEnvironment,
            runtimeParams,
            renderOptions: normalizedRenderOptions,
            contentIds: { lwrResourcesId },
            // TODO: We override the importer with the original view, however
            // Layouts relative paths won't work
            importer: renderedContent.compiledView.filePath,
        });
        return renderedViewDef;
    }
    async render(viewId, viewParams, renderOptions) {
        const globalContext = this.globalData;
        const { rootComponent, contentTemplate } = viewId;
        const compiledView = await this.getView({
            contentTemplate,
            rootComponent,
        }, renderOptions?.skipCaching);
        // Get content/body of the view
        /*
            When rendering the compiled view, a collection variable properties can be passed to the render() to be rendered in
            the view's content.  The following are the sources of those properties:
            * GlobalContext is global data provided by the project in the ${globalDataDir}
            * A View Provider MAY expose a set of properties that should be applied to all rendered content generated by the CompiledView renderer()
            * A caller can also pass a set of property parameters derived from the request or out-of-band sources.

            These are merged together in to a combined context used by render()
        */
        const result = await compiledView.render({
            ...globalContext,
            ...compiledView.properties,
            ...viewParams,
        });
        const normalizedResult = normalizeRenderedResult(result);
        return {
            compiledView,
            ...normalizedResult,
        };
    }
    async link(renderedView, viewContext) {
        const { view, viewParams, runtimeEnvironment: runtimeEnv, runtimeParams, renderOptions, contentIds, importer, } = viewContext;
        const { skipMetadataCollection, freezeAssets } = renderOptions;
        const { lwrResourcesId } = contentIds;
        const { moduleRegistry, resourceRegistry, moduleBundler } = this;
        const runtimeEnvironment = { ...runtimeEnv, immutableAssets: freezeAssets };
        // normalize/extract metadata
        const { renderedView: renderedViewContent, metadata: renderedViewMetadata, compiledView: { immutable = true }, } = renderedView;
        const linkedMetadata = skipMetadataCollection
            ? renderedViewMetadata
            : await extractMetadataFromHtml(renderedViewContent);
        const mergedViewContext = {
            ...viewContext,
            runtimeEnvironment,
            importer: importer || renderedView.compiledView.filePath,
        };
        const stringBuilder = createStringBuilder(renderedViewContent);
        for (const viewTransformer of this.viewTransformers) {
            // eslint-disable-next-line no-await-in-loop
            await viewTransformer.link?.(stringBuilder, mergedViewContext, linkedMetadata);
        }
        const linkedAssetContent = stringBuilder.toString();
        // Link LWR related resources
        if (linkedAssetContent.includes(lwrResourcesId)) {
            // This calculation is expensive, only do it if lwr_resources is needed
            // Link LWR View resources if necessary
            const { renderedView: linkedView, viewRecord } = await linkLwrResources(linkedAssetContent, view, viewParams, {
                lwrResourcesId,
                viewMetadata: linkedMetadata,
                moduleRegistry,
                moduleBundler,
                resourceRegistry,
                runtimeEnvironment,
                runtimeParams,
            });
            return {
                // ...viewDefinition,
                renderedView: linkedView,
                immutable,
                viewRecord: {
                    assetReferences: reduceSourceAssetReferences(linkedMetadata.assetReferences),
                    ...viewRecord,
                },
            };
        }
        return {
            renderedView: linkedAssetContent,
            immutable,
            viewRecord: {
                assetReferences: reduceSourceAssetReferences(linkedMetadata.assetReferences),
            },
        };
    }
}
//# sourceMappingURL=index.js.map