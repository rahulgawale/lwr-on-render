import { kebabCaseToModuleSpecifer, getModuleGraphs, GraphDepth, getModuleUriPrefix, logger, } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier } from '@lwrjs/app-service/identity';
import { generateHtmlTag, getModuleResource, getModuleResourceByUri } from '../utils.js';
import { flattenCustomElements, getViewBootstrapConfigurationResource, getViewHmrConfigurationResource, } from './utils.js';
export async function getHtmlResources(view, viewParams, resourceContext) {
    const { runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler, resourceRegistry, viewMetadata, } = resourceContext;
    const { id: appName, bootstrap: { services } = { services: [] } } = view;
    const { lwrVersion, format, hmrEnabled, bundle, debug, minify } = runtimeEnvironment;
    const { customElements } = viewMetadata;
    const version = lwrVersion;
    const isAMD = format === 'amd';
    // Application Bootstrap (ABS) module resource: "@lwrjs/app-service/{appName}/module/{format}"
    const appIdentity = {
        appName,
        format: runtimeEnvironment.format,
        resourceType: AppResourceEnum.MODULE,
    };
    const bootstrapSpecifier = getAppSpecifier(appIdentity);
    /*
        Internal module and module dependency related resources used by the view to render view related components.
     */
    const moduleResources = [];
    /*
        External resources that the view depends. These resources include ones that an ViewDefinition client are required to load
        in order to view to begin initialization.
     */
    const requiredResources = [];
    /*
        Bootstrap configuration resources -- these resources are specifically exposed as bootstrap.resources in the RenderedViewRecord
     */
    const configResources = [];
    // Cache of visited module flattened graphs
    const visitedCache = new Map();
    // Collection of import URL metadata
    const imports = {};
    // Collection of root view component specifiers
    const rootComponents = [];
    // Collection of modules specifiers that MUST be loaded in the view
    const requiredAmdModules = [];
    // Collection of modules that will be loaded in the view
    const preloadAmdModules = [];
    // Determine if server side rendering view modules
    const isSSR = view.bootstrap?.ssr;
    // ------ AMD Required module resources
    if (isAMD) {
        // Keep shim format in sync with view_bootstrap.ts
        const shimBundle = !bundle
            ? 'lwr-loader-shim-legacy.js'
            : debug || minify === false
                ? 'lwr-loader-shim-legacy.bundle.js'
                : 'lwr-loader-shim-legacy.bundle.min.js';
        const def = (await resourceRegistry.getResource({ specifier: shimBundle, version }, runtimeEnvironment, runtimeParams));
        if (!def) {
            throw Error('Failed to find definition of resource: ' + shimBundle);
        }
        requiredResources.push(def);
        // Always inline the error shim script after the shim
        const errorShimDef = (await resourceRegistry.getResource({ specifier: 'lwr-error-shim.js', version }, runtimeEnvironment, runtimeParams));
        if (!errorShimDef) {
            throw Error('Failed to find definition of resource: lwr-error-shim.js');
        }
        requiredResources.push(errorShimDef);
        // Add loader, if not already bundled with the shim
        if (!bundle) {
            // needed because we're resolving against fully-linked modules
            requiredResources.push(await getModuleResource({
                specifier: 'lwr/loaderLegacy',
                version,
            }, runtimeEnvironment, {
                isPreload: false,
                isSSR,
            }, moduleRegistry, runtimeParams));
        }
    }
    // ------- Application Bootstrap module
    // Traversal of the Bootstrap Module Graph is done to get all the URLS for discoverable static dependencies.
    // Reasoning: This is to avoid unecessary HTTP 302's during initial application module fetching.
    // Scope: ESM currently only exposes immutable URI references, optimize for AMD formats
    const depth = isAMD
        ? { static: GraphDepth.ALL, dynamic: 1 }
        : { static: GraphDepth.NONE, dynamic: 0 };
    const bootstrapModuleGraph = await getModuleGraphs(bootstrapSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams, visitedCache);
    // ADD bootstrap module uri as a script resource
    const versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
    const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
    moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { isPreload: false, isSSR }));
    if (isAMD) {
        // ADD bootstrap module as required
        requiredAmdModules.push(versionedSpecifier);
        // AMD ADD bootstrap module uri addressability
        imports[versionedSpecifier] = uri;
        // PRELOAD bootstrap module static deps as link resource
        for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
            const uri = bootstrapModuleGraph.uriMap[staticDep];
            // AMD ADD static module dep uri addressability
            imports[staticDep] = uri;
            // ADD bootstrap module static deps to requiredAmdModules if services, otherwise preloadModules
            if (services && services.length) {
                // get the graphs for the bs static deps
                moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { isPreload: true, isSSR }));
                requiredAmdModules.push(staticDep);
            }
        }
        // AMD Add import mappings for known dynamic imports
        for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
            const uri = bootstrapModuleGraph.uriMap[dynamicDep];
            if (uri) {
                imports[dynamicDep] = uri;
            }
            else {
                logger.warn('Skipping unknown dynamic import ' + dynamicDep);
            }
        }
    }
    // ------- View related custom element moduleResources
    const customElementsRecords = [];
    const flattenedElements = flattenCustomElements(customElements, isSSR);
    await Promise.all(flattenedElements.map(async ({ tagName: element, props }) => {
        const graph = await getModuleGraphs(kebabCaseToModuleSpecifer(element), { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams ? runtimeParams : {}, visitedCache);
        // add to the viewRecord
        customElementsRecords.push({ elementName: element, flatGraph: graph });
        // PRELOAD custom element static deps as link resource
        const specifier = graph.graphs[0].specifier;
        const uri = graph.uriMap[specifier];
        moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { isPreload: true, isSSR }));
        // ADD register custom elements as a uri addressable rootComponents
        rootComponents.push(specifier);
        imports[specifier] = uri;
        if (isAMD) {
            preloadAmdModules.push(specifier);
            for (const staticDep of graph.graphs[0].static) {
                const uri = graph.uriMap[staticDep];
                // AMD ADD static module dep uri addressability
                imports[staticDep] = uri;
            }
            // AMD ADD dynamic imports module dep uri addressability
            for (const dynamicDep of graph.graphs[0].dynamicRefs) {
                const uri = graph.uriMap[dynamicDep];
                imports[dynamicDep] = uri;
            }
        }
    }));
    // ADD configuration of the bootstrapModule
    configResources.unshift(await getViewBootstrapConfigurationResource({
        id: view.id,
        url: viewParams?.page?.url,
        configAsSrc: view.bootstrap?.configAsSrc || false,
    }, {
        appId: appIdentity.appName,
        bootstrapModule: versionedSpecifier,
        autoBoot: view.bootstrap?.autoBoot === false ? false : true,
        importMappings: {
            imports,
            default: getModuleUriPrefix(runtimeEnvironment, runtimeParams),
        },
        rootComponents,
        ...(isAMD && { requiredModules: requiredAmdModules }),
        ...(isAMD && { preloadModules: preloadAmdModules }),
    }, runtimeEnvironment, runtimeParams));
    if (!isAMD && hmrEnabled) {
        configResources.unshift(await getViewHmrConfigurationResource(view, viewMetadata));
    }
    // generate html partial
    const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(generateHtmlTag));
    return {
        partial: htmlResources.join('\n'),
        viewRecord: {
            resources: requiredResources,
            customElements: customElementsRecords,
            bootstrapModule: {
                specifier: bootstrapModuleGraph.graphs[0].specifier,
                flatGraph: bootstrapModuleGraph,
                resources: configResources,
            },
        },
    };
}
//# sourceMappingURL=legacy_view_bootstrap.js.map