import { getMappingUriPrefix, getModuleUriPrefix, getClientBootstrapConfigurationUri, hashContent, } from '@lwrjs/shared-utils';
const CONTENT_TYPE = 'application/javascript';
export function getViewBootstrapConfigurationResource(viewInfo, config, runtimeEnvironment, runtimeParams) {
    const { compat, debug, hmrEnabled, apiVersion, format } = runtimeEnvironment;
    const isESM = format === 'esm';
    const defaultUrl = getModuleUriPrefix(runtimeEnvironment, runtimeParams);
    const mapping = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping,
            // TODO: DBL Should the ESM rely directly on the module endpoint?  why not use the mapping endpoint as well?
            ...(isESM && { module: defaultUrl }),
            ...(isESM &&
                hmrEnabled && {
                hmr: `/${apiVersion}/hmr/${format}/${compat}?${debug ? 'debug=true' : ''}`,
            }),
        },
        ...(debug && { modifiers: { debug: 'true' } }),
    };
    const configString = [
        '/* This script is generated */',
        '/* Client Bootstrap configuration */',
        `globalThis.LWR = globalThis.LWR || {};`,
        `Object.assign(globalThis.LWR, ${JSON.stringify({
            ...config,
            endpoints,
        })});`,
        `globalThis.process = { env: { NODE_ENV: "${runtimeEnvironment.serverMode}" } };`,
    ]
        .filter(Boolean)
        .join('\n');
    if (viewInfo.configAsSrc) {
        const viewUrl = viewInfo.url || '/';
        const url = getClientBootstrapConfigurationUri({ id: viewInfo.id, url: viewUrl }, runtimeEnvironment, runtimeParams, hashContent(configString));
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: false,
            src: url,
        };
    }
    else {
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: true,
        };
    }
}
export function getViewHmrConfigurationResource(view, viewMetadata) {
    const { assetReferences } = viewMetadata;
    const { contentTemplate, layoutTemplate } = view;
    const refs = assetReferences.map((assetReference) => {
        if (assetReference.override) {
            return assetReference.override?.entry;
        }
    });
    const configString = [
        `
        /* generated View/HMR debug script */
        globalThis._lwrRuntimeDebug = {
            viewMetadata: {
                assetReferences: ${JSON.stringify(refs)},
                templates: ${JSON.stringify([contentTemplate, layoutTemplate].filter(Boolean))}
            }
        }
        `,
        `globalThis.lwcRuntimeFlags = { ENABLE_HMR: true };`,
    ]
        .filter(Boolean)
        .join('\n');
    // Return an inline resource
    return {
        type: CONTENT_TYPE,
        inline: true,
        content: configString,
    };
}
export function flattenCustomElements(arr, isSSR = false) {
    const ret = [];
    const visitedTags = new Set();
    function flatten(arr) {
        for (const val of arr) {
            const { tagName, children, props } = val;
            if (!visitedTags.has(tagName)) {
                if (isSSR) {
                    ret.push({ tagName, props });
                }
                else {
                    ret.push({ tagName });
                }
                visitedTags.add(tagName);
            }
            if (children) {
                flatten(children);
            }
        }
    }
    flatten(arr);
    return ret;
}
//# sourceMappingURL=utils.js.map