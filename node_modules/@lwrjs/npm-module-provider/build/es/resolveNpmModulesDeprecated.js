/* istanbul ignore file */
import { dirname, join } from 'path';
import { install } from 'esinstall';
import { readFileSync, copyFileSync, mkdirSync, existsSync, writeFileSync } from 'fs';
import resolve from 'resolve';
function getPkgVersion(specifier) {
    const pkgPath = resolve.sync(join(specifier, '/package.json'));
    return JSON.parse(readFileSync(pkgPath, 'utf-8')).version;
}
function readModuleMapping(moduleMappingPath) {
    return existsSync(moduleMappingPath)
        ? JSON.parse(readFileSync(moduleMappingPath, 'utf-8'))
        : { imports: {} };
}
function writeModuleMapping(loc, importMap) {
    writeFileSync(loc, JSON.stringify(importMap, undefined, 2), { encoding: 'utf-8' });
}
export async function resolveNpmModuleSpecifierBlock(specifier, dest, config) {
    try {
        // TODO: file an issue on snowpack so they don't wipe the folder every-time
        // in the mean time we have to do hackery that will be likely to break when upgrading
        const tmpFolder = join(dest, '__tmp', specifier.replace(/[/|@]/g, '_'));
        mkdirSync(tmpFolder, { recursive: true });
        const moduleMappingPath = join(dest, 'import-map-cache.json');
        const currentModuleMapping = readModuleMapping(moduleMappingPath);
        const version = getPkgVersion(specifier);
        const cacheKey = `${specifier}@${version}`;
        if (currentModuleMapping.imports[cacheKey]) {
            return {
                id: cacheKey,
                specifier,
                entry: currentModuleMapping.imports[cacheKey],
                version,
            };
        }
        const external = config.external?.filter((e) => e !== specifier) || [];
        const polyfillNode = config.polyfillNode ?? true;
        // Unfortunately esinstall APIs its  not very programatic instead its file oriented...
        await install([specifier], {
            dest: tmpFolder,
            importMap: currentModuleMapping,
            logger: {
                debug: () => void 0,
                log: () => void 0,
                warn: () => void 0,
                error: () => void 0,
            },
            polyfillNode,
            external,
        });
        // esinstall produces a new module mapping, read it to get the generated file
        const moduleMapping = readModuleMapping(join(tmpFolder, 'import-map.json'));
        const moduleRelativePath = moduleMapping.imports[specifier];
        const moduleAbsPath = join(tmpFolder, moduleRelativePath);
        const moduleEntry = join(dest, moduleRelativePath);
        // create module's namespaced dir if it's namespaced, i.e.
        // no namespace: 'utils' -> web_modules/utils.js
        // namespace: '@mynamespace/utils' -> web_modules/@mynamespace/utils.js
        mkdirSync(dirname(moduleEntry), { recursive: true });
        // copy from _tmp to main folder and update the importMap for caching
        copyFileSync(moduleAbsPath, moduleEntry);
        const mergedMapping = {
            imports: {
                ...currentModuleMapping.imports,
                [cacheKey]: moduleEntry,
            },
        };
        writeModuleMapping(moduleMappingPath, mergedMapping);
        return {
            id: cacheKey,
            entry: moduleEntry,
            specifier,
            version,
        };
    }
    catch (err) {
        console.log('[ERROR]resolveNpmModules(esinstall): ', { specifier, dest });
    }
}
class Queue {
    constructor() {
        this.queue = [];
        this.workingOnPromise = false;
        this.pendingPromise = false;
    }
    enqueue(promise) {
        return new Promise((resolve, reject) => {
            this.queue.push({ promise, resolve, reject });
            this.dequeue();
        });
    }
    dequeue() {
        if (this.workingOnPromise) {
            return false;
        }
        const item = this.queue.shift();
        if (!item) {
            return false;
        }
        this.workingOnPromise = true;
        try {
            item.promise()
                .then((value) => {
                this.workingOnPromise = false;
                item.resolve(value);
                this.dequeue();
            })
                .catch((err) => {
                this.workingOnPromise = false;
                item.reject(err);
                this.dequeue();
            });
        }
        catch (err) {
            this.workingOnPromise = false;
            item.reject(err);
            this.dequeue();
        }
        return true;
    }
}
const RESOLVER_QUEUE = new Queue();
export async function resolveNpmModuleSpecifierDeprecated(specifier, dest, config) {
    return RESOLVER_QUEUE.enqueue(resolveNpmModuleSpecifierBlock.bind(null, specifier, dest, config));
}
//# sourceMappingURL=resolveNpmModulesDeprecated.js.map