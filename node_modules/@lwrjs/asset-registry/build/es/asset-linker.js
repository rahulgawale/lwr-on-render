import { join } from 'path';
import { createStringBuilder, logger } from '@lwrjs/shared-utils';
export function getUriFromAsset(asset, runtimeEnvironment) {
    const { apiVersion, immutableAssets, basePath } = runtimeEnvironment;
    const { type, ownHash, uri: assetUri, entry } = asset;
    const immutable = immutableAssets ? 'immutable/' : '';
    const hash = immutableAssets ? ownHash : 'latest';
    const uri = join(`${basePath}/${apiVersion}/${type}/${immutable}s/${hash}`, encodeURI(assetUri));
    return {
        uri,
        entry,
        immutable: immutableAssets,
    };
}
export async function linkAsset(source, assetSource, runtimeEnvironment, resolveUri) {
    const assetReferences = assetSource.metadata?.assetReferences;
    if (Buffer.isBuffer(source) || !assetReferences || assetReferences.length === 0) {
        return source;
    }
    const codeStringBuilder = createStringBuilder(source);
    const importer = assetSource.entry;
    for (const assetRef of assetReferences) {
        const { url, relative, location: { startOffset, endOffset }, } = assetRef;
        // Only override relative assets
        if (relative) {
            try {
                // eslint-disable-next-line no-await-in-loop
                assetRef.override = await resolveUri({ specifier: url, importer }, runtimeEnvironment);
                const overrideUrl = assetRef.override?.uri;
                codeStringBuilder.overwrite(startOffset, endOffset, overrideUrl || url);
            }
            catch (err) {
                // Just logging a waring if the user cannot resolve a linked asset reference to not disrupt other linking
                logger.warn(`Failed to resolve reference '${url}' in asset '${importer}'`);
            }
        }
    }
    return codeStringBuilder.toString();
}
//# sourceMappingURL=asset-linker.js.map