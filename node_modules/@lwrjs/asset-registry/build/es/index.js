import crypto from 'crypto';
import { dirname, join, relative, basename } from 'path';
import { createReadStream, existsSync, readFileSync, writeFileSync } from 'fs';
import { getUriFromAsset, linkAsset } from './asset-linker.js';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { isExternalUrl, normalizeResourcePath, ASSETS_CACHE_DIR } from '@lwrjs/shared-utils';
// Tries to convert any URL or $aliased path into a canonical fs path
function normalizeSpecifier(assetId, assetPathMap, resourcePaths, basePath) {
    const { specifier, importer, type } = assetId;
    if (specifier.startsWith('./') || specifier.startsWith('../')) {
        if (!importer) {
            throw Error(`Unable to resolve relative import "${specifier}" without an importer.`);
        }
        return join(dirname(importer), specifier);
    }
    if (type === 'content-asset') {
        const originSpecifier = basePath === '' ? specifier : specifier.split(basePath)[1];
        return join(resourcePaths.contentDir, originSpecifier);
    }
    if (specifier[0] === '$') {
        // This is a fs path containing an asset alias
        return normalizeResourcePath(specifier, resourcePaths);
    }
    // This is an absolute path to the server
    // Match in 2 ways:
    //      - Directories: the prefix of the asset specifier/path matches a configured assets[i].urlPath
    //      - Individual files: the asset specifier is equal to a configured assets[i].urlPath
    for (const [urlPath, fsPath] of assetPathMap.entries()) {
        const slashPath = urlPath.endsWith('/') ? urlPath : `${urlPath}/`;
        if (specifier.startsWith(slashPath) || specifier === urlPath) {
            return specifier.replace(urlPath, fsPath);
        }
    }
    return specifier;
}
function validateSpecifier(specifier, { assets, contentDir }) {
    // If is a URL
    if (isExternalUrl(specifier)) {
        return {
            type: 'external',
            uri: specifier,
        };
    }
    const assetsMap = assets.reduce((map, asset) => {
        const { alias, urlPath } = asset;
        if (alias) {
            const assetDir = asset;
            const fsPath = assetDir.dir ? assetDir.dir : asset.file;
            if (fsPath) {
                map[fsPath] = urlPath;
            }
        }
        return map;
    }, {});
    if (specifier.startsWith(contentDir)) {
        return {
            type: 'content-asset',
            uri: relative(contentDir, specifier),
        };
    }
    for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
        if (specifier.startsWith(fsPath)) {
            return {
                type: 'asset',
                uri: specifier.replace(fsPath, urlPath),
            };
        }
    }
    return {
        type: 'unknown',
        uri: specifier,
    };
}
export class LwrAssetRegistry {
    constructor(context, lwrGlobalConfig) {
        this.providers = [];
        const { assetTransformers = [] } = context;
        const { assets, rootDir, layoutsDir, contentDir, cacheDir, basePath } = lwrGlobalConfig;
        this.resourcePaths = { assets, rootDir, layoutsDir, contentDir };
        this.name = 'lwr-asset-registry';
        this.cacheDir = join(cacheDir, ASSETS_CACHE_DIR);
        this.assetTransformers = assetTransformers;
        this.assetPathMap = assets.reduce((map, asset) => {
            const urlPath = `${basePath}${asset.urlPath}`;
            map.set(urlPath, asset.dir || asset.file);
            return map;
        }, new Map());
        this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
    }
    async delegateGetAsset(assetFilePath) {
        for (const provider of this.providers) {
            // eslint-disable-next-line no-await-in-loop
            const result = await provider.getAsset(assetFilePath);
            if (result) {
                return result;
            }
        }
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.ASSET(assetFilePath),
        }, LwrUnresolvableError);
    }
    // -- Public API --------------------------------------------------------------------
    // Add new resource providers
    addAssetProviders(providers) {
        this.providers.push(...providers);
    }
    // Retrieve a resource from the providers and transform it though pipeline of plugins
    async getAsset(assetId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runtimeEnvironment, includeMetadata) {
        const { basePath } = runtimeEnvironment;
        const assetFilePath = normalizeSpecifier(assetId, this.assetPathMap, this.resourcePaths, basePath);
        const rawAsset = await this.delegateGetAsset(assetFilePath);
        const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
        // Since metadata is not cached with the asset to include metadata we need to re-process
        if (!includeMetadata && existsSync(overrideFilePath)) {
            return this.getAssetDefinition(rawAsset, runtimeEnvironment);
        }
        // Note is important we guarantee the release of the assetSource string (no closures!)
        // Otherwise we will be putting all assets in memory which is problematic
        let assetSource = rawAsset.content();
        let pluginContext = {};
        // STEP 1: Apply asset transformations
        // In this hook you can modify the source arbitrarily @include file semantics
        // INVARIANT: return must be a parsable mimetype compliant source
        // ex (SASS -> CSS, LESS -> CSS, PNG -> PNG optimized, ...)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const transformResult = await transformPlugin.transform?.(assetSource, rawAsset, pluginContext);
            if (transformResult) {
                if (Buffer.isBuffer(transformResult) || typeof transformResult === 'string') {
                    assetSource = transformResult;
                }
                else {
                    assetSource = transformResult.code;
                    pluginContext = { ...pluginContext, ...transformResult.context };
                }
            }
        }
        // STEP 2: Apply metadata transformations
        // Here is where we "link" or "transform" the code
        // as long as the module semantics are not touched
        // (ex. you cant add links to more resources)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const linkResult = await transformPlugin.extractMetadata?.(assetSource, rawAsset, pluginContext);
            if (linkResult) {
                pluginContext = { ...pluginContext, ...linkResult.context };
                rawAsset.metadata = { ...rawAsset.metadata, ...linkResult.metadata };
            }
        }
        // STEP 3.0: TBD: Potentially expose a "linking" phase to user-land ??
        // STEP 3.1: Link the asset (rewrite the file based on metadata)
        // Note that some of the metadata might no longer be accurate (ex. import locations) after this step
        assetSource = await linkAsset(assetSource, rawAsset, runtimeEnvironment, this._memoizeResolveUri);
        // STEP 4:  Optimize asset transformations
        // Here we do minimization, compression, obfuscation, ...
        // This should also not change the semantics of the file (ex. imports)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const optimizeResult = await transformPlugin.optimize?.(assetSource, rawAsset, pluginContext);
            if (optimizeResult) {
                if (typeof optimizeResult === 'string' || Buffer.isBuffer(optimizeResult)) {
                    assetSource = optimizeResult;
                }
                else {
                    pluginContext = { ...pluginContext, ...optimizeResult.context };
                    assetSource = optimizeResult.code;
                }
            }
        }
        // STEP 5: Store the modified/transformed version of the asset
        writeFileSync(overrideFilePath, assetSource, 'utf-8');
        // STEP 6: Normalize and augment the asset and return the full definition
        const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        if (includeMetadata) {
            return { ...newDef, metadata: rawAsset.metadata };
        }
        else {
            return newDef;
        }
    }
    getHashedAssetPath({ ownHash, entry }, runtimeEnvironment) {
        const runtimeHash = [
            runtimeEnvironment.immutableAssets ? 'i' : '',
            runtimeEnvironment.minify ? 'm' : '',
        ].join('');
        // Create a hash based on the full path plus the own hash from the provider.
        // The FS provider own hash is just the last time the file was saved.
        const fullPathHash = crypto.createHash('sha1').update(`${entry}:${ownHash}`).digest('hex').toString();
        return join(this.cacheDir, `${runtimeHash}_${fullPathHash}_${basename(entry)}`);
    }
    async getAssetDefinition(assetSource, runtimeEnvironment) {
        const { uri, type } = validateSpecifier(assetSource.entry, this.resourcePaths);
        const overrideFilePath = this.getHashedAssetPath(assetSource, runtimeEnvironment);
        return {
            ...assetSource,
            type: assetSource.uri ? 'external' : type,
            uri: assetSource.uri ? assetSource.uri : uri,
            // NOTE: The "entry" field still points to the old fs path.
            // If we were to change it, we need to reconcile it with the metadata delivery on HMR
            stream: (encoding) => createReadStream(overrideFilePath, { encoding }),
            content: (encoding) => readFileSync(overrideFilePath, encoding),
        };
    }
    // Given a resource and environment, return a resource URI
    async resolveAssetUri(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            return { uri: specifier, entry: specifier, immutable: true };
        }
        const assetDef = await this.getAsset(assetId, runtimeEnvironment);
        return getUriFromAsset(assetDef, runtimeEnvironment);
    }
    // Given a resource and environment, return a resource URI with out deep linking (which could result in cycles)
    async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            return { uri: specifier, entry: specifier, immutable: true };
        }
        const { basePath } = runtimeEnvironment;
        const assetFilePath = normalizeSpecifier(assetId, this.assetPathMap, this.resourcePaths, basePath);
        const rawAsset = await this.delegateGetAsset(assetFilePath);
        const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        return getUriFromAsset(assetDef, runtimeEnvironment);
    }
    getPublicApi() {
        return {
            getAsset: this.getAsset.bind(this),
            resolveAssetUri: this.resolveAssetUri.bind(this),
        };
    }
}
//# sourceMappingURL=index.js.map