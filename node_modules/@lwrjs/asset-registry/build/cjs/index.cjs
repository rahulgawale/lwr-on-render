var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/asset-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrAssetRegistry: () => LwrAssetRegistry
});
var import_crypto = __toModule(require("crypto"));
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var import_asset_linker = __toModule(require("./asset-linker.cjs"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
function normalizeSpecifier(assetId, assetPathMap, resourcePaths, basePath) {
  const {specifier, importer, type} = assetId;
  if (specifier.startsWith("./") || specifier.startsWith("../")) {
    if (!importer) {
      throw Error(`Unable to resolve relative import "${specifier}" without an importer.`);
    }
    return (0, import_path.join)((0, import_path.dirname)(importer), specifier);
  }
  if (type === "content-asset") {
    const originSpecifier = basePath === "" ? specifier : specifier.split(basePath)[1];
    return (0, import_path.join)(resourcePaths.contentDir, originSpecifier);
  }
  if (specifier[0] === "$") {
    return (0, import_shared_utils.normalizeResourcePath)(specifier, resourcePaths);
  }
  for (const [urlPath, fsPath] of assetPathMap.entries()) {
    const slashPath = urlPath.endsWith("/") ? urlPath : `${urlPath}/`;
    if (specifier.startsWith(slashPath) || specifier === urlPath) {
      return specifier.replace(urlPath, fsPath);
    }
  }
  return specifier;
}
function validateSpecifier(specifier, {assets, contentDir}) {
  if ((0, import_shared_utils.isExternalUrl)(specifier)) {
    return {
      type: "external",
      uri: specifier
    };
  }
  const assetsMap = assets.reduce((map, asset) => {
    const {alias, urlPath} = asset;
    if (alias) {
      const assetDir = asset;
      const fsPath = assetDir.dir ? assetDir.dir : asset.file;
      if (fsPath) {
        map[fsPath] = urlPath;
      }
    }
    return map;
  }, {});
  if (specifier.startsWith(contentDir)) {
    return {
      type: "content-asset",
      uri: (0, import_path.relative)(contentDir, specifier)
    };
  }
  for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
    if (specifier.startsWith(fsPath)) {
      return {
        type: "asset",
        uri: specifier.replace(fsPath, urlPath)
      };
    }
  }
  return {
    type: "unknown",
    uri: specifier
  };
}
var LwrAssetRegistry = class {
  constructor(context, lwrGlobalConfig) {
    this.providers = [];
    const {assetTransformers = []} = context;
    const {assets, rootDir, layoutsDir, contentDir, cacheDir, basePath} = lwrGlobalConfig;
    this.resourcePaths = {assets, rootDir, layoutsDir, contentDir};
    this.name = "lwr-asset-registry";
    this.cacheDir = (0, import_path.join)(cacheDir, import_shared_utils.ASSETS_CACHE_DIR);
    this.assetTransformers = assetTransformers;
    this.assetPathMap = assets.reduce((map, asset) => {
      const urlPath = `${basePath}${asset.urlPath}`;
      map.set(urlPath, asset.dir || asset.file);
      return map;
    }, new Map());
    this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
  }
  async delegateGetAsset(assetFilePath) {
    for (const provider of this.providers) {
      const result = await provider.getAsset(assetFilePath);
      if (result) {
        return result;
      }
    }
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.ASSET(assetFilePath)
    }, import_diagnostics.LwrUnresolvableError);
  }
  addAssetProviders(providers) {
    this.providers.push(...providers);
  }
  async getAsset(assetId, runtimeEnvironment, includeMetadata) {
    const {basePath} = runtimeEnvironment;
    const assetFilePath = normalizeSpecifier(assetId, this.assetPathMap, this.resourcePaths, basePath);
    const rawAsset = await this.delegateGetAsset(assetFilePath);
    const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
    if (!includeMetadata && (0, import_fs.existsSync)(overrideFilePath)) {
      return this.getAssetDefinition(rawAsset, runtimeEnvironment);
    }
    let assetSource = rawAsset.content();
    let pluginContext = {};
    for (const transformPlugin of this.assetTransformers) {
      const transformResult = await transformPlugin.transform?.(assetSource, rawAsset, pluginContext);
      if (transformResult) {
        if (Buffer.isBuffer(transformResult) || typeof transformResult === "string") {
          assetSource = transformResult;
        } else {
          assetSource = transformResult.code;
          pluginContext = {...pluginContext, ...transformResult.context};
        }
      }
    }
    for (const transformPlugin of this.assetTransformers) {
      const linkResult = await transformPlugin.extractMetadata?.(assetSource, rawAsset, pluginContext);
      if (linkResult) {
        pluginContext = {...pluginContext, ...linkResult.context};
        rawAsset.metadata = {...rawAsset.metadata, ...linkResult.metadata};
      }
    }
    assetSource = await (0, import_asset_linker.linkAsset)(assetSource, rawAsset, runtimeEnvironment, this._memoizeResolveUri);
    for (const transformPlugin of this.assetTransformers) {
      const optimizeResult = await transformPlugin.optimize?.(assetSource, rawAsset, pluginContext);
      if (optimizeResult) {
        if (typeof optimizeResult === "string" || Buffer.isBuffer(optimizeResult)) {
          assetSource = optimizeResult;
        } else {
          pluginContext = {...pluginContext, ...optimizeResult.context};
          assetSource = optimizeResult.code;
        }
      }
    }
    (0, import_fs.writeFileSync)(overrideFilePath, assetSource, "utf-8");
    const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    if (includeMetadata) {
      return {...newDef, metadata: rawAsset.metadata};
    } else {
      return newDef;
    }
  }
  getHashedAssetPath({ownHash, entry}, runtimeEnvironment) {
    const runtimeHash = [
      runtimeEnvironment.immutableAssets ? "i" : "",
      runtimeEnvironment.minify ? "m" : ""
    ].join("");
    const fullPathHash = import_crypto.default.createHash("sha1").update(`${entry}:${ownHash}`).digest("hex").toString();
    return (0, import_path.join)(this.cacheDir, `${runtimeHash}_${fullPathHash}_${(0, import_path.basename)(entry)}`);
  }
  async getAssetDefinition(assetSource, runtimeEnvironment) {
    const {uri, type} = validateSpecifier(assetSource.entry, this.resourcePaths);
    const overrideFilePath = this.getHashedAssetPath(assetSource, runtimeEnvironment);
    return {
      ...assetSource,
      type: assetSource.uri ? "external" : type,
      uri: assetSource.uri ? assetSource.uri : uri,
      stream: (encoding) => (0, import_fs.createReadStream)(overrideFilePath, {encoding}),
      content: (encoding) => (0, import_fs.readFileSync)(overrideFilePath, encoding)
    };
  }
  async resolveAssetUri(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      return {uri: specifier, entry: specifier, immutable: true};
    }
    const assetDef = await this.getAsset(assetId, runtimeEnvironment);
    return (0, import_asset_linker.getUriFromAsset)(assetDef, runtimeEnvironment);
  }
  async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      return {uri: specifier, entry: specifier, immutable: true};
    }
    const {basePath} = runtimeEnvironment;
    const assetFilePath = normalizeSpecifier(assetId, this.assetPathMap, this.resourcePaths, basePath);
    const rawAsset = await this.delegateGetAsset(assetFilePath);
    const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    return (0, import_asset_linker.getUriFromAsset)(assetDef, runtimeEnvironment);
  }
  getPublicApi() {
    return {
      getAsset: this.getAsset.bind(this),
      resolveAssetUri: this.resolveAssetUri.bind(this)
    };
  }
};
