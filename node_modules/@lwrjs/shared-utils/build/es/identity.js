import slugifyText from 'slugify';
import getCacheKeyFromJson from 'fast-json-stable-stringify';
export const VERSION_SIGIL = '/v/';
export const LOCALE_SIGIL = 'l';
export const ENVIRONMENT_SIGIL = 'e';
export const BUNDLE_SIGIL = 'bi';
export const LATEST_SIGNATURE = 'latest';
export const DEFAULT_TITLE = 'LWR App';
export const IMMUTABLE_ASSET_PREFIX = '/_immutable/';
export const ASSETS_CACHE_DIR = 'assetsCache';
// Locker trusted components
export const DEFAULT_LOCKER_TRUSTED_CMP = ['@locker/*', 'lwr/*', '@lwrjs/*', 'lwc', '@lwc/*'];
export const DEFAULT_LWR_LOCKER_CONFIG = {
    enabled: false,
    trustedComponents: DEFAULT_LOCKER_TRUSTED_CMP,
};
export const DEFAULT_LWR_BOOTSTRAP_CONFIG = {
    autoBoot: true,
    syntheticShadow: false,
    workers: {},
    services: [],
    configAsSrc: false,
    ssr: false,
};
/**
 * Turn the dots in a version into underscores
 * @param version
 * @example '1.0.0' => '1_0_0'
 */
export function normalizeVersionToUri(version) {
    return version.replace(/\./g, '_');
}
/**
 * Turn the underscores in a URI version into dots
 * @param version
 * @example '1_0_0' => '1.0.0'
 */
export function normalizeVersionFromUri(version) {
    return version.replace(/_/g, '.');
}
/**
 * Create the last token for a module URL.  Readable specifier for a URI
 *
 * examples/app/scoped/css?scoped=true => examples_app_scoped_css_scoped=true
 */
export function prettyModuleUriSuffix(specifier) {
    // eslint-disable-next-line no-useless-escape
    return `${specifier.replace(/[\/\.\?\#]/g, '_')}`;
}
export function explodeSpecifier(rawSpecifier) {
    const decodedSpecifier = decodeURIComponent(rawSpecifier);
    // Split up the version and bare specifier
    const versionMatch = decodedSpecifier.match(/(.+)\/v\/([a-zA-Z0-9-_.]+)$/);
    const version = versionMatch ? versionMatch[2] : undefined;
    const importee = versionMatch ? versionMatch[1] : decodedSpecifier;
    // Pull out the namespace and name
    const [rawNamespace, rawName, ...remaining] = importee.split('/');
    const namespace = rawName ? rawNamespace : undefined;
    const name = rawName ? [rawName, ...remaining].join('/') : rawNamespace;
    // Return an abstract ModuleIdentifier
    return {
        specifier: importee,
        namespace,
        name,
        version: version ? normalizeVersionFromUri(version) : version,
    };
}
export function explodeSpecifiers(rawSpecifiers) {
    const exploder = explodeSpecifier;
    if (!rawSpecifiers) {
        return [];
    }
    return rawSpecifiers.split(',').map(function (rawSpecifier) {
        return exploder(rawSpecifier);
    });
}
/**
 * Create a specifier with a namespace (optional), name and version (optional)
 * @param param0 - namespace and name
 * @example - { specifier: 'c/form', namespace: 'c', name: 'form' } => 'c/form'
 * @example - { specifier: 'c/form', version: '5000' } => 'c/form/v/5000'
 * @example - { name: 'lwc' } => 'lwc'
 * @example - { namespace: 'c', name: 'app' } => 'c/app'
 * @example - { namespace: '@salesforce', name: 'label/my.label' } => '@salesforce/label/my.label'
 * @example - { name: 'lwc', version: '1.7' } => 'lwc/v/1.7'
 * @example - { namespace: 'c', name: 'navMenu', version: '2.0' } => 'c/navMenu/v/2.0'
 * @example - { namespace: '@salesforce', name: 'label/my.label', version: '1' } => '@salesforce/label/my.label/v/1'
 */
export function getSpecifier({ specifier, namespace, name = '', version }) {
    if (specifier) {
        // Remove any versioning from the specifier
        const versionMatch = specifier.match(/(.+)\/v\/[a-zA-Z0-9-_.]+$/);
        specifier = versionMatch ? versionMatch[1] : specifier;
        return version ? `${specifier}${VERSION_SIGIL}${normalizeVersionToUri(version)}` : specifier;
    }
    const bareSpecifier = namespace ? `${namespace}/${name}` : name;
    return version ? `${bareSpecifier}${VERSION_SIGIL}${normalizeVersionToUri(version)}` : bareSpecifier;
}
/**
 * Create a versioned specifier based on the module registry
 *
 * @remarks
 * If the incoming specifier is already versioned, it will be returned as is.
 *
 * The returned specifier's version conforms to the format expected to be used
 * external to the framework (e.g. via the identity in the URL, mapping metadata,
 * AMD define module name). This format conforms to the `normalizeVersionToUri`
 * implementation (e.g. version semver format -- major_minor_patch).
 *
 * This method is analogous to `getSpecifier` but supports non-versioned `rawSpecifiers`
 * The inverse of this method is `explodeSpecifier`

 * @param specifier - the module specifier
 * @param moduleRegistry - the public module registry
 *
 * @returns the specifier for the latest version
 *
 * @example - 'c/form' => 'c/form/v/0_0_1'
 * @example - 'c/form/v/0.0.2' => 'c/form/v/0_0_2'
 */
export async function getVersionedSpecifier(rawSpecifier, moduleRegistry) {
    const { specifier, namespace, name, version } = explodeSpecifier(rawSpecifier);
    if (version) {
        return normalizeVersionToUri(rawSpecifier);
    }
    // Get version from Module Registry
    const moduleEntry = await moduleRegistry.getModuleEntry({ specifier });
    return getSpecifier({ namespace, name, version: normalizeVersionToUri(moduleEntry.version) });
}
/**
 * Create a AbstractModuleId using the module registry to resolve the version
 * if a version is not provided in the `rawSpecifier`
 *
 * The returned ModuleId properties (specifically version) conforms to the format
 * expected by Module registry (e.g. version semver format -- major.minor.patch)
 *
 * @remarks
 * If the incoming specifier is already versioned, the version value will be normalized
 * to semver format.
 *
 * @param specifier - the module specifier
 * @param moduleRegistry - the public module registry
 *
 * @returns the specifier for the latest version
 *
 * @example - 'c/form' => {specifier: "c/form", version: "0.0.1"}
 * @example - 'c/form/v/0.0.2' => {specifier: "c/form", version: "0.0.2"}
 * @example - 'c/form/v/0_0_2' => {specifier: "c/form", version: "0.0.2"}
 */
export async function getVersionedModuleId(rawSpecifier, moduleRegistry) {
    const { specifier, version } = explodeSpecifier(rawSpecifier);
    if (version) {
        return { specifier, version: normalizeVersionFromUri(version) };
    }
    // Get version from Module Registry
    const moduleEntry = await moduleRegistry.getModuleEntry({ specifier });
    return { specifier, version: moduleEntry.version };
}
const RE_SCOPED = /^(@[^/]+\/[^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
const RE_NORMAL = /^([^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
/**
 * Parses an npm-style specifier
 * modified from https://github.com/egoist/parse-package-name#readme
 *
 * @param specifier - String to parse
 *
 * @example "@angular/core" => { scope: "@angular", packageName: "@angular/core", subResource: "" }
 * @example "@lwr/core/some/path" => { scope: "@lwr", packageName: "@lwr/core", subResource: "some/path" }
 * @example "my/app" => { packageName: "my", subResource: "app" }
 * @example "my/app/utils" => { packageName: "my", subResource: "app/utils" }
 * @example "lwc" => { packageName: "lwc", subResource: "" }
 */
export function parsePackageSpecifier(specifier) {
    const isScoped = specifier.charAt(0) === '@';
    const matched = isScoped ? specifier.match(RE_SCOPED) : specifier.match(RE_NORMAL);
    if (!matched) {
        throw new Error(`[parse-package-name] "${specifier}" is not a valid string`);
    }
    const scope = isScoped ? matched[1].split('/')[0] : undefined;
    if (isScoped) {
        return {
            scope,
            packageName: matched[1],
            subResource: matched[2] || '',
        };
    }
    return {
        packageName: matched[1],
        subResource: matched[2] || '',
    };
}
/**
 * Turn a string from kebab case to "specifier case": namespace/camelCaseName
 * @param name A string in kebab case
 * @example - 'name-of-something' => 'name/ofSomething'
 */
export function kebabCaseToModuleSpecifer(name) {
    const newName = [];
    let nsFound = false;
    let upper = false;
    for (const currChar of name) {
        if (currChar === '-') {
            if (!nsFound) {
                nsFound = true;
                newName.push('/');
            }
            else {
                upper = true;
            }
        }
        else {
            newName.push(upper ? currChar.toUpperCase() : currChar);
            upper = false;
        }
    }
    return newName.join('');
}
/**
 * Clone of lwr/init, reverse of kebabCaseToModuleSpecifer, strips off versions
 * @param specifier
 * @example - 'name/ofSomething/v/1.0.0' => 'name-of-something'
 */
export function moduleSpecifierToKebabCase(specifier) {
    return specifier
        .replace(/\/v\/[a-zA-Z0-9-_.]+$/, '')
        .replace('/', '-')
        .replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
}
/**
 * Turn a string into a slug
 * @param name a string to slugify
 * @example - 'This IS a sentence' => 'this-is-a-sentence'
 */
export function slugify(name) {
    return slugifyText(name, {
        lower: true,
    });
}
/**
 * Turn an html attribute into a LWC property, eg: 'best-property-ever' => 'bestPropertyEver'
 * @param propName - a string in kebab case (lowercase)
 * @returns - a string in camel case
 */
export function getPropFromAttrName(propName) {
    return propName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
/**
 * Create a module URI prefix, stopping where the specifier would be (at "mi/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export function getModuleUriPrefix({ apiVersion, bundle, format, compat, basePath }, { locale, environment } = {}) {
    const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : '';
    const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : '';
    if (bundle) {
        return `${basePath}/${apiVersion}/bundle/${format}${localePart}${environmentPart}/${BUNDLE_SIGIL}/0/module/mi/`;
    }
    else {
        return `${basePath}/${apiVersion}/module/${format}/${compat}${localePart}${environmentPart}/mi/`;
    }
}
/**
 * Create a URI Mapping API URI prefix, stopping where the specifiers would be (at "mp/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export function getMappingUriPrefix({ apiVersion, bundle, format, compat, basePath }, { locale, environment } = {}) {
    const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : '';
    const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : '';
    const bundlePart = bundle ? `/${BUNDLE_SIGIL}/0` : '';
    return `${basePath}/${apiVersion}/mapping/${format}/${compat}${localePart}${environmentPart}${bundlePart}/mp/`;
}
export { getCacheKeyFromJson };
const REGEX_URL_SCHEMA_PREFIX = /^(https?|\/\/)/;
export function isExternalUrl(url) {
    return REGEX_URL_SCHEMA_PREFIX.test(url);
}
// type guard for ViewDef responses
export function isBundleDefinition(definition) {
    return definition.bundleRecord !== undefined;
}
function validateSpecifier(specifer) {
    return specifer.indexOf('../') < 0;
}
export function getModuleIdentity(req) {
    const { specifier, signature = LATEST_SIGNATURE } = req.params;
    if (validateSpecifier(specifier) === false) {
        throw new Error('dot-dot-slash is not allowed for module specifier');
    }
    const moduleId = explodeSpecifier(specifier);
    return {
        moduleId,
        signature,
    };
}
export function getMappingIdentity(req) {
    const { specifiers } = req.params;
    const moduleIds = explodeSpecifiers(specifiers).map((obj) => ({
        ...obj,
        importer: req.query.importer,
    }));
    return {
        moduleIds,
    };
}
export function getResourceIdentity(req) {
    const { specifier, signature = LATEST_SIGNATURE } = req.params;
    if (validateSpecifier(specifier) === false) {
        throw new Error('dot-dot-slash is not allowed for resource specifier');
    }
    const resourceId = explodeSpecifier(specifier);
    return {
        resourceId,
        signature,
    };
}
export function getAssetIdentity(req) {
    const { signature = LATEST_SIGNATURE, assetType: type } = req.params;
    const [specifier] = req.originalUrl.split('?');
    if (validateSpecifier(specifier) === false) {
        throw new Error('dot-dot-slash is not allowed for asset specifier');
    }
    return {
        assetId: {
            specifier,
            type,
        },
        signature,
    };
}
//# sourceMappingURL=identity.js.map