import { getModuleGraphs, GraphDepth } from './graph.js';
import { explodeSpecifier, getSpecifier, isBundleDefinition } from './identity.js';
/**
 * Get the Import Metadata for the LWR Mapping Api (https://rfcs.lwc.dev/rfcs/lwr/0000-mapping-api)
 */
export async function getImportMetadataMappings(moduleIds, runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler) {
    const visitedCache = new Map();
    let importMetadata = {
        imports: {},
        index: {},
    };
    for (const moduleId of moduleIds) {
        const requestedSpecifier = getSpecifier(moduleId);
        // eslint-disable-next-line no-await-in-loop
        const specifier = await getVersionedSpecifier(moduleId, moduleRegistry);
        // Check if we have already visited
        if (!visitedCache.has(specifier)) {
            // Traversal of the Module Graph is done to get all the URLs for discoverable dependencies.
            // AMD gathers static imports while ESM gathers dynamic imports
            const depth = {
                static: runtimeEnvironment.format === 'esm' ? GraphDepth.NONE : GraphDepth.ALL,
                dynamic: runtimeEnvironment.format === 'esm' ? 1 : 0,
            };
            // eslint-disable-next-line no-await-in-loop
            const moduleGraph = await getModuleGraphs(specifier, 
            // include uris and linked definitions
            { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, runtimeEnvironment.bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams, visitedCache);
            // Root module
            // eslint-disable-next-line no-await-in-loop
            importMetadata = await toImportMetadata(moduleGraph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
        }
        // If the requested specifier is not the same as the versioned specifier, include the requested specifier's importer.
        if (requestedSpecifier !== specifier) {
            const requestedSpecifierPlusImporter = `${requestedSpecifier}?importer=${moduleId.importer}`;
            const specifiersArray = Object.values(importMetadata.imports).find((a) => a.includes(specifier));
            if (!specifiersArray) {
                throw new Error('Could not find: ' + specifier + ' in ' + JSON.stringify(importMetadata.imports));
            }
            specifiersArray.push(requestedSpecifierPlusImporter);
        }
    }
    return importMetadata;
}
/**
 * Generate the import mapping metadata for a module graph.
 *
 * The graph must have set includeUris and includeLinkedDefinitions to link specifiers to uris.
 *
 * You can pass in an existing set of import metadata and the result will merge the imports.
 * If there is a duplicate uri the merge will keep the one from the existing metadata.
 *
 * @param moduleGraph FlattenedModuleGraphs created by the graph shared util
 * @param existingImportMetadata Optional existing ImportMetadata.  If provided the results will be a merge the two sets of URI mappings.
 * @returns Returns ImportMetadata from a module graph in the format here -> https://rfcs.lwc.dev/rfcs/lwr/0000-mapping-api#uri-mapping-resource-specification
 */
export async function toImportMetadata(moduleGraph, existingImportMetadata = { imports: {}, index: {} }, moduleRegistry, runtimeEnvironment, runtimeParams = {}) {
    // root module specifier
    const specifier = moduleGraph.graphs[0].specifier;
    const uri = moduleGraph.uriMap[specifier];
    const definition = moduleGraph.linkedDefinitions[specifier];
    if (!uri) {
        throw new Error('URI was not included in the graph: ' + specifier);
    }
    if (!definition) {
        throw new Error('Linked module definition was not included in the graph: ' + specifier);
    }
    // Merge in the existing metadata with imports for the root specifier
    const rootMetadata = await normalizeImportMetadata(specifier, uri, definition, moduleRegistry, runtimeEnvironment, runtimeParams);
    let importMetadata = mergeImportMetadata(existingImportMetadata, rootMetadata);
    // root module dependencies:
    //  - static for AMD; dynamic dependencies require a new mapping request
    //  - dynamic for ESM; static dependencies are imported via fully qualified URLs
    const depSpecifiers = runtimeEnvironment.format === 'esm'
        ? moduleGraph.graphs[0].dynamicRefs
        : moduleGraph.graphs[0].static;
    for (const depSpecifier of depSpecifiers) {
        const depUri = moduleGraph.uriMap[depSpecifier];
        const depDef = moduleGraph.linkedDefinitions[depSpecifier];
        const depMissing = !depUri || !depDef;
        if (depMissing && runtimeEnvironment.format !== 'esm') {
            if (!depUri) {
                throw new Error('URI was not included in the graph for dependent: ' + depSpecifier);
            }
            if (!depDef) {
                throw new Error('Linked dependent module definition was not included in the graph: ' + depSpecifier);
            }
        }
        else if (depMissing) {
            // Ignore variable dynamic imports
            continue;
        }
        if (!importMetadata.imports[depUri]) {
            // eslint-disable-next-line no-await-in-loop
            const depMetadata = await normalizeImportMetadata(getSpecifier(depDef), depUri, depDef, moduleRegistry, runtimeEnvironment, runtimeParams);
            importMetadata = mergeImportMetadata(importMetadata, depMetadata);
        }
    }
    return importMetadata;
}
function mergeImportMetadata(existing, newMetadata) {
    // TODO should there be an error if the metadata conflicts?
    return {
        imports: {
            ...existing.imports,
            ...newMetadata.imports,
        },
        index: {
            ...existing.index,
            ...newMetadata.index,
        },
    };
}
async function normalizeImportMetadata(specifier, uri, definition, moduleRegistry, moduleRuntimeEnvironment, runtimeParams) {
    const specifiers = normalizedIncludedModules(definition);
    const imports = {};
    imports[uri] = specifiers;
    // The index info for the modules included in a bundle
    const index = await createIndex(specifiers, moduleRegistry, moduleRuntimeEnvironment, runtimeParams);
    // If root specifier was not included in createIndex add an entry where the uri is the index
    if (!(specifier in index)) {
        index[specifier] = uri;
    }
    // return imports and index objects created above
    return {
        imports,
        index,
    };
}
// Normalized the included modules associated with either an individual module definition or Bundle definition
function normalizedIncludedModules(definition) {
    return isBundleDefinition(definition)
        ? [getSpecifier(definition), ...definition.bundleRecord.includedModules]
        : [getSpecifier(definition)];
}
async function createIndex(specifiers, moduleRegistry, runtimeEnvironment, runtimeParams) {
    const index = {};
    // We need a runtime environment for modules when building the index for a bundle
    const moduleRuntimeEnvironment = { ...runtimeEnvironment, bundle: false };
    async function getUri(specifier) {
        const moduleId = explodeSpecifier(specifier);
        if (!moduleId.version) {
            throw new Error('Module specifier must include a version: ' + specifier);
        }
        index[specifier] = await moduleRegistry.resolveModuleUri({ ...moduleId, version: moduleId.version }, moduleRuntimeEnvironment, runtimeParams);
    }
    // Queue up uri requests
    const promises = [];
    for (const specifier of specifiers) {
        promises.push(getUri(specifier));
    }
    // Wait for them to finish
    await Promise.all(promises);
    return index;
}
async function getVersionedSpecifier(moduleId, moduleRegistry) {
    if (!moduleId.importer || moduleId.version) {
        return getSpecifier(moduleId);
    }
    const versionedModuleEntry = await moduleRegistry.getModuleEntry({
        ...moduleId,
    });
    return getSpecifier(versionedModuleEntry);
}
//# sourceMappingURL=mappings.js.map