import { DiagnosticsError } from '@lwrjs/diagnostics';
export const VERBOSE = 'verbose';
export const DEBUG = 'debug';
export const INFO = 'info';
export const WARN = 'warn';
export const ERROR = 'error';
let options = {};
const DUPES = new Set();
let currentLevel = process.env.LOG_LEVEL || INFO;
function log(level, message, additionalInfo) {
    const LOG_LEVEL = process.env.LOG_LEVEL || INFO;
    if (currentLevel !== LOG_LEVEL) {
        currentLevel = LOG_LEVEL;
        console.log(`LOG_LEVEL: ${LOG_LEVEL}`);
    }
    let shouldLog = false;
    switch (level) {
        case VERBOSE:
            shouldLog = LOG_LEVEL == VERBOSE;
            break;
        case DEBUG:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG;
            break;
        case INFO:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO;
            break;
        case WARN:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO || LOG_LEVEL == WARN;
            break;
        case ERROR:
            shouldLog = true;
            break;
    }
    // Check if we should suppress dupes and we have already logged this message
    if (shouldLog && options.dedupe && options.dedupe.has(level)) {
        const key = `[${level}] : ${message}`;
        if (DUPES.has(key)) {
            shouldLog = false;
        }
        else {
            // add key to de-duplicate cache
            DUPES.add(key);
        }
    }
    if (shouldLog) {
        let logMethod;
        if (level == ERROR) {
            logMethod = console.error;
        }
        else if (level == WARN) {
            logMethod = console.warn;
        }
        else {
            logMethod = console.log;
        }
        if (additionalInfo) {
            logMethod(`[${level}] ${message} \nAdditional Info: ${JSON.stringify(additionalInfo)}`);
        }
        else {
            logMethod(`[${level}] ${message}`);
        }
    }
}
export const stringifyError = (error) => {
    if (error instanceof DiagnosticsError) {
        return JSON.stringify({
            message: error.message,
            diagnostics: error.diagnostics,
            stack: error.stack,
        });
    }
    else if (typeof error === 'string' || error instanceof String) {
        return error;
    }
    else {
        const propertyNames = Object.getOwnPropertyNames(error);
        const retObj = {};
        for (let property, i = 0, len = propertyNames.length; i < len; ++i) {
            property = propertyNames[i];
            const descriptor = Object.getOwnPropertyDescriptor(error, property);
            retObj[property] = descriptor?.value;
        }
        return JSON.stringify(retObj);
    }
};
export const logger = {
    verbose: (message, additionalInfo) => log(VERBOSE, message, additionalInfo),
    debug: (message, additionalInfo) => log(DEBUG, message, additionalInfo),
    info: (message, additionalInfo) => log(INFO, message, additionalInfo),
    warn: (message, additionalInfo) => log(WARN, message, additionalInfo),
    error: (error, additionalInfo) => log(ERROR, stringifyError(error), additionalInfo),
    log,
    setOptions: (opts) => {
        options = opts;
    },
    currentLevel,
};
//# sourceMappingURL=logger.js.map