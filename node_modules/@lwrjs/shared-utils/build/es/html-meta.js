import { getPropFromAttrName } from './identity.js';
import SAXParser from 'parse5-sax-parser';
import { Readable } from 'stream';
function parseAssetLocation(htmlSource, tagName, attrLocation) {
    const { startOffset, endOffset } = attrLocation;
    const srcAttr = htmlSource.substring(startOffset, endOffset);
    // Split src="myURL"
    const split = srcAttr.indexOf('=');
    const keyAttr = srcAttr.substr(0, split);
    // Also remove the "s to just get myURL
    const url = srcAttr.slice(split + 2, -1);
    return {
        url,
        tagName,
        relative: isRelative(url),
        location: {
            startOffset: startOffset + keyAttr.length + 2 /* =" */,
            endOffset: endOffset - 1,
        },
    };
}
// Detect if this is a relative URL
export function isRelative(url) {
    return !url?.match(isNotRelativeRegex);
}
const isNotRelativeRegex = /^(http(s)?:\/\/|\/)/i;
// Detect if this is just a self referential URL
export function isSelfUrl(url) {
    return !url || !!url.match(isSelfUrlRegex);
}
const isSelfUrlRegex = /^\s*(data:|#)/i;
/**
 * Pull the custom elements and img tags out of an HTML string, to use as metadata
 * @param htmlSource - An HTML string to parse
 */
export async function extractMetadataFromHtml(htmlSource) {
    return new Promise((resolve, reject) => {
        const customElements = [];
        const openElements = new Set();
        const assetReferences = [];
        const parser = new SAXParser({ sourceCodeLocationInfo: true }); // TODO: Would we need this in the future?
        const ceRefStack = [];
        parser.on('startTag', ({ tagName, attrs, // attributes are passed into SSR
        sourceCodeLocation, }) => {
            // custom elements
            if (tagName.includes('-') && !openElements.has(tagName)) {
                const { startOffset, endOffset } = sourceCodeLocation;
                const ceRef = {
                    tagName,
                    location: { startOffset, endOffset },
                    // transform attributes [{ name: 'some-attr', value: 'the value' }] into properties { someAttr: 'the value' }
                    // leave props as undefined if there are no attributes
                    // set boolean attribute values to "true", or lwc will see them as falsy
                    props: attrs.length
                        ? attrs.reduce((obj, { name, value }) => {
                            obj[getPropFromAttrName(name)] = value === '' ? 'true' : value;
                            return obj;
                        }, {})
                        : undefined,
                };
                openElements.add(tagName);
                if (ceRefStack.length) {
                    // nested CE
                    const last = ceRefStack[ceRefStack.length - 1];
                    last.children = last.children ? [...last.children, ceRef] : [ceRef];
                    ceRefStack.push(ceRef);
                }
                else {
                    customElements.push(ceRef);
                    ceRefStack.push(ceRef);
                }
            }
            // <img src="asset-url"/>
            // <script type="text/javascript" src="asset-url"></script>
            if ((tagName === 'img' || tagName === 'script') && sourceCodeLocation.attrs) {
                if (sourceCodeLocation.attrs.src) {
                    assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.src));
                }
                // if (sourceCodeLocation.attrs.srcset) {
                // TODO: WIP
                // }
            }
            // <link rel="stylesheet" href="asset-url">
            if (tagName === 'link' && sourceCodeLocation.attrs) {
                if (sourceCodeLocation.attrs.href) {
                    assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.href));
                }
            }
        });
        parser.on('endTag', ({ tagName, sourceCodeLocation, }) => {
            if (openElements.has(tagName)) {
                const ceRef = ceRefStack.pop();
                openElements.delete(tagName);
                if (!ceRef) {
                    throw new Error(`Error extracting metadata: Unmatched custom element close tag for ${tagName}`);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                ceRef.location.endOffset = sourceCodeLocation.endOffset;
            }
        });
        const inputStream = Readable.from(htmlSource);
        // dedupe custom element references
        inputStream.on('end', () => resolve({ customElements, assetReferences }));
        inputStream.on('error', (error) => reject(error));
        inputStream.pipe(parser);
    });
}
//# sourceMappingURL=html-meta.js.map