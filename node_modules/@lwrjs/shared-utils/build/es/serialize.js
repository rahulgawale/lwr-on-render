// Given a Module Identifier, return a JSON entry
async function createJsonModule(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams) {
    const { ownHash, moduleEntry: { version }, } = await moduleRegistry.getModule(moduleId, runtimeParams);
    return {
        specifier: moduleId.specifier,
        version,
        ownHash,
        links: {
            self: moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, ownHash),
        },
    };
}
/**
 * Take a Module Definition and return its JSON serialization
 *
 * @param code - the compiled code string for the given module
 * @param param1 - the Module Definition to serialize
 * @param moduleRegistry
 * @returns - Promise to the JSON serialization of the module
 */
export async function serializeModuleToJson(code = '', { specifier, version, ownHash, runtimeEnvironment, linkedConfig: { minified }, moduleRecord: { imports = [] }, }, moduleRegistry, runtimeParams) {
    const { format } = runtimeEnvironment;
    // Build the dependencies array
    const dependencies = imports.map((dep) => createJsonModule(dep, moduleRegistry, runtimeEnvironment, runtimeParams));
    return {
        specifier,
        version,
        ownHash,
        dependencies: await Promise.all(dependencies),
        format,
        minified,
        code,
    };
}
/**
 * Replace a part of a source string at the indices with a different value
 *
 * @param src - source string
 * @param param1 - offset indices
 * @param replaceValue - replacement
 */
export function replaceStringFromLocation(src, { startOffset, endOffset }, replaceValue) {
    return src.substr(0, startOffset) + replaceValue + src.substr(endOffset, src.length);
}
//# sourceMappingURL=serialize.js.map