import getCacheKeyFromJson from 'fast-json-stable-stringify';
import { AbstractModuleId, AssetIdentity, BundleDefinition, MappingIdentity, MiddlewareRequest, ModuleDefinition, ModuleId, ModuleIdentity, PublicModuleRegistry, ResourceIdentity, RuntimeEnvironment, RuntimeParams } from '@lwrjs/types';
export declare const VERSION_SIGIL = "/v/";
export declare const LOCALE_SIGIL = "l";
export declare const ENVIRONMENT_SIGIL = "e";
export declare const BUNDLE_SIGIL = "bi";
export declare const LATEST_SIGNATURE = "latest";
export declare const DEFAULT_TITLE = "LWR App";
export declare const IMMUTABLE_ASSET_PREFIX = "/_immutable/";
export declare const ASSETS_CACHE_DIR = "assetsCache";
export declare const DEFAULT_LOCKER_TRUSTED_CMP: string[];
export declare const DEFAULT_LWR_LOCKER_CONFIG: {
    enabled: boolean;
    trustedComponents: string[];
};
export declare const DEFAULT_LWR_BOOTSTRAP_CONFIG: {
    autoBoot: boolean;
    syntheticShadow: boolean;
    workers: {};
    services: never[];
    configAsSrc: boolean;
    ssr: boolean;
};
declare type ModuleIdentifierPartial = Partial<AbstractModuleId>;
/**
 * Turn the dots in a version into underscores
 * @param version
 * @example '1.0.0' => '1_0_0'
 */
export declare function normalizeVersionToUri(version: string): string;
/**
 * Turn the underscores in a URI version into dots
 * @param version
 * @example '1_0_0' => '1.0.0'
 */
export declare function normalizeVersionFromUri(version: string): string;
/**
 * Create the last token for a module URL.  Readable specifier for a URI
 *
 * examples/app/scoped/css?scoped=true => examples_app_scoped_css_scoped=true
 */
export declare function prettyModuleUriSuffix(specifier: string): string;
/**
 * Create a partial Module Identifier from a specifier
 * The Module Identifier is partial because the specifier may not contain a version
 * This function is the opposite of 'getSpecifier()'
 * @param rawSpecifier
 */
interface PartialModuleId extends AbstractModuleId {
    name: string;
}
export declare function explodeSpecifier(rawSpecifier: string): PartialModuleId;
export declare function explodeSpecifiers(rawSpecifiers: string): PartialModuleId[];
/**
 * Create a specifier with a namespace (optional), name and version (optional)
 * @param param0 - namespace and name
 * @example - { specifier: 'c/form', namespace: 'c', name: 'form' } => 'c/form'
 * @example - { specifier: 'c/form', version: '5000' } => 'c/form/v/5000'
 * @example - { name: 'lwc' } => 'lwc'
 * @example - { namespace: 'c', name: 'app' } => 'c/app'
 * @example - { namespace: '@salesforce', name: 'label/my.label' } => '@salesforce/label/my.label'
 * @example - { name: 'lwc', version: '1.7' } => 'lwc/v/1.7'
 * @example - { namespace: 'c', name: 'navMenu', version: '2.0' } => 'c/navMenu/v/2.0'
 * @example - { namespace: '@salesforce', name: 'label/my.label', version: '1' } => '@salesforce/label/my.label/v/1'
 */
export declare function getSpecifier({ specifier, namespace, name, version }: ModuleIdentifierPartial): string;
/**
 * Create a versioned specifier based on the module registry
 *
 * @remarks
 * If the incoming specifier is already versioned, it will be returned as is.
 *
 * The returned specifier's version conforms to the format expected to be used
 * external to the framework (e.g. via the identity in the URL, mapping metadata,
 * AMD define module name). This format conforms to the `normalizeVersionToUri`
 * implementation (e.g. version semver format -- major_minor_patch).
 *
 * This method is analogous to `getSpecifier` but supports non-versioned `rawSpecifiers`
 * The inverse of this method is `explodeSpecifier`

 * @param specifier - the module specifier
 * @param moduleRegistry - the public module registry
 *
 * @returns the specifier for the latest version
 *
 * @example - 'c/form' => 'c/form/v/0_0_1'
 * @example - 'c/form/v/0.0.2' => 'c/form/v/0_0_2'
 */
export declare function getVersionedSpecifier(rawSpecifier: string, moduleRegistry: PublicModuleRegistry): Promise<string>;
/**
 * Create a AbstractModuleId using the module registry to resolve the version
 * if a version is not provided in the `rawSpecifier`
 *
 * The returned ModuleId properties (specifically version) conforms to the format
 * expected by Module registry (e.g. version semver format -- major.minor.patch)
 *
 * @remarks
 * If the incoming specifier is already versioned, the version value will be normalized
 * to semver format.
 *
 * @param specifier - the module specifier
 * @param moduleRegistry - the public module registry
 *
 * @returns the specifier for the latest version
 *
 * @example - 'c/form' => {specifier: "c/form", version: "0.0.1"}
 * @example - 'c/form/v/0.0.2' => {specifier: "c/form", version: "0.0.2"}
 * @example - 'c/form/v/0_0_2' => {specifier: "c/form", version: "0.0.2"}
 */
export declare function getVersionedModuleId(rawSpecifier: string, moduleRegistry: PublicModuleRegistry): Promise<Required<Pick<ModuleId, 'specifier' | 'version'>>>;
interface PackageIdentity {
    scope?: string;
    packageName: string;
    subResource: string;
}
/**
 * Parses an npm-style specifier
 * modified from https://github.com/egoist/parse-package-name#readme
 *
 * @param specifier - String to parse
 *
 * @example "@angular/core" => { scope: "@angular", packageName: "@angular/core", subResource: "" }
 * @example "@lwr/core/some/path" => { scope: "@lwr", packageName: "@lwr/core", subResource: "some/path" }
 * @example "my/app" => { packageName: "my", subResource: "app" }
 * @example "my/app/utils" => { packageName: "my", subResource: "app/utils" }
 * @example "lwc" => { packageName: "lwc", subResource: "" }
 */
export declare function parsePackageSpecifier(specifier: string): PackageIdentity;
/**
 * Turn a string from kebab case to "specifier case": namespace/camelCaseName
 * @param name A string in kebab case
 * @example - 'name-of-something' => 'name/ofSomething'
 */
export declare function kebabCaseToModuleSpecifer(name: string): string;
/**
 * Clone of lwr/init, reverse of kebabCaseToModuleSpecifer, strips off versions
 * @param specifier
 * @example - 'name/ofSomething/v/1.0.0' => 'name-of-something'
 */
export declare function moduleSpecifierToKebabCase(specifier: string): string;
/**
 * Turn a string into a slug
 * @param name a string to slugify
 * @example - 'This IS a sentence' => 'this-is-a-sentence'
 */
export declare function slugify(name: string): string;
/**
 * Turn an html attribute into a LWC property, eg: 'best-property-ever' => 'bestPropertyEver'
 * @param propName - a string in kebab case (lowercase)
 * @returns - a string in camel case
 */
export declare function getPropFromAttrName(propName: string): string;
/**
 * Create a module URI prefix, stopping where the specifier would be (at "mi/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export declare function getModuleUriPrefix({ apiVersion, bundle, format, compat, basePath }: RuntimeEnvironment, { locale, environment }?: RuntimeParams): string;
/**
 * Create a URI Mapping API URI prefix, stopping where the specifiers would be (at "mp/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export declare function getMappingUriPrefix({ apiVersion, bundle, format, compat, basePath }: RuntimeEnvironment, { locale, environment }?: RuntimeParams): string;
export { getCacheKeyFromJson };
export declare function isExternalUrl(url: string): boolean;
export declare function isBundleDefinition(definition: ModuleDefinition | BundleDefinition): definition is BundleDefinition;
export declare function getModuleIdentity(req: MiddlewareRequest): ModuleIdentity;
export declare function getMappingIdentity(req: MiddlewareRequest): MappingIdentity;
export declare function getResourceIdentity(req: MiddlewareRequest): ResourceIdentity;
export declare function getAssetIdentity(req: MiddlewareRequest): AssetIdentity;
//# sourceMappingURL=identity.d.ts.map