import { InterchangeableModuleRecord, LwcConfig, ResolverModuleRecord, InterchangeableModuleMap } from '@lwrjs/types';
/**
 * Traverses LWC configurations to find all possible interchangeable modules
 *
 * Modules are NOT compiled to resolve nested dependencies.  Package dependencies are
 *  checked recursively to find nested interchangeable modules.
 *
 * @param {array} modules - LWC module records
 * @param {map} interchangeableModules -
 *  interchangeable specifier -> context -> alternate implementation specifier
 * @returns {map} a map of all possible interchangeable modules
 *
 */
export declare function discoverInterchangeableModules(modules: ResolverModuleRecord[], interchangeableModules?: InterchangeableModuleMap): InterchangeableModuleMap;
/**
 * Locate the LWC config for the package and resolve custom properties
 *
 * Interchangeable modules are resolvable based on two custom properties:
 *  - interchangeable: An array of interchangeable modules provided by the package
 *  - interchangeableModules: An array of contextual module overrides
 *
 * @param {string} dir - package directory for lwc modules
 * @returns interchangeable module metadata for the package
 */
export declare function resolveCustomLWCMetadata(dir: string): Pick<LwcConfig, 'interchangeable' | 'interchangeableModules'>;
/**
 * Convert interchangeable module records to map:
 *  interchangeable specifier -> context -> alternate implementation specifier
 *
 * Throws an error if the config contains more than one implementation for the same context
 *
 * @param records - interchangeable module records
 * @param interchangeableModules - an existing map of interchangeable modules to add to
 * @returns normalized map of interchangeable modules
 */
export declare function normalizeInterchangeableModuleConfig(records: InterchangeableModuleRecord[], interchangeableModules?: InterchangeableModuleMap): InterchangeableModuleMap;
//# sourceMappingURL=interchangeable-modules.d.ts.map