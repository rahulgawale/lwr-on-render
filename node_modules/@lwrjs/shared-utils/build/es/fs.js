import fs from 'fs';
import pathLib from 'path';
import crypto from 'crypto';
import { slugify } from './identity.js';
import { debounce } from './object.js';
import chokidar from 'chokidar';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { lookup } from 'mime-types';
import { logger } from './logger.js';
/**
 * Create a hash string for a source
 * @param source
 */
export function hashContent(source) {
    return crypto.createHash('md5').update(source).digest('hex');
}
/**
 * Read in the contents of the file path
 * @param filePath
 */
export function readFile(filePath) {
    return fs.readFileSync(filePath, 'utf8');
}
/**
 * Given a filepath, ensure it has a file extension by checking for the file on the fs
 * @param filePath
 */
export function resolveFileExtension(filePath) {
    const fileName = pathLib.basename(filePath);
    const hasExt = !!pathLib.extname(fileName);
    // If it has extension just return it
    if (hasExt) {
        return filePath;
    }
    // No extension, if it exist, it can be a dir or a file
    if (fs.existsSync(filePath)) {
        if (fs.statSync(filePath).isFile()) {
            return filePath; // extensionless file, which is odd but...
        }
        else {
            filePath = pathLib.join(filePath, 'index'); // if is a dir we will be tesing the extensions
        }
    }
    // At this point we have a file with no extension so we try for the default (js,ts) or fail
    if (fs.existsSync(filePath + '.js')) {
        return filePath + '.js';
    }
    else if (fs.existsSync(filePath + '.ts')) {
        return filePath + '.ts';
    }
    else {
        throw new Error(`Unable to find file "${filePath}"`);
    }
}
/**
 * Set up a watcher with the given options
 * @param options
 */
export function createFileWatcher(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
options = { persistent: true, ignored: '**/node_modules/**' }) {
    return chokidar.watch([], options);
}
/**
 * Set up file watcher
 */
export function setupWatcher(onModuleChange) {
    const fileWatcher = createFileWatcher();
    fileWatcher.on('change', debounce((file) => onModuleChange(file), 500));
    fileWatcher.on('unlink', debounce((file) => onModuleChange(file), 500));
    fileWatcher.on('add', (file) => logger.info(`Watching: ${file}`));
    return fileWatcher;
}
/**
 * Returns if view of specific type can be resolved
 *
 * @param source - path to view
 * @param type - extension of file that should be expected, i.e. 'html'
 */
export function canResolveView(source, type) {
    if (!source.endsWith(`.${type}`)) {
        return false;
    }
    if (!fs.existsSync(pathLib.resolve(source))) {
        throw new Error(`View template cannot be found: "${source}"`);
    }
    return true;
}
/**
 * Construct a ViewSource from the associated file on the fs
 * @param source - Filepath with the source (source can be an absolute or relative path)
 * @param viewFolder - File in the fs which holds the view
 */
export function getViewSourceFromFile(source) {
    const sourceFilePath = pathLib.resolve(source);
    const viewSource = readFile(sourceFilePath);
    const ext = pathLib.extname(sourceFilePath);
    const name = pathLib.basename(sourceFilePath, ext);
    return {
        name,
        slug: slugify(name),
        filePath: sourceFilePath,
        ownHash: hashContent(viewSource),
        originalSource: viewSource,
    };
}
/**
 * Replace all instances of `$rootDir` with `rootDir`
 * @param dir
 * @param rootDir
 */
const ROOT_DIR_REGEX = /\$rootDir/g;
export function normalizeDirectory(dir, rootDir) {
    return dir.replace(ROOT_DIR_REGEX, rootDir);
}
/**
 * Replace all instances of `$*Dir` with `resourcePaths.*Dir`
 * @param rawPath
 * @param param1 - root directories
 */
const RESOURCE_DIR_REGEX = /\$(\w+)|^\$(\w+)/g;
export function normalizeResourcePath(rawPath, { rootDir, assets, contentDir, layoutsDir }, allowUnresolvedAlias) {
    const assetsMap = assets.reduce((map, asset) => {
        if (asset.alias) {
            // Asset config has either a "dir" OR a "file"
            map[asset.alias] = asset.dir || asset.file;
        }
        return map;
    }, { rootDir, contentDir, layoutsDir });
    return rawPath.replace(RESOURCE_DIR_REGEX, function (fullMatch, m1, m2) {
        const alias = assetsMap[m1] || assetsMap[m2];
        if (!alias && !allowUnresolvedAlias) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.DIR_ALIAS(fullMatch),
            }, LwrUnresolvableError);
        }
        return alias;
    });
}
export { lookup as mimeLookup };
//# sourceMappingURL=fs.js.map