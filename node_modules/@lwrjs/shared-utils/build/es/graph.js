import { getSpecifier, getVersionedModuleId, isBundleDefinition } from './identity.js';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { ModuleNameType } from './import-metadata.js';
export var GraphDepth;
(function (GraphDepth) {
    GraphDepth["ALL"] = "all";
    GraphDepth["DIRECT"] = "direct";
    GraphDepth["NONE"] = "none";
})(GraphDepth || (GraphDepth = {}));
// type guard for ViewDef responses
function isBundler(registry) {
    return registry.getModuleBundle !== undefined;
}
async function traverse(module, depth, flattened, 
// based from 1; since its exposed
graphIdx, visited, 
// moduleRegistry: ModuleRegistry,
defRegistry, runtimeEnvironment, runtimeParams) {
    // const { bundle } = runtimeEnvironment;
    const { includeId: includeIdHook } = depth;
    const versionedSpecifier = getSpecifier(module);
    const { imports = [], dynamicImports = [] } = isBundleDefinition(module)
        ? module.bundleRecord
        : module.moduleRecord;
    // depth traversal
    const staticImports = imports.map((imp) => getSpecifier(imp));
    const dynamic = dynamicImports.map((imp) => getSpecifier(imp));
    // add the module to the visited list
    if (!visited.has(versionedSpecifier)) {
        visited.set(versionedSpecifier, { static: staticImports, dynamic });
    }
    // initialize the graph root if its the first module encountered
    if (!flattened[graphIdx]) {
        flattened.push({
            specifier: versionedSpecifier,
            static: [],
            dynamicRefs: dynamic,
        });
    }
    if (depth.static !== GraphDepth.NONE) {
        // traverse and flatten static imports
        for (const imp of imports) {
            const impSpecifier = getSpecifier(imp);
            // check the hook
            const shouldIncludeModule = includeIdHook ? includeIdHook(imp) : true;
            if (shouldIncludeModule) {
                // add it to the flattened graph
                if (!flattened[graphIdx].static.includes(impSpecifier)) {
                    flattened[graphIdx].static.push(impSpecifier);
                }
                if (depth.static === GraphDepth.ALL) {
                    if (visited.has(impSpecifier)) {
                        // eslint-disable-next-line no-await-in-loop
                        await flatten(impSpecifier, flattened, graphIdx, visited);
                    }
                    else {
                        const moduleDef = isBundler(defRegistry)
                            ? // eslint-disable-next-line no-await-in-loop
                                await defRegistry.getModuleBundle(imp, runtimeEnvironment, runtimeParams)
                            : // eslint-disable-next-line no-await-in-loop
                                await defRegistry.getModule(imp, runtimeParams);
                        // eslint-disable-next-line no-await-in-loop
                        await traverse(moduleDef, depth, flattened, graphIdx, visited, defRegistry, runtimeEnvironment, runtimeParams);
                    }
                }
            }
        }
    }
    // traverse and flatten dynamic imports based on depth
    for (const imp of dynamicImports) {
        if (imp.moduleNameType !== ModuleNameType.unresolved) {
            const impSpecifier = getSpecifier(imp);
            if (depth.dynamic > graphIdx) {
                if (!flattened[graphIdx].dynamicRefs.includes(impSpecifier)) {
                    flattened[graphIdx].dynamicRefs.push(impSpecifier);
                }
                if (visited.has(impSpecifier)) {
                    // flatten already known sub graphs
                    // eslint-disable-next-line no-await-in-loop
                    await flatten(impSpecifier, flattened, graphIdx + 1, visited);
                }
                else {
                    const moduleDef = isBundler(defRegistry)
                        ? // eslint-disable-next-line no-await-in-loop
                            await defRegistry.getModuleBundle(imp, runtimeEnvironment, runtimeParams)
                        : // eslint-disable-next-line no-await-in-loop
                            await defRegistry.getModule(imp, runtimeParams);
                    // eslint-disable-next-line no-await-in-loop
                    await traverse(moduleDef, depth, flattened, graphIdx + 1, visited, defRegistry, runtimeEnvironment, runtimeParams);
                }
            }
        }
    }
}
async function flatten(versionedSpecifier, flattened, idx, visited) {
    const node = visited.get(versionedSpecifier);
    if (node) {
        node.static.forEach(async (imp) => {
            if (!flattened[idx].static.includes(imp)) {
                flattened[idx].static.push(imp);
                await flatten(imp, flattened, idx, visited);
            }
        });
    }
}
/* Return the collection of modules and their related properties for graph of a module's dependencies */
export async function getModuleGraphs(specifier, // version | un-versioned specifiers
options, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visited) {
    const acc = visited || new Map();
    // normalize the specifier
    const versionedModuleId = await getVersionedModuleId(specifier, moduleRegistry);
    const depth = options.depth || {
        static: GraphDepth.DIRECT,
        dynamic: 1,
    };
    const moduleDef = isBundler(defRegistry)
        ? await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams)
        : await defRegistry.getModule(versionedModuleId, runtimeParams);
    if (!moduleDef) {
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.MODULE_ENTRY(versionedModuleId.specifier),
        }, LwrUnresolvableError);
    }
    const flattened = [];
    await traverse(moduleDef, depth, flattened, 0, acc, defRegistry, runtimeEnvironment, runtimeParams);
    const uriMap = {};
    if (options.includeUris) {
        for (const visitedSpecifier of acc.keys()) {
            // eslint-disable-next-line no-await-in-loop
            const moduleId = await getVersionedModuleId(visitedSpecifier, moduleRegistry);
            // eslint-disable-next-line no-await-in-loop
            const uri = await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
            uriMap[visitedSpecifier] = uri;
        }
    }
    const linkedDefinitions = {};
    if (options.includeLinkedDefinitions) {
        for (const visitedSpecifier of acc.keys()) {
            // eslint-disable-next-line no-await-in-loop
            const versionedModuleId = await getVersionedModuleId(visitedSpecifier, moduleRegistry);
            const module = isBundler(defRegistry)
                ? // eslint-disable-next-line no-await-in-loop
                    await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams)
                : // eslint-disable-next-line no-await-in-loop
                    await defRegistry.getLinkedModule(versionedModuleId, runtimeEnvironment, runtimeParams);
            linkedDefinitions[visitedSpecifier] = module;
        }
    }
    return {
        graphs: flattened,
        uriMap,
        linkedDefinitions,
    };
}
//# sourceMappingURL=graph.js.map