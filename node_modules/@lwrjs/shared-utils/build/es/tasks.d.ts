/**
 * A pool is created of a given size
 * If more tasks than that are asked to execute they are put in a queue until there is space in the pool
 */
export declare class TaskPool {
    private size;
    private queue;
    private running;
    constructor(size?: number);
    /**
     * Add a function that takes no arguments
     * It will run as soon as there is room in the pool
     *
     * @param taskFunction - Function to run when there is space in the pool
     * @param caller - The closer to use when calling the constructor
     **/
    execute(taskFunction: Function, caller?: any): Promise<any>;
    private start;
    private runNext;
}
/**
 * Contains a map of tasks that are in progress
 * Calls to execute with the id of a task in progress returns the running tasks
 * If no task of that id is running a new task is created
 */
export declare class InflightTasks<Value> {
    private tasks;
    /**
     * Return a promise per id.  If one is already in flight return the promise.
     * If not use the constructor to create a new
     *
     * @param id - Unique id for promise in question
     * @param fn - Function that create a promise for the id if needed
     */
    execute(id: string, fn: () => Promise<Value>): Promise<Value>;
}
//# sourceMappingURL=tasks.d.ts.map