import fs from 'fs';
import path from 'path';
import resolve from 'resolve';
import { readFile } from './fs.js';
const CONFIG_FILES = ['package.json', 'lwc.config.json', 'lwr.config.json'];
class NoLwcModuleError extends Error {
    constructor() {
        super('No LWC module found');
        this.code = 'NO_LWC_MODULE_FOUND';
    }
}
function isNpmModuleRecord(module) {
    return module.npm !== undefined;
}
/**
 * Traverses LWC configurations to find all possible interchangeable modules
 *
 * Modules are NOT compiled to resolve nested dependencies.  Package dependencies are
 *  checked recursively to find nested interchangeable modules.
 *
 * @param {array} modules - LWC module records
 * @param {map} interchangeableModules -
 *  interchangeable specifier -> context -> alternate implementation specifier
 * @returns {map} a map of all possible interchangeable modules
 *
 */
export function discoverInterchangeableModules(modules, interchangeableModules) {
    if (!interchangeableModules) {
        interchangeableModules = new Map();
    }
    if (modules.length === 0) {
        return interchangeableModules;
    }
    const nestedModules = [];
    for (const module of modules) {
        // skip non-npm module records
        if (!isNpmModuleRecord(module)) {
            continue;
        }
        // resolve module path and package.json
        const packageJsonPath = resolve.sync(`${module.npm}/package.json`);
        const packageJson = JSON.parse(readFile(packageJsonPath));
        let lwcConfig = packageJson.lwc;
        // load lwc.config.json if package.json does not contain lwc configuration
        if (!lwcConfig) {
            const lwcConfigPath = path.join(path.dirname(packageJsonPath), 'lwc.config.json');
            lwcConfig = JSON.parse(readFile(lwcConfigPath));
        }
        // track nested modules
        if (lwcConfig?.modules?.length) {
            nestedModules.push(...lwcConfig.modules);
        }
        // normalize interchangeable module configurations
        if (lwcConfig?.interchangeableModules) {
            interchangeableModules = normalizeInterchangeableModuleConfig(lwcConfig.interchangeableModules, interchangeableModules);
        }
    }
    return discoverInterchangeableModules(nestedModules, interchangeableModules);
}
/**
 * Locate the LWC config for the package and resolve custom properties
 *
 * Interchangeable modules are resolvable based on two custom properties:
 *  - interchangeable: An array of interchangeable modules provided by the package
 *  - interchangeableModules: An array of contextual module overrides
 *
 * @param {string} dir - package directory for lwc modules
 * @returns interchangeable module metadata for the package
 */
export function resolveCustomLWCMetadata(dir) {
    for (const configFile of CONFIG_FILES) {
        const configPath = path.join(dir, configFile);
        if (fs.existsSync(configPath)) {
            let metadata = JSON.parse(readFile(configPath));
            // step into the lwc config for package.json or lwr.config.json
            if (metadata.lwc) {
                metadata = metadata.lwc;
            }
            // look for the next config file if modules property is not found
            if (!metadata.modules) {
                continue;
            }
            const { interchangeable, interchangeableModules } = metadata;
            return {
                interchangeable,
                interchangeableModules,
            };
        }
    }
    throw new NoLwcModuleError();
}
/**
 * Convert interchangeable module records to map:
 *  interchangeable specifier -> context -> alternate implementation specifier
 *
 * Throws an error if the config contains more than one implementation for the same context
 *
 * @param records - interchangeable module records
 * @param interchangeableModules - an existing map of interchangeable modules to add to
 * @returns normalized map of interchangeable modules
 */
export function normalizeInterchangeableModuleConfig(records, interchangeableModules) {
    return records.reduce((interchangeableModules, record) => {
        for (const [target, override] of Object.entries(record.modules)) {
            const contextMap = interchangeableModules.get(target) || new Map();
            // interchangeable modules should not have more than one alternate implementation for the same context
            if (contextMap.has(record.context)) {
                throw `Multiple implementations found for "${target}" in the "${record.context}" context`;
            }
            contextMap.set(record.context, override);
            interchangeableModules.set(target, contextMap);
        }
        return interchangeableModules;
    }, interchangeableModules || new Map());
}
//# sourceMappingURL=interchangeable-modules.js.map