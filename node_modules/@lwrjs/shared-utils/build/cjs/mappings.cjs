var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/mappings.ts
__markAsModule(exports);
__export(exports, {
  getImportMetadataMappings: () => getImportMetadataMappings,
  toImportMetadata: () => toImportMetadata
});
var import_graph = __toModule(require("./graph.cjs"));
var import_identity = __toModule(require("./identity.cjs"));
async function getImportMetadataMappings(moduleIds, runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler) {
  const visitedCache = new Map();
  let importMetadata = {
    imports: {},
    index: {}
  };
  for (const moduleId of moduleIds) {
    const requestedSpecifier = (0, import_identity.getSpecifier)(moduleId);
    const specifier = await getVersionedSpecifier(moduleId, moduleRegistry);
    if (!visitedCache.has(specifier)) {
      const depth = {
        static: runtimeEnvironment.format === "esm" ? import_graph.GraphDepth.NONE : import_graph.GraphDepth.ALL,
        dynamic: runtimeEnvironment.format === "esm" ? 1 : 0
      };
      const moduleGraph = await (0, import_graph.getModuleGraphs)(specifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, runtimeEnvironment.bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams, visitedCache);
      importMetadata = await toImportMetadata(moduleGraph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
    if (requestedSpecifier !== specifier) {
      const requestedSpecifierPlusImporter = `${requestedSpecifier}?importer=${moduleId.importer}`;
      const specifiersArray = Object.values(importMetadata.imports).find((a) => a.includes(specifier));
      if (!specifiersArray) {
        throw new Error("Could not find: " + specifier + " in " + JSON.stringify(importMetadata.imports));
      }
      specifiersArray.push(requestedSpecifierPlusImporter);
    }
  }
  return importMetadata;
}
async function toImportMetadata(moduleGraph, existingImportMetadata = {imports: {}, index: {}}, moduleRegistry, runtimeEnvironment, runtimeParams = {}) {
  const specifier = moduleGraph.graphs[0].specifier;
  const uri = moduleGraph.uriMap[specifier];
  const definition = moduleGraph.linkedDefinitions[specifier];
  if (!uri) {
    throw new Error("URI was not included in the graph: " + specifier);
  }
  if (!definition) {
    throw new Error("Linked module definition was not included in the graph: " + specifier);
  }
  const rootMetadata = await normalizeImportMetadata(specifier, uri, definition, moduleRegistry, runtimeEnvironment, runtimeParams);
  let importMetadata = mergeImportMetadata(existingImportMetadata, rootMetadata);
  const depSpecifiers = runtimeEnvironment.format === "esm" ? moduleGraph.graphs[0].dynamicRefs : moduleGraph.graphs[0].static;
  for (const depSpecifier of depSpecifiers) {
    const depUri = moduleGraph.uriMap[depSpecifier];
    const depDef = moduleGraph.linkedDefinitions[depSpecifier];
    const depMissing = !depUri || !depDef;
    if (depMissing && runtimeEnvironment.format !== "esm") {
      if (!depUri) {
        throw new Error("URI was not included in the graph for dependent: " + depSpecifier);
      }
      if (!depDef) {
        throw new Error("Linked dependent module definition was not included in the graph: " + depSpecifier);
      }
    } else if (depMissing) {
      continue;
    }
    if (!importMetadata.imports[depUri]) {
      const depMetadata = await normalizeImportMetadata((0, import_identity.getSpecifier)(depDef), depUri, depDef, moduleRegistry, runtimeEnvironment, runtimeParams);
      importMetadata = mergeImportMetadata(importMetadata, depMetadata);
    }
  }
  return importMetadata;
}
function mergeImportMetadata(existing, newMetadata) {
  return {
    imports: {
      ...existing.imports,
      ...newMetadata.imports
    },
    index: {
      ...existing.index,
      ...newMetadata.index
    }
  };
}
async function normalizeImportMetadata(specifier, uri, definition, moduleRegistry, moduleRuntimeEnvironment, runtimeParams) {
  const specifiers = normalizedIncludedModules(definition);
  const imports = {};
  imports[uri] = specifiers;
  const index = await createIndex(specifiers, moduleRegistry, moduleRuntimeEnvironment, runtimeParams);
  if (!(specifier in index)) {
    index[specifier] = uri;
  }
  return {
    imports,
    index
  };
}
function normalizedIncludedModules(definition) {
  return (0, import_identity.isBundleDefinition)(definition) ? [(0, import_identity.getSpecifier)(definition), ...definition.bundleRecord.includedModules] : [(0, import_identity.getSpecifier)(definition)];
}
async function createIndex(specifiers, moduleRegistry, runtimeEnvironment, runtimeParams) {
  const index = {};
  const moduleRuntimeEnvironment = {...runtimeEnvironment, bundle: false};
  async function getUri(specifier) {
    const moduleId = (0, import_identity.explodeSpecifier)(specifier);
    if (!moduleId.version) {
      throw new Error("Module specifier must include a version: " + specifier);
    }
    index[specifier] = await moduleRegistry.resolveModuleUri({...moduleId, version: moduleId.version}, moduleRuntimeEnvironment, runtimeParams);
  }
  const promises = [];
  for (const specifier of specifiers) {
    promises.push(getUri(specifier));
  }
  await Promise.all(promises);
  return index;
}
async function getVersionedSpecifier(moduleId, moduleRegistry) {
  if (!moduleId.importer || moduleId.version) {
    return (0, import_identity.getSpecifier)(moduleId);
  }
  const versionedModuleEntry = await moduleRegistry.getModuleEntry({
    ...moduleId
  });
  return (0, import_identity.getSpecifier)(versionedModuleEntry);
}
