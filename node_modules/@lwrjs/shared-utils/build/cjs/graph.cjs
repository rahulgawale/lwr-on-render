var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/graph.ts
__markAsModule(exports);
__export(exports, {
  GraphDepth: () => GraphDepth,
  getModuleGraphs: () => getModuleGraphs
});
var import_identity = __toModule(require("./identity.cjs"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_import_metadata = __toModule(require("./import-metadata.cjs"));
var GraphDepth;
(function(GraphDepth2) {
  GraphDepth2["ALL"] = "all";
  GraphDepth2["DIRECT"] = "direct";
  GraphDepth2["NONE"] = "none";
})(GraphDepth || (GraphDepth = {}));
function isBundler(registry) {
  return registry.getModuleBundle !== void 0;
}
async function traverse(module2, depth, flattened, graphIdx, visited, defRegistry, runtimeEnvironment, runtimeParams) {
  const {includeId: includeIdHook} = depth;
  const versionedSpecifier = (0, import_identity.getSpecifier)(module2);
  const {imports = [], dynamicImports = []} = (0, import_identity.isBundleDefinition)(module2) ? module2.bundleRecord : module2.moduleRecord;
  const staticImports = imports.map((imp) => (0, import_identity.getSpecifier)(imp));
  const dynamic = dynamicImports.map((imp) => (0, import_identity.getSpecifier)(imp));
  if (!visited.has(versionedSpecifier)) {
    visited.set(versionedSpecifier, {static: staticImports, dynamic});
  }
  if (!flattened[graphIdx]) {
    flattened.push({
      specifier: versionedSpecifier,
      static: [],
      dynamicRefs: dynamic
    });
  }
  if (depth.static !== GraphDepth.NONE) {
    for (const imp of imports) {
      const impSpecifier = (0, import_identity.getSpecifier)(imp);
      const shouldIncludeModule = includeIdHook ? includeIdHook(imp) : true;
      if (shouldIncludeModule) {
        if (!flattened[graphIdx].static.includes(impSpecifier)) {
          flattened[graphIdx].static.push(impSpecifier);
        }
        if (depth.static === GraphDepth.ALL) {
          if (visited.has(impSpecifier)) {
            await flatten(impSpecifier, flattened, graphIdx, visited);
          } else {
            const moduleDef = isBundler(defRegistry) ? await defRegistry.getModuleBundle(imp, runtimeEnvironment, runtimeParams) : await defRegistry.getModule(imp, runtimeParams);
            await traverse(moduleDef, depth, flattened, graphIdx, visited, defRegistry, runtimeEnvironment, runtimeParams);
          }
        }
      }
    }
  }
  for (const imp of dynamicImports) {
    if (imp.moduleNameType !== import_import_metadata.ModuleNameType.unresolved) {
      const impSpecifier = (0, import_identity.getSpecifier)(imp);
      if (depth.dynamic > graphIdx) {
        if (!flattened[graphIdx].dynamicRefs.includes(impSpecifier)) {
          flattened[graphIdx].dynamicRefs.push(impSpecifier);
        }
        if (visited.has(impSpecifier)) {
          await flatten(impSpecifier, flattened, graphIdx + 1, visited);
        } else {
          const moduleDef = isBundler(defRegistry) ? await defRegistry.getModuleBundle(imp, runtimeEnvironment, runtimeParams) : await defRegistry.getModule(imp, runtimeParams);
          await traverse(moduleDef, depth, flattened, graphIdx + 1, visited, defRegistry, runtimeEnvironment, runtimeParams);
        }
      }
    }
  }
}
async function flatten(versionedSpecifier, flattened, idx, visited) {
  const node = visited.get(versionedSpecifier);
  if (node) {
    node.static.forEach(async (imp) => {
      if (!flattened[idx].static.includes(imp)) {
        flattened[idx].static.push(imp);
        await flatten(imp, flattened, idx, visited);
      }
    });
  }
}
async function getModuleGraphs(specifier, options, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visited) {
  const acc = visited || new Map();
  const versionedModuleId = await (0, import_identity.getVersionedModuleId)(specifier, moduleRegistry);
  const depth = options.depth || {
    static: GraphDepth.DIRECT,
    dynamic: 1
  };
  const moduleDef = isBundler(defRegistry) ? await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams) : await defRegistry.getModule(versionedModuleId, runtimeParams);
  if (!moduleDef) {
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.MODULE_ENTRY(versionedModuleId.specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  const flattened = [];
  await traverse(moduleDef, depth, flattened, 0, acc, defRegistry, runtimeEnvironment, runtimeParams);
  const uriMap = {};
  if (options.includeUris) {
    for (const visitedSpecifier of acc.keys()) {
      const moduleId = await (0, import_identity.getVersionedModuleId)(visitedSpecifier, moduleRegistry);
      const uri = await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
      uriMap[visitedSpecifier] = uri;
    }
  }
  const linkedDefinitions = {};
  if (options.includeLinkedDefinitions) {
    for (const visitedSpecifier of acc.keys()) {
      const versionedModuleId2 = await (0, import_identity.getVersionedModuleId)(visitedSpecifier, moduleRegistry);
      const module2 = isBundler(defRegistry) ? await defRegistry.getModuleBundle(versionedModuleId2, runtimeEnvironment, runtimeParams) : await defRegistry.getLinkedModule(versionedModuleId2, runtimeEnvironment, runtimeParams);
      linkedDefinitions[visitedSpecifier] = module2;
    }
  }
  return {
    graphs: flattened,
    uriMap,
    linkedDefinitions
  };
}
