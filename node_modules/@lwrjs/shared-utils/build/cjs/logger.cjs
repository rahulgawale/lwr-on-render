var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/logger.ts
__markAsModule(exports);
__export(exports, {
  DEBUG: () => DEBUG,
  ERROR: () => ERROR,
  INFO: () => INFO,
  VERBOSE: () => VERBOSE,
  WARN: () => WARN,
  logger: () => logger,
  stringifyError: () => stringifyError
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var VERBOSE = "verbose";
var DEBUG = "debug";
var INFO = "info";
var WARN = "warn";
var ERROR = "error";
var options = {};
var DUPES = new Set();
var currentLevel = process.env.LOG_LEVEL || INFO;
function log(level, message, additionalInfo) {
  const LOG_LEVEL = process.env.LOG_LEVEL || INFO;
  if (currentLevel !== LOG_LEVEL) {
    currentLevel = LOG_LEVEL;
    console.log(`LOG_LEVEL: ${LOG_LEVEL}`);
  }
  let shouldLog = false;
  switch (level) {
    case VERBOSE:
      shouldLog = LOG_LEVEL == VERBOSE;
      break;
    case DEBUG:
      shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG;
      break;
    case INFO:
      shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO;
      break;
    case WARN:
      shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO || LOG_LEVEL == WARN;
      break;
    case ERROR:
      shouldLog = true;
      break;
  }
  if (shouldLog && options.dedupe && options.dedupe.has(level)) {
    const key = `[${level}] : ${message}`;
    if (DUPES.has(key)) {
      shouldLog = false;
    } else {
      DUPES.add(key);
    }
  }
  if (shouldLog) {
    let logMethod;
    if (level == ERROR) {
      logMethod = console.error;
    } else if (level == WARN) {
      logMethod = console.warn;
    } else {
      logMethod = console.log;
    }
    if (additionalInfo) {
      logMethod(`[${level}] ${message} 
Additional Info: ${JSON.stringify(additionalInfo)}`);
    } else {
      logMethod(`[${level}] ${message}`);
    }
  }
}
var stringifyError = (error) => {
  if (error instanceof import_diagnostics.DiagnosticsError) {
    return JSON.stringify({
      message: error.message,
      diagnostics: error.diagnostics,
      stack: error.stack
    });
  } else if (typeof error === "string" || error instanceof String) {
    return error;
  } else {
    const propertyNames = Object.getOwnPropertyNames(error);
    const retObj = {};
    for (let property, i = 0, len = propertyNames.length; i < len; ++i) {
      property = propertyNames[i];
      const descriptor = Object.getOwnPropertyDescriptor(error, property);
      retObj[property] = descriptor?.value;
    }
    return JSON.stringify(retObj);
  }
};
var logger = {
  verbose: (message, additionalInfo) => log(VERBOSE, message, additionalInfo),
  debug: (message, additionalInfo) => log(DEBUG, message, additionalInfo),
  info: (message, additionalInfo) => log(INFO, message, additionalInfo),
  warn: (message, additionalInfo) => log(WARN, message, additionalInfo),
  error: (error, additionalInfo) => log(ERROR, stringifyError(error), additionalInfo),
  log,
  setOptions: (opts) => {
    options = opts;
  },
  currentLevel
};
