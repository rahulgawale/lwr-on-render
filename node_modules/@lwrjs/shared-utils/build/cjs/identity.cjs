var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/identity.ts
__markAsModule(exports);
__export(exports, {
  ASSETS_CACHE_DIR: () => ASSETS_CACHE_DIR,
  BUNDLE_SIGIL: () => BUNDLE_SIGIL,
  DEFAULT_LOCKER_TRUSTED_CMP: () => DEFAULT_LOCKER_TRUSTED_CMP,
  DEFAULT_LWR_BOOTSTRAP_CONFIG: () => DEFAULT_LWR_BOOTSTRAP_CONFIG,
  DEFAULT_LWR_LOCKER_CONFIG: () => DEFAULT_LWR_LOCKER_CONFIG,
  DEFAULT_TITLE: () => DEFAULT_TITLE,
  ENVIRONMENT_SIGIL: () => ENVIRONMENT_SIGIL,
  IMMUTABLE_ASSET_PREFIX: () => IMMUTABLE_ASSET_PREFIX,
  LATEST_SIGNATURE: () => LATEST_SIGNATURE,
  LOCALE_SIGIL: () => LOCALE_SIGIL,
  VERSION_SIGIL: () => VERSION_SIGIL,
  explodeSpecifier: () => explodeSpecifier,
  explodeSpecifiers: () => explodeSpecifiers,
  getAssetIdentity: () => getAssetIdentity,
  getCacheKeyFromJson: () => import_fast_json_stable_stringify.default,
  getMappingIdentity: () => getMappingIdentity,
  getMappingUriPrefix: () => getMappingUriPrefix,
  getModuleIdentity: () => getModuleIdentity,
  getModuleUriPrefix: () => getModuleUriPrefix,
  getPropFromAttrName: () => getPropFromAttrName,
  getResourceIdentity: () => getResourceIdentity,
  getSpecifier: () => getSpecifier,
  getVersionedModuleId: () => getVersionedModuleId,
  getVersionedSpecifier: () => getVersionedSpecifier,
  isBundleDefinition: () => isBundleDefinition,
  isExternalUrl: () => isExternalUrl,
  kebabCaseToModuleSpecifer: () => kebabCaseToModuleSpecifer,
  moduleSpecifierToKebabCase: () => moduleSpecifierToKebabCase,
  normalizeVersionFromUri: () => normalizeVersionFromUri,
  normalizeVersionToUri: () => normalizeVersionToUri,
  parsePackageSpecifier: () => parsePackageSpecifier,
  prettyModuleUriSuffix: () => prettyModuleUriSuffix,
  slugify: () => slugify
});
var import_slugify = __toModule(require("slugify"));
var import_fast_json_stable_stringify = __toModule(require("fast-json-stable-stringify"));
var VERSION_SIGIL = "/v/";
var LOCALE_SIGIL = "l";
var ENVIRONMENT_SIGIL = "e";
var BUNDLE_SIGIL = "bi";
var LATEST_SIGNATURE = "latest";
var DEFAULT_TITLE = "LWR App";
var IMMUTABLE_ASSET_PREFIX = "/_immutable/";
var ASSETS_CACHE_DIR = "assetsCache";
var DEFAULT_LOCKER_TRUSTED_CMP = ["@locker/*", "lwr/*", "@lwrjs/*", "lwc", "@lwc/*"];
var DEFAULT_LWR_LOCKER_CONFIG = {
  enabled: false,
  trustedComponents: DEFAULT_LOCKER_TRUSTED_CMP
};
var DEFAULT_LWR_BOOTSTRAP_CONFIG = {
  autoBoot: true,
  syntheticShadow: false,
  workers: {},
  services: [],
  configAsSrc: false,
  ssr: false
};
function normalizeVersionToUri(version) {
  return version.replace(/\./g, "_");
}
function normalizeVersionFromUri(version) {
  return version.replace(/_/g, ".");
}
function prettyModuleUriSuffix(specifier) {
  return `${specifier.replace(/[\/\.\?\#]/g, "_")}`;
}
function explodeSpecifier(rawSpecifier) {
  const decodedSpecifier = decodeURIComponent(rawSpecifier);
  const versionMatch = decodedSpecifier.match(/(.+)\/v\/([a-zA-Z0-9-_.]+)$/);
  const version = versionMatch ? versionMatch[2] : void 0;
  const importee = versionMatch ? versionMatch[1] : decodedSpecifier;
  const [rawNamespace, rawName, ...remaining] = importee.split("/");
  const namespace = rawName ? rawNamespace : void 0;
  const name = rawName ? [rawName, ...remaining].join("/") : rawNamespace;
  return {
    specifier: importee,
    namespace,
    name,
    version: version ? normalizeVersionFromUri(version) : version
  };
}
function explodeSpecifiers(rawSpecifiers) {
  const exploder = explodeSpecifier;
  if (!rawSpecifiers) {
    return [];
  }
  return rawSpecifiers.split(",").map(function(rawSpecifier) {
    return exploder(rawSpecifier);
  });
}
function getSpecifier({specifier, namespace, name = "", version}) {
  if (specifier) {
    const versionMatch = specifier.match(/(.+)\/v\/[a-zA-Z0-9-_.]+$/);
    specifier = versionMatch ? versionMatch[1] : specifier;
    return version ? `${specifier}${VERSION_SIGIL}${normalizeVersionToUri(version)}` : specifier;
  }
  const bareSpecifier = namespace ? `${namespace}/${name}` : name;
  return version ? `${bareSpecifier}${VERSION_SIGIL}${normalizeVersionToUri(version)}` : bareSpecifier;
}
async function getVersionedSpecifier(rawSpecifier, moduleRegistry) {
  const {specifier, namespace, name, version} = explodeSpecifier(rawSpecifier);
  if (version) {
    return normalizeVersionToUri(rawSpecifier);
  }
  const moduleEntry = await moduleRegistry.getModuleEntry({specifier});
  return getSpecifier({namespace, name, version: normalizeVersionToUri(moduleEntry.version)});
}
async function getVersionedModuleId(rawSpecifier, moduleRegistry) {
  const {specifier, version} = explodeSpecifier(rawSpecifier);
  if (version) {
    return {specifier, version: normalizeVersionFromUri(version)};
  }
  const moduleEntry = await moduleRegistry.getModuleEntry({specifier});
  return {specifier, version: moduleEntry.version};
}
var RE_SCOPED = /^(@[^/]+\/[^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
var RE_NORMAL = /^([^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
function parsePackageSpecifier(specifier) {
  const isScoped = specifier.charAt(0) === "@";
  const matched = isScoped ? specifier.match(RE_SCOPED) : specifier.match(RE_NORMAL);
  if (!matched) {
    throw new Error(`[parse-package-name] "${specifier}" is not a valid string`);
  }
  const scope = isScoped ? matched[1].split("/")[0] : void 0;
  if (isScoped) {
    return {
      scope,
      packageName: matched[1],
      subResource: matched[2] || ""
    };
  }
  return {
    packageName: matched[1],
    subResource: matched[2] || ""
  };
}
function kebabCaseToModuleSpecifer(name) {
  const newName = [];
  let nsFound = false;
  let upper = false;
  for (const currChar of name) {
    if (currChar === "-") {
      if (!nsFound) {
        nsFound = true;
        newName.push("/");
      } else {
        upper = true;
      }
    } else {
      newName.push(upper ? currChar.toUpperCase() : currChar);
      upper = false;
    }
  }
  return newName.join("");
}
function moduleSpecifierToKebabCase(specifier) {
  return specifier.replace(/\/v\/[a-zA-Z0-9-_.]+$/, "").replace("/", "-").replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
}
function slugify(name) {
  return (0, import_slugify.default)(name, {
    lower: true
  });
}
function getPropFromAttrName(propName) {
  return propName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
function getModuleUriPrefix({apiVersion, bundle, format, compat, basePath}, {locale, environment} = {}) {
  const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : "";
  const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : "";
  if (bundle) {
    return `${basePath}/${apiVersion}/bundle/${format}${localePart}${environmentPart}/${BUNDLE_SIGIL}/0/module/mi/`;
  } else {
    return `${basePath}/${apiVersion}/module/${format}/${compat}${localePart}${environmentPart}/mi/`;
  }
}
function getMappingUriPrefix({apiVersion, bundle, format, compat, basePath}, {locale, environment} = {}) {
  const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : "";
  const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : "";
  const bundlePart = bundle ? `/${BUNDLE_SIGIL}/0` : "";
  return `${basePath}/${apiVersion}/mapping/${format}/${compat}${localePart}${environmentPart}${bundlePart}/mp/`;
}
var REGEX_URL_SCHEMA_PREFIX = /^(https?|\/\/)/;
function isExternalUrl(url) {
  return REGEX_URL_SCHEMA_PREFIX.test(url);
}
function isBundleDefinition(definition) {
  return definition.bundleRecord !== void 0;
}
function validateSpecifier(specifer) {
  return specifer.indexOf("../") < 0;
}
function getModuleIdentity(req) {
  const {specifier, signature = LATEST_SIGNATURE} = req.params;
  if (validateSpecifier(specifier) === false) {
    throw new Error("dot-dot-slash is not allowed for module specifier");
  }
  const moduleId = explodeSpecifier(specifier);
  return {
    moduleId,
    signature
  };
}
function getMappingIdentity(req) {
  const {specifiers} = req.params;
  const moduleIds = explodeSpecifiers(specifiers).map((obj) => ({
    ...obj,
    importer: req.query.importer
  }));
  return {
    moduleIds
  };
}
function getResourceIdentity(req) {
  const {specifier, signature = LATEST_SIGNATURE} = req.params;
  if (validateSpecifier(specifier) === false) {
    throw new Error("dot-dot-slash is not allowed for resource specifier");
  }
  const resourceId = explodeSpecifier(specifier);
  return {
    resourceId,
    signature
  };
}
function getAssetIdentity(req) {
  const {signature = LATEST_SIGNATURE, assetType: type} = req.params;
  const [specifier] = req.originalUrl.split("?");
  if (validateSpecifier(specifier) === false) {
    throw new Error("dot-dot-slash is not allowed for asset specifier");
  }
  return {
    assetId: {
      specifier,
      type
    },
    signature
  };
}
