import { cac } from 'cac';
import { readFileSync } from 'fs';
import { DiagnosticsError } from '@lwrjs/diagnostics';
import chalk from 'chalk';
import { launch } from './utils.js';
const { version } = JSON.parse(readFileSync(new URL('../../../package.json', import.meta.url), 'utf-8'));
const cli = cac('lwr');
// global options
cli.option('-c, --config <file>', `[string] use specified config file`)
    .option('-r, --root <path>', `[string] use specified root directory`)
    .option('--base <path>', `[string] public base path (default: /)`)
    .option('-m, --mode <mode>', `[string] set env mode`);
// .option('-l, --logLevel <level>', `[string] info | warn | error | silent`)
// .option('-d, --debug [feat]', `[string | boolean] show debug logs`)
// .option('-f, --filter <filter>', `[string] filter debug logs`)
// default no-command (errors out)
cli.command('').action((o) => {
    console.error(chalk.red(`Invalid command`));
    cli.outputHelp();
    process.exit(1);
});
// server command
cli.command('serve', 'Starts an LWR server (defaults to dev mode)')
    .alias('dev')
    .option('--port <port>', `[number] specify port`)
    .option('--mode <mode>', '[string] server mode')
    .option('--open <path>', `[boolean | string] open browser on startup`)
    // .option('--https', `[boolean] use TLS + HTTP/2`)
    // .option('--strictPort', `[boolean] exit if specified port is already in use`)
    // .option('--force', `[boolean] force the optimizer to ignore the cache and re-bundle`)
    .action(async (options) => {
    const { createServer } = await import('@lwrjs/core');
    const { port, mode = 'dev', open } = options;
    try {
        const server = await createServer({ port, serverMode: mode });
        await server.listen(async ({ serverMode, port }) => {
            console.log(chalk.green(`Running LWR v${version} at: http://localhost:${port} | mode: ${serverMode}`));
            if (open) {
                await launch(port);
            }
        });
    }
    catch (error) {
        if (error instanceof DiagnosticsError) {
            console.log(error.diagnostics);
            process.exit(1);
        }
        else {
            throw error;
        }
    }
});
cli.command('build', 'Builds a static LWR site') // default command
    .alias('static-build')
    .option('--outputDir <directory>', `[string] output directory`)
    .action(async (options) => {
    const { outputDir, mode = process.env.MODE || 'prod' } = options;
    const { generateStaticSite } = await import('@lwrjs/core');
    try {
        await generateStaticSite({
            serverMode: mode,
            staticSiteGenerator: { outputDir },
        });
    }
    catch (error) {
        if (error instanceof DiagnosticsError) {
            console.log(error.diagnostics);
            process.exit(1);
        }
        else {
            throw error;
        }
    }
});
cli.command('bundle-lambda', 'Bundles the lambda source')
    .option('--entryPoint <entry>', '[string] bundling entry point')
    .option('--format <format>', '[string] bundle output format')
    .action(async (options) => {
    const entryPoint = options.entryPoint || './src/index.ts';
    const format = options.format || 'esm';
    try {
        const { bundleLambda } = await import('./commands/bundle-lambda.js');
        await bundleLambda({ entryPoint, format });
    }
    catch (error) {
        if (error instanceof DiagnosticsError) {
            console.log(error.diagnostics);
            process.exit(1);
        }
        else {
            throw error;
        }
    }
});
cli.on('command:*', () => {
    console.error(chalk.redBright(`Invalid command: ${cli.args.join(' ')}`));
    cli.outputHelp();
    process.exit(1);
});
cli.help();
cli.version(version);
cli.parse();
//# sourceMappingURL=cli.js.map