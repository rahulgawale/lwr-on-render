import fs from 'fs';
import path from 'path';
import { build } from 'esbuild';
import { NodeVM } from 'vm2';
import { createServer } from '@lwrjs/core';
import ESM_REQUIRE_SHIM from './shims/esm-require-shim.js';
import LWR_LAMBDA_SHIM from './shims/lwr-lambda-shim.js';
export async function bundleLambda({ entryPoint, format }) {
    // get createHandler config argument
    const arg = await getConfigArg(entryPoint);
    // HACK: creating server just for config loading
    const server = createServer(arg);
    const config = server.getConfig();
    // generate the lambda shim source
    const lambdaShim = generateLambdaShim(config);
    const buildDir = path.resolve('./build/generated');
    const lambdaShimPath = path.join(buildDir, 'lwr-lambda-shim.js');
    fs.mkdirSync(buildDir, { recursive: true });
    fs.writeFileSync(lambdaShimPath, lambdaShim);
    // bundle lambda handler and inject the lwr shim
    const options = {
        bundle: true,
        format,
        treeShaking: true,
        entryPoints: [entryPoint],
        outdir: './build',
        platform: 'node',
        external: ['fsevents', 'esbuild', 'iltorb', 'rollup', 'esinstall', 'rollup-plugin-node-polyfills'],
        inject: [lambdaShimPath],
    };
    if (format === 'esm') {
        options.banner = {
            js: ESM_REQUIRE_SHIM,
        };
    }
    build(options);
}
async function getConfigArg(entryPoint) {
    // bundle lambda source for execution in a sandbox
    const result = await build({
        entryPoints: [entryPoint],
        bundle: true,
        write: false,
        format: 'cjs',
        platform: 'node',
        external: [
            // skip @lwrjs/lambda/aws because it will be mocked at execution
            '@lwrjs/lambda/aws',
        ],
    });
    // execute lambda source with mocked createHandler to capture config
    const lambda = result.outputFiles[0].text;
    const vm = new NodeVM({
        console: 'inherit',
        sandbox: {},
        require: {
            external: true,
            builtin: ['*'],
            root: [path.dirname(entryPoint)],
            mock: {
                '@lwrjs/lambda/aws': {
                    createHandler: (arg) => {
                        return arg;
                    },
                },
            },
        },
    });
    try {
        const { get } = vm.run(lambda);
        return get;
    }
    catch (e) {
        console.error(e);
        process.exit(1);
    }
}
function generateLambdaShim(config) {
    const serviceCtors = [];
    const services = [];
    const serviceConfigs = [];
    // module provider generation
    for (const [index, [servicePath, serviceConfig = {}]] of config.moduleProviders.entries()) {
        serviceCtors.push(`import ServiceCtor${index} from '${servicePath}';`);
        services.push(`ServiceCtor${index}`);
        serviceConfigs.push(JSON.stringify(serviceConfig));
    }
    const hookCtors = [];
    const hooks = [];
    const hookConfigs = [];
    // hooks generation
    for (const [index, [hookPath, hookConfig = {}]] of config.moduleProviders.entries()) {
        hookCtors.push(`import HookCtor${index} from '${hookPath}';`);
        hooks.push(`HookCtor${index}`);
        hookConfigs.push(JSON.stringify(hookConfig));
    }
    return LWR_LAMBDA_SHIM.replace('{ serviceCtors }', serviceCtors.join('\n'))
        .replace('{ services }', services.join())
        .replace('{ serviceConfigs }', serviceConfigs.join())
        .replace('{ hookCtors }', hookCtors.join('\n'))
        .replace('{ hooks }', hooks.join())
        .replace('{ hookConfigs }', hookConfigs.join());
}
//# sourceMappingURL=bundle-lambda.js.map